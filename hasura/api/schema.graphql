schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

type ActionAddress {
  address: String!
}

type ActionBalance {
  coins: [ActionCoin]
}

scalar ActionCoin

scalar ActionDelegation

type ActionDelegationResponse {
  delegations: [ActionDelegation]
  pagination: ActionPagination
}

type ActionDelegationReward {
  coins: [ActionCoin]
  validator_address: String!
}

scalar ActionPagination

scalar ActionRedelegation

type ActionRedelegationResponse {
  pagination: ActionPagination
  redelegations: [ActionRedelegation]
}

scalar ActionUnbondingDelegation

type ActionUnbondingDelegationResponse {
  pagination: ActionPagination
  unbonding_delegations: [ActionUnbondingDelegation]
}

type ActionValidatorCommissionAmount {
  coins: [ActionCoin]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

scalar _coin

"""
Boolean expression to compare columns of type "_coin". All fields are combined with logical 'AND'.
"""
input _coin_comparison_exp {
  _eq: _coin
  _gt: _coin
  _gte: _coin
  _in: [_coin!]
  _is_null: Boolean
  _lt: _coin
  _lte: _coin
  _neq: _coin
  _nin: [_coin!]
}

scalar _dec_coin

"""
Boolean expression to compare columns of type "_dec_coin". All fields are combined with logical 'AND'.
"""
input _dec_coin_comparison_exp {
  _eq: _dec_coin
  _gt: _dec_coin
  _gte: _dec_coin
  _in: [_dec_coin!]
  _is_null: Boolean
  _lt: _dec_coin
  _lte: _dec_coin
  _neq: _dec_coin
  _nin: [_dec_coin!]
}

scalar _text

"""
Boolean expression to compare columns of type "_text". All fields are combined with logical 'AND'.
"""
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

"""
columns and relationships of "account"
"""
type account {
  address: String!

  """An array relationship"""
  proposal_deposits(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): [proposal_deposit!]!

  """An aggregate relationship"""
  proposal_deposits_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): proposal_deposit_aggregate!

  """An array relationship"""
  proposal_votes(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): [proposal_vote!]!

  """An aggregate relationship"""
  proposal_votes_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): proposal_vote_aggregate!

  """An array relationship"""
  proposals(
    """distinct select on columns"""
    distinct_on: [proposal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_order_by!]

    """filter the rows returned"""
    where: proposal_bool_exp
  ): [proposal!]!

  """An aggregate relationship"""
  proposals_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_order_by!]

    """filter the rows returned"""
    where: proposal_bool_exp
  ): proposal_aggregate!

  """An array relationship"""
  validator_infos(
    """distinct select on columns"""
    distinct_on: [validator_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_info_order_by!]

    """filter the rows returned"""
    where: validator_info_bool_exp
  ): [validator_info!]!

  """An aggregate relationship"""
  validator_infos_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_info_order_by!]

    """filter the rows returned"""
    where: validator_info_bool_exp
  ): validator_info_aggregate!

  """An object relationship"""
  vesting_account: vesting_account

  """An array relationship"""
  vesting_accounts(
    """distinct select on columns"""
    distinct_on: [vesting_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_account_order_by!]

    """filter the rows returned"""
    where: vesting_account_bool_exp
  ): [vesting_account!]!

  """An aggregate relationship"""
  vesting_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [vesting_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_account_order_by!]

    """filter the rows returned"""
    where: vesting_account_bool_exp
  ): vesting_account_aggregate!
}

"""
aggregated selection of "account"
"""
type account_aggregate {
  aggregate: account_aggregate_fields
  nodes: [account!]!
}

"""
aggregate fields of "account"
"""
type account_aggregate_fields {
  count(columns: [account_select_column!], distinct: Boolean): Int!
  max: account_max_fields
  min: account_min_fields
}

"""
Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
"""
input account_bool_exp {
  _and: [account_bool_exp!]
  _not: account_bool_exp
  _or: [account_bool_exp!]
  address: String_comparison_exp
  proposal_deposits: proposal_deposit_bool_exp
  proposal_votes: proposal_vote_bool_exp
  proposals: proposal_bool_exp
  validator_infos: validator_info_bool_exp
  vesting_account: vesting_account_bool_exp
  vesting_accounts: vesting_account_bool_exp
}

"""
unique or primary key constraints on table "account"
"""
enum account_constraint {
  """unique or primary key constraint"""
  account_pkey
}

"""
input type for inserting data into table "account"
"""
input account_insert_input {
  address: String
  proposal_deposits: proposal_deposit_arr_rel_insert_input
  proposal_votes: proposal_vote_arr_rel_insert_input
  proposals: proposal_arr_rel_insert_input
  validator_infos: validator_info_arr_rel_insert_input
  vesting_account: vesting_account_obj_rel_insert_input
  vesting_accounts: vesting_account_arr_rel_insert_input
}

"""aggregate max on columns"""
type account_max_fields {
  address: String
}

"""aggregate min on columns"""
type account_min_fields {
  address: String
}

"""
response of any mutation on the table "account"
"""
type account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [account!]!
}

"""
input type for inserting object relation for remote table "account"
"""
input account_obj_rel_insert_input {
  data: account_insert_input!

  """on conflict condition"""
  on_conflict: account_on_conflict
}

"""
on conflict condition type for table "account"
"""
input account_on_conflict {
  constraint: account_constraint!
  update_columns: [account_update_column!]! = []
  where: account_bool_exp
}

"""Ordering options when selecting data from "account"."""
input account_order_by {
  address: order_by
  proposal_deposits_aggregate: proposal_deposit_aggregate_order_by
  proposal_votes_aggregate: proposal_vote_aggregate_order_by
  proposals_aggregate: proposal_aggregate_order_by
  validator_infos_aggregate: validator_info_aggregate_order_by
  vesting_account: vesting_account_order_by
  vesting_accounts_aggregate: vesting_account_aggregate_order_by
}

"""primary key columns input for table: account"""
input account_pk_columns_input {
  address: String!
}

"""
select columns of table "account"
"""
enum account_select_column {
  """column name"""
  address
}

"""
input type for updating data in table "account"
"""
input account_set_input {
  address: String
}

"""
update columns of table "account"
"""
enum account_update_column {
  """column name"""
  address
}

"""
columns and relationships of "assetft_params"
"""
type assetft_params {
  height: bigint!
  one_row_id: Boolean!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "assetft_params"
"""
type assetft_params_aggregate {
  aggregate: assetft_params_aggregate_fields
  nodes: [assetft_params!]!
}

"""
aggregate fields of "assetft_params"
"""
type assetft_params_aggregate_fields {
  avg: assetft_params_avg_fields
  count(columns: [assetft_params_select_column!], distinct: Boolean): Int!
  max: assetft_params_max_fields
  min: assetft_params_min_fields
  stddev: assetft_params_stddev_fields
  stddev_pop: assetft_params_stddev_pop_fields
  stddev_samp: assetft_params_stddev_samp_fields
  sum: assetft_params_sum_fields
  var_pop: assetft_params_var_pop_fields
  var_samp: assetft_params_var_samp_fields
  variance: assetft_params_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input assetft_params_append_input {
  params: jsonb
}

"""aggregate avg on columns"""
type assetft_params_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "assetft_params". All fields are combined with a logical 'AND'.
"""
input assetft_params_bool_exp {
  _and: [assetft_params_bool_exp!]
  _not: assetft_params_bool_exp
  _or: [assetft_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "assetft_params"
"""
enum assetft_params_constraint {
  """unique or primary key constraint"""
  assetft_params_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input assetft_params_delete_at_path_input {
  params: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input assetft_params_delete_elem_input {
  params: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input assetft_params_delete_key_input {
  params: String
}

"""
input type for incrementing numeric columns in table "assetft_params"
"""
input assetft_params_inc_input {
  height: bigint
}

"""
input type for inserting data into table "assetft_params"
"""
input assetft_params_insert_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate max on columns"""
type assetft_params_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type assetft_params_min_fields {
  height: bigint
}

"""
response of any mutation on the table "assetft_params"
"""
type assetft_params_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [assetft_params!]!
}

"""
on conflict condition type for table "assetft_params"
"""
input assetft_params_on_conflict {
  constraint: assetft_params_constraint!
  update_columns: [assetft_params_update_column!]! = []
  where: assetft_params_bool_exp
}

"""Ordering options when selecting data from "assetft_params"."""
input assetft_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"""primary key columns input for table: assetft_params"""
input assetft_params_pk_columns_input {
  one_row_id: Boolean!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input assetft_params_prepend_input {
  params: jsonb
}

"""
select columns of table "assetft_params"
"""
enum assetft_params_select_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""
input type for updating data in table "assetft_params"
"""
input assetft_params_set_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate stddev on columns"""
type assetft_params_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type assetft_params_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type assetft_params_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type assetft_params_sum_fields {
  height: bigint
}

"""
update columns of table "assetft_params"
"""
enum assetft_params_update_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""aggregate var_pop on columns"""
type assetft_params_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type assetft_params_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type assetft_params_variance_fields {
  height: Float
}

"""
columns and relationships of "assetnft_params"
"""
type assetnft_params {
  height: bigint!
  one_row_id: Boolean!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "assetnft_params"
"""
type assetnft_params_aggregate {
  aggregate: assetnft_params_aggregate_fields
  nodes: [assetnft_params!]!
}

"""
aggregate fields of "assetnft_params"
"""
type assetnft_params_aggregate_fields {
  avg: assetnft_params_avg_fields
  count(columns: [assetnft_params_select_column!], distinct: Boolean): Int!
  max: assetnft_params_max_fields
  min: assetnft_params_min_fields
  stddev: assetnft_params_stddev_fields
  stddev_pop: assetnft_params_stddev_pop_fields
  stddev_samp: assetnft_params_stddev_samp_fields
  sum: assetnft_params_sum_fields
  var_pop: assetnft_params_var_pop_fields
  var_samp: assetnft_params_var_samp_fields
  variance: assetnft_params_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input assetnft_params_append_input {
  params: jsonb
}

"""aggregate avg on columns"""
type assetnft_params_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "assetnft_params". All fields are combined with a logical 'AND'.
"""
input assetnft_params_bool_exp {
  _and: [assetnft_params_bool_exp!]
  _not: assetnft_params_bool_exp
  _or: [assetnft_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "assetnft_params"
"""
enum assetnft_params_constraint {
  """unique or primary key constraint"""
  assetnft_params_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input assetnft_params_delete_at_path_input {
  params: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input assetnft_params_delete_elem_input {
  params: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input assetnft_params_delete_key_input {
  params: String
}

"""
input type for incrementing numeric columns in table "assetnft_params"
"""
input assetnft_params_inc_input {
  height: bigint
}

"""
input type for inserting data into table "assetnft_params"
"""
input assetnft_params_insert_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate max on columns"""
type assetnft_params_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type assetnft_params_min_fields {
  height: bigint
}

"""
response of any mutation on the table "assetnft_params"
"""
type assetnft_params_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [assetnft_params!]!
}

"""
on conflict condition type for table "assetnft_params"
"""
input assetnft_params_on_conflict {
  constraint: assetnft_params_constraint!
  update_columns: [assetnft_params_update_column!]! = []
  where: assetnft_params_bool_exp
}

"""Ordering options when selecting data from "assetnft_params"."""
input assetnft_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"""primary key columns input for table: assetnft_params"""
input assetnft_params_pk_columns_input {
  one_row_id: Boolean!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input assetnft_params_prepend_input {
  params: jsonb
}

"""
select columns of table "assetnft_params"
"""
enum assetnft_params_select_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""
input type for updating data in table "assetnft_params"
"""
input assetnft_params_set_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate stddev on columns"""
type assetnft_params_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type assetnft_params_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type assetnft_params_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type assetnft_params_sum_fields {
  height: bigint
}

"""
update columns of table "assetnft_params"
"""
enum assetnft_params_update_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""aggregate var_pop on columns"""
type assetnft_params_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type assetnft_params_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type assetnft_params_variance_fields {
  height: Float
}

"""
columns and relationships of "average_block_time_from_genesis"
"""
type average_block_time_from_genesis {
  average_time: numeric!
  height: bigint!
  one_row_id: Boolean!
}

"""
aggregated selection of "average_block_time_from_genesis"
"""
type average_block_time_from_genesis_aggregate {
  aggregate: average_block_time_from_genesis_aggregate_fields
  nodes: [average_block_time_from_genesis!]!
}

"""
aggregate fields of "average_block_time_from_genesis"
"""
type average_block_time_from_genesis_aggregate_fields {
  avg: average_block_time_from_genesis_avg_fields
  count(columns: [average_block_time_from_genesis_select_column!], distinct: Boolean): Int!
  max: average_block_time_from_genesis_max_fields
  min: average_block_time_from_genesis_min_fields
  stddev: average_block_time_from_genesis_stddev_fields
  stddev_pop: average_block_time_from_genesis_stddev_pop_fields
  stddev_samp: average_block_time_from_genesis_stddev_samp_fields
  sum: average_block_time_from_genesis_sum_fields
  var_pop: average_block_time_from_genesis_var_pop_fields
  var_samp: average_block_time_from_genesis_var_samp_fields
  variance: average_block_time_from_genesis_variance_fields
}

"""aggregate avg on columns"""
type average_block_time_from_genesis_avg_fields {
  average_time: Float
  height: Float
}

"""
Boolean expression to filter rows from the table "average_block_time_from_genesis". All fields are combined with a logical 'AND'.
"""
input average_block_time_from_genesis_bool_exp {
  _and: [average_block_time_from_genesis_bool_exp!]
  _not: average_block_time_from_genesis_bool_exp
  _or: [average_block_time_from_genesis_bool_exp!]
  average_time: numeric_comparison_exp
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "average_block_time_from_genesis"
"""
enum average_block_time_from_genesis_constraint {
  """unique or primary key constraint"""
  average_block_time_from_genesis_pkey
}

"""
input type for incrementing numeric columns in table "average_block_time_from_genesis"
"""
input average_block_time_from_genesis_inc_input {
  average_time: numeric
  height: bigint
}

"""
input type for inserting data into table "average_block_time_from_genesis"
"""
input average_block_time_from_genesis_insert_input {
  average_time: numeric
  height: bigint
  one_row_id: Boolean
}

"""aggregate max on columns"""
type average_block_time_from_genesis_max_fields {
  average_time: numeric
  height: bigint
}

"""aggregate min on columns"""
type average_block_time_from_genesis_min_fields {
  average_time: numeric
  height: bigint
}

"""
response of any mutation on the table "average_block_time_from_genesis"
"""
type average_block_time_from_genesis_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [average_block_time_from_genesis!]!
}

"""
on conflict condition type for table "average_block_time_from_genesis"
"""
input average_block_time_from_genesis_on_conflict {
  constraint: average_block_time_from_genesis_constraint!
  update_columns: [average_block_time_from_genesis_update_column!]! = []
  where: average_block_time_from_genesis_bool_exp
}

"""
Ordering options when selecting data from "average_block_time_from_genesis".
"""
input average_block_time_from_genesis_order_by {
  average_time: order_by
  height: order_by
  one_row_id: order_by
}

"""primary key columns input for table: average_block_time_from_genesis"""
input average_block_time_from_genesis_pk_columns_input {
  one_row_id: Boolean!
}

"""
select columns of table "average_block_time_from_genesis"
"""
enum average_block_time_from_genesis_select_column {
  """column name"""
  average_time

  """column name"""
  height

  """column name"""
  one_row_id
}

"""
input type for updating data in table "average_block_time_from_genesis"
"""
input average_block_time_from_genesis_set_input {
  average_time: numeric
  height: bigint
  one_row_id: Boolean
}

"""aggregate stddev on columns"""
type average_block_time_from_genesis_stddev_fields {
  average_time: Float
  height: Float
}

"""aggregate stddev_pop on columns"""
type average_block_time_from_genesis_stddev_pop_fields {
  average_time: Float
  height: Float
}

"""aggregate stddev_samp on columns"""
type average_block_time_from_genesis_stddev_samp_fields {
  average_time: Float
  height: Float
}

"""aggregate sum on columns"""
type average_block_time_from_genesis_sum_fields {
  average_time: numeric
  height: bigint
}

"""
update columns of table "average_block_time_from_genesis"
"""
enum average_block_time_from_genesis_update_column {
  """column name"""
  average_time

  """column name"""
  height

  """column name"""
  one_row_id
}

"""aggregate var_pop on columns"""
type average_block_time_from_genesis_var_pop_fields {
  average_time: Float
  height: Float
}

"""aggregate var_samp on columns"""
type average_block_time_from_genesis_var_samp_fields {
  average_time: Float
  height: Float
}

"""aggregate variance on columns"""
type average_block_time_from_genesis_variance_fields {
  average_time: Float
  height: Float
}

"""
columns and relationships of "average_block_time_per_day"
"""
type average_block_time_per_day {
  average_time: numeric!
  height: bigint!
  one_row_id: Boolean!
}

"""
aggregated selection of "average_block_time_per_day"
"""
type average_block_time_per_day_aggregate {
  aggregate: average_block_time_per_day_aggregate_fields
  nodes: [average_block_time_per_day!]!
}

"""
aggregate fields of "average_block_time_per_day"
"""
type average_block_time_per_day_aggregate_fields {
  avg: average_block_time_per_day_avg_fields
  count(columns: [average_block_time_per_day_select_column!], distinct: Boolean): Int!
  max: average_block_time_per_day_max_fields
  min: average_block_time_per_day_min_fields
  stddev: average_block_time_per_day_stddev_fields
  stddev_pop: average_block_time_per_day_stddev_pop_fields
  stddev_samp: average_block_time_per_day_stddev_samp_fields
  sum: average_block_time_per_day_sum_fields
  var_pop: average_block_time_per_day_var_pop_fields
  var_samp: average_block_time_per_day_var_samp_fields
  variance: average_block_time_per_day_variance_fields
}

"""aggregate avg on columns"""
type average_block_time_per_day_avg_fields {
  average_time: Float
  height: Float
}

"""
Boolean expression to filter rows from the table "average_block_time_per_day". All fields are combined with a logical 'AND'.
"""
input average_block_time_per_day_bool_exp {
  _and: [average_block_time_per_day_bool_exp!]
  _not: average_block_time_per_day_bool_exp
  _or: [average_block_time_per_day_bool_exp!]
  average_time: numeric_comparison_exp
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "average_block_time_per_day"
"""
enum average_block_time_per_day_constraint {
  """unique or primary key constraint"""
  average_block_time_per_day_pkey
}

"""
input type for incrementing numeric columns in table "average_block_time_per_day"
"""
input average_block_time_per_day_inc_input {
  average_time: numeric
  height: bigint
}

"""
input type for inserting data into table "average_block_time_per_day"
"""
input average_block_time_per_day_insert_input {
  average_time: numeric
  height: bigint
  one_row_id: Boolean
}

"""aggregate max on columns"""
type average_block_time_per_day_max_fields {
  average_time: numeric
  height: bigint
}

"""aggregate min on columns"""
type average_block_time_per_day_min_fields {
  average_time: numeric
  height: bigint
}

"""
response of any mutation on the table "average_block_time_per_day"
"""
type average_block_time_per_day_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [average_block_time_per_day!]!
}

"""
on conflict condition type for table "average_block_time_per_day"
"""
input average_block_time_per_day_on_conflict {
  constraint: average_block_time_per_day_constraint!
  update_columns: [average_block_time_per_day_update_column!]! = []
  where: average_block_time_per_day_bool_exp
}

"""
Ordering options when selecting data from "average_block_time_per_day".
"""
input average_block_time_per_day_order_by {
  average_time: order_by
  height: order_by
  one_row_id: order_by
}

"""primary key columns input for table: average_block_time_per_day"""
input average_block_time_per_day_pk_columns_input {
  one_row_id: Boolean!
}

"""
select columns of table "average_block_time_per_day"
"""
enum average_block_time_per_day_select_column {
  """column name"""
  average_time

  """column name"""
  height

  """column name"""
  one_row_id
}

"""
input type for updating data in table "average_block_time_per_day"
"""
input average_block_time_per_day_set_input {
  average_time: numeric
  height: bigint
  one_row_id: Boolean
}

"""aggregate stddev on columns"""
type average_block_time_per_day_stddev_fields {
  average_time: Float
  height: Float
}

"""aggregate stddev_pop on columns"""
type average_block_time_per_day_stddev_pop_fields {
  average_time: Float
  height: Float
}

"""aggregate stddev_samp on columns"""
type average_block_time_per_day_stddev_samp_fields {
  average_time: Float
  height: Float
}

"""aggregate sum on columns"""
type average_block_time_per_day_sum_fields {
  average_time: numeric
  height: bigint
}

"""
update columns of table "average_block_time_per_day"
"""
enum average_block_time_per_day_update_column {
  """column name"""
  average_time

  """column name"""
  height

  """column name"""
  one_row_id
}

"""aggregate var_pop on columns"""
type average_block_time_per_day_var_pop_fields {
  average_time: Float
  height: Float
}

"""aggregate var_samp on columns"""
type average_block_time_per_day_var_samp_fields {
  average_time: Float
  height: Float
}

"""aggregate variance on columns"""
type average_block_time_per_day_variance_fields {
  average_time: Float
  height: Float
}

"""
columns and relationships of "average_block_time_per_hour"
"""
type average_block_time_per_hour {
  average_time: numeric!
  height: bigint!
  one_row_id: Boolean!
}

"""
aggregated selection of "average_block_time_per_hour"
"""
type average_block_time_per_hour_aggregate {
  aggregate: average_block_time_per_hour_aggregate_fields
  nodes: [average_block_time_per_hour!]!
}

"""
aggregate fields of "average_block_time_per_hour"
"""
type average_block_time_per_hour_aggregate_fields {
  avg: average_block_time_per_hour_avg_fields
  count(columns: [average_block_time_per_hour_select_column!], distinct: Boolean): Int!
  max: average_block_time_per_hour_max_fields
  min: average_block_time_per_hour_min_fields
  stddev: average_block_time_per_hour_stddev_fields
  stddev_pop: average_block_time_per_hour_stddev_pop_fields
  stddev_samp: average_block_time_per_hour_stddev_samp_fields
  sum: average_block_time_per_hour_sum_fields
  var_pop: average_block_time_per_hour_var_pop_fields
  var_samp: average_block_time_per_hour_var_samp_fields
  variance: average_block_time_per_hour_variance_fields
}

"""aggregate avg on columns"""
type average_block_time_per_hour_avg_fields {
  average_time: Float
  height: Float
}

"""
Boolean expression to filter rows from the table "average_block_time_per_hour". All fields are combined with a logical 'AND'.
"""
input average_block_time_per_hour_bool_exp {
  _and: [average_block_time_per_hour_bool_exp!]
  _not: average_block_time_per_hour_bool_exp
  _or: [average_block_time_per_hour_bool_exp!]
  average_time: numeric_comparison_exp
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "average_block_time_per_hour"
"""
enum average_block_time_per_hour_constraint {
  """unique or primary key constraint"""
  average_block_time_per_hour_pkey
}

"""
input type for incrementing numeric columns in table "average_block_time_per_hour"
"""
input average_block_time_per_hour_inc_input {
  average_time: numeric
  height: bigint
}

"""
input type for inserting data into table "average_block_time_per_hour"
"""
input average_block_time_per_hour_insert_input {
  average_time: numeric
  height: bigint
  one_row_id: Boolean
}

"""aggregate max on columns"""
type average_block_time_per_hour_max_fields {
  average_time: numeric
  height: bigint
}

"""aggregate min on columns"""
type average_block_time_per_hour_min_fields {
  average_time: numeric
  height: bigint
}

"""
response of any mutation on the table "average_block_time_per_hour"
"""
type average_block_time_per_hour_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [average_block_time_per_hour!]!
}

"""
on conflict condition type for table "average_block_time_per_hour"
"""
input average_block_time_per_hour_on_conflict {
  constraint: average_block_time_per_hour_constraint!
  update_columns: [average_block_time_per_hour_update_column!]! = []
  where: average_block_time_per_hour_bool_exp
}

"""
Ordering options when selecting data from "average_block_time_per_hour".
"""
input average_block_time_per_hour_order_by {
  average_time: order_by
  height: order_by
  one_row_id: order_by
}

"""primary key columns input for table: average_block_time_per_hour"""
input average_block_time_per_hour_pk_columns_input {
  one_row_id: Boolean!
}

"""
select columns of table "average_block_time_per_hour"
"""
enum average_block_time_per_hour_select_column {
  """column name"""
  average_time

  """column name"""
  height

  """column name"""
  one_row_id
}

"""
input type for updating data in table "average_block_time_per_hour"
"""
input average_block_time_per_hour_set_input {
  average_time: numeric
  height: bigint
  one_row_id: Boolean
}

"""aggregate stddev on columns"""
type average_block_time_per_hour_stddev_fields {
  average_time: Float
  height: Float
}

"""aggregate stddev_pop on columns"""
type average_block_time_per_hour_stddev_pop_fields {
  average_time: Float
  height: Float
}

"""aggregate stddev_samp on columns"""
type average_block_time_per_hour_stddev_samp_fields {
  average_time: Float
  height: Float
}

"""aggregate sum on columns"""
type average_block_time_per_hour_sum_fields {
  average_time: numeric
  height: bigint
}

"""
update columns of table "average_block_time_per_hour"
"""
enum average_block_time_per_hour_update_column {
  """column name"""
  average_time

  """column name"""
  height

  """column name"""
  one_row_id
}

"""aggregate var_pop on columns"""
type average_block_time_per_hour_var_pop_fields {
  average_time: Float
  height: Float
}

"""aggregate var_samp on columns"""
type average_block_time_per_hour_var_samp_fields {
  average_time: Float
  height: Float
}

"""aggregate variance on columns"""
type average_block_time_per_hour_variance_fields {
  average_time: Float
  height: Float
}

"""
columns and relationships of "average_block_time_per_minute"
"""
type average_block_time_per_minute {
  average_time: numeric!
  height: bigint!
  one_row_id: Boolean!
}

"""
aggregated selection of "average_block_time_per_minute"
"""
type average_block_time_per_minute_aggregate {
  aggregate: average_block_time_per_minute_aggregate_fields
  nodes: [average_block_time_per_minute!]!
}

"""
aggregate fields of "average_block_time_per_minute"
"""
type average_block_time_per_minute_aggregate_fields {
  avg: average_block_time_per_minute_avg_fields
  count(columns: [average_block_time_per_minute_select_column!], distinct: Boolean): Int!
  max: average_block_time_per_minute_max_fields
  min: average_block_time_per_minute_min_fields
  stddev: average_block_time_per_minute_stddev_fields
  stddev_pop: average_block_time_per_minute_stddev_pop_fields
  stddev_samp: average_block_time_per_minute_stddev_samp_fields
  sum: average_block_time_per_minute_sum_fields
  var_pop: average_block_time_per_minute_var_pop_fields
  var_samp: average_block_time_per_minute_var_samp_fields
  variance: average_block_time_per_minute_variance_fields
}

"""aggregate avg on columns"""
type average_block_time_per_minute_avg_fields {
  average_time: Float
  height: Float
}

"""
Boolean expression to filter rows from the table "average_block_time_per_minute". All fields are combined with a logical 'AND'.
"""
input average_block_time_per_minute_bool_exp {
  _and: [average_block_time_per_minute_bool_exp!]
  _not: average_block_time_per_minute_bool_exp
  _or: [average_block_time_per_minute_bool_exp!]
  average_time: numeric_comparison_exp
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "average_block_time_per_minute"
"""
enum average_block_time_per_minute_constraint {
  """unique or primary key constraint"""
  average_block_time_per_minute_pkey
}

"""
input type for incrementing numeric columns in table "average_block_time_per_minute"
"""
input average_block_time_per_minute_inc_input {
  average_time: numeric
  height: bigint
}

"""
input type for inserting data into table "average_block_time_per_minute"
"""
input average_block_time_per_minute_insert_input {
  average_time: numeric
  height: bigint
  one_row_id: Boolean
}

"""aggregate max on columns"""
type average_block_time_per_minute_max_fields {
  average_time: numeric
  height: bigint
}

"""aggregate min on columns"""
type average_block_time_per_minute_min_fields {
  average_time: numeric
  height: bigint
}

"""
response of any mutation on the table "average_block_time_per_minute"
"""
type average_block_time_per_minute_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [average_block_time_per_minute!]!
}

"""
on conflict condition type for table "average_block_time_per_minute"
"""
input average_block_time_per_minute_on_conflict {
  constraint: average_block_time_per_minute_constraint!
  update_columns: [average_block_time_per_minute_update_column!]! = []
  where: average_block_time_per_minute_bool_exp
}

"""
Ordering options when selecting data from "average_block_time_per_minute".
"""
input average_block_time_per_minute_order_by {
  average_time: order_by
  height: order_by
  one_row_id: order_by
}

"""primary key columns input for table: average_block_time_per_minute"""
input average_block_time_per_minute_pk_columns_input {
  one_row_id: Boolean!
}

"""
select columns of table "average_block_time_per_minute"
"""
enum average_block_time_per_minute_select_column {
  """column name"""
  average_time

  """column name"""
  height

  """column name"""
  one_row_id
}

"""
input type for updating data in table "average_block_time_per_minute"
"""
input average_block_time_per_minute_set_input {
  average_time: numeric
  height: bigint
  one_row_id: Boolean
}

"""aggregate stddev on columns"""
type average_block_time_per_minute_stddev_fields {
  average_time: Float
  height: Float
}

"""aggregate stddev_pop on columns"""
type average_block_time_per_minute_stddev_pop_fields {
  average_time: Float
  height: Float
}

"""aggregate stddev_samp on columns"""
type average_block_time_per_minute_stddev_samp_fields {
  average_time: Float
  height: Float
}

"""aggregate sum on columns"""
type average_block_time_per_minute_sum_fields {
  average_time: numeric
  height: bigint
}

"""
update columns of table "average_block_time_per_minute"
"""
enum average_block_time_per_minute_update_column {
  """column name"""
  average_time

  """column name"""
  height

  """column name"""
  one_row_id
}

"""aggregate var_pop on columns"""
type average_block_time_per_minute_var_pop_fields {
  average_time: Float
  height: Float
}

"""aggregate var_samp on columns"""
type average_block_time_per_minute_var_samp_fields {
  average_time: Float
  height: Float
}

"""aggregate variance on columns"""
type average_block_time_per_minute_variance_fields {
  average_time: Float
  height: Float
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "block"
"""
type block {
  hash: String!
  height: bigint!
  num_txs: Int

  """An array relationship"""
  pre_commits(
    """distinct select on columns"""
    distinct_on: [pre_commit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pre_commit_order_by!]

    """filter the rows returned"""
    where: pre_commit_bool_exp
  ): [pre_commit!]!

  """An aggregate relationship"""
  pre_commits_aggregate(
    """distinct select on columns"""
    distinct_on: [pre_commit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pre_commit_order_by!]

    """filter the rows returned"""
    where: pre_commit_bool_exp
  ): pre_commit_aggregate!

  """An array relationship"""
  proposal_deposits(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): [proposal_deposit!]!

  """An aggregate relationship"""
  proposal_deposits_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): proposal_deposit_aggregate!

  """An array relationship"""
  proposal_votes(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): [proposal_vote!]!

  """An aggregate relationship"""
  proposal_votes_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): proposal_vote_aggregate!
  proposer_address: String
  timestamp: timestamp!
  total_gas: bigint

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """An aggregate relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """An object relationship"""
  validator: validator

  """An array relationship"""
  validator_voting_powers(
    """distinct select on columns"""
    distinct_on: [validator_voting_power_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_voting_power_order_by!]

    """filter the rows returned"""
    where: validator_voting_power_bool_exp
  ): [validator_voting_power!]!

  """An aggregate relationship"""
  validator_voting_powers_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_voting_power_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_voting_power_order_by!]

    """filter the rows returned"""
    where: validator_voting_power_bool_exp
  ): validator_voting_power_aggregate!
}

"""
aggregated selection of "block"
"""
type block_aggregate {
  aggregate: block_aggregate_fields
  nodes: [block!]!
}

"""
aggregate fields of "block"
"""
type block_aggregate_fields {
  avg: block_avg_fields
  count(columns: [block_select_column!], distinct: Boolean): Int!
  max: block_max_fields
  min: block_min_fields
  stddev: block_stddev_fields
  stddev_pop: block_stddev_pop_fields
  stddev_samp: block_stddev_samp_fields
  sum: block_sum_fields
  var_pop: block_var_pop_fields
  var_samp: block_var_samp_fields
  variance: block_variance_fields
}

"""
order by aggregate values of table "block"
"""
input block_aggregate_order_by {
  avg: block_avg_order_by
  count: order_by
  max: block_max_order_by
  min: block_min_order_by
  stddev: block_stddev_order_by
  stddev_pop: block_stddev_pop_order_by
  stddev_samp: block_stddev_samp_order_by
  sum: block_sum_order_by
  var_pop: block_var_pop_order_by
  var_samp: block_var_samp_order_by
  variance: block_variance_order_by
}

"""
input type for inserting array relation for remote table "block"
"""
input block_arr_rel_insert_input {
  data: [block_insert_input!]!

  """on conflict condition"""
  on_conflict: block_on_conflict
}

"""aggregate avg on columns"""
type block_avg_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"""
order by avg() on columns of table "block"
"""
input block_avg_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"""
Boolean expression to filter rows from the table "block". All fields are combined with a logical 'AND'.
"""
input block_bool_exp {
  _and: [block_bool_exp!]
  _not: block_bool_exp
  _or: [block_bool_exp!]
  hash: String_comparison_exp
  height: bigint_comparison_exp
  num_txs: Int_comparison_exp
  pre_commits: pre_commit_bool_exp
  proposal_deposits: proposal_deposit_bool_exp
  proposal_votes: proposal_vote_bool_exp
  proposer_address: String_comparison_exp
  timestamp: timestamp_comparison_exp
  total_gas: bigint_comparison_exp
  transactions: transaction_bool_exp
  validator: validator_bool_exp
  validator_voting_powers: validator_voting_power_bool_exp
}

"""
unique or primary key constraints on table "block"
"""
enum block_constraint {
  """unique or primary key constraint"""
  block_hash_key

  """unique or primary key constraint"""
  block_pkey
}

"""
input type for incrementing numeric columns in table "block"
"""
input block_inc_input {
  height: bigint
  num_txs: Int
  total_gas: bigint
}

"""
input type for inserting data into table "block"
"""
input block_insert_input {
  hash: String
  height: bigint
  num_txs: Int
  pre_commits: pre_commit_arr_rel_insert_input
  proposal_deposits: proposal_deposit_arr_rel_insert_input
  proposal_votes: proposal_vote_arr_rel_insert_input
  proposer_address: String
  timestamp: timestamp
  total_gas: bigint
  transactions: transaction_arr_rel_insert_input
  validator: validator_obj_rel_insert_input
  validator_voting_powers: validator_voting_power_arr_rel_insert_input
}

"""aggregate max on columns"""
type block_max_fields {
  hash: String
  height: bigint
  num_txs: Int
  proposer_address: String
  timestamp: timestamp
  total_gas: bigint
}

"""
order by max() on columns of table "block"
"""
input block_max_order_by {
  hash: order_by
  height: order_by
  num_txs: order_by
  proposer_address: order_by
  timestamp: order_by
  total_gas: order_by
}

"""aggregate min on columns"""
type block_min_fields {
  hash: String
  height: bigint
  num_txs: Int
  proposer_address: String
  timestamp: timestamp
  total_gas: bigint
}

"""
order by min() on columns of table "block"
"""
input block_min_order_by {
  hash: order_by
  height: order_by
  num_txs: order_by
  proposer_address: order_by
  timestamp: order_by
  total_gas: order_by
}

"""
response of any mutation on the table "block"
"""
type block_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [block!]!
}

"""
input type for inserting object relation for remote table "block"
"""
input block_obj_rel_insert_input {
  data: block_insert_input!

  """on conflict condition"""
  on_conflict: block_on_conflict
}

"""
on conflict condition type for table "block"
"""
input block_on_conflict {
  constraint: block_constraint!
  update_columns: [block_update_column!]! = []
  where: block_bool_exp
}

"""Ordering options when selecting data from "block"."""
input block_order_by {
  hash: order_by
  height: order_by
  num_txs: order_by
  pre_commits_aggregate: pre_commit_aggregate_order_by
  proposal_deposits_aggregate: proposal_deposit_aggregate_order_by
  proposal_votes_aggregate: proposal_vote_aggregate_order_by
  proposer_address: order_by
  timestamp: order_by
  total_gas: order_by
  transactions_aggregate: transaction_aggregate_order_by
  validator: validator_order_by
  validator_voting_powers_aggregate: validator_voting_power_aggregate_order_by
}

"""primary key columns input for table: block"""
input block_pk_columns_input {
  height: bigint!
}

"""
select columns of table "block"
"""
enum block_select_column {
  """column name"""
  hash

  """column name"""
  height

  """column name"""
  num_txs

  """column name"""
  proposer_address

  """column name"""
  timestamp

  """column name"""
  total_gas
}

"""
input type for updating data in table "block"
"""
input block_set_input {
  hash: String
  height: bigint
  num_txs: Int
  proposer_address: String
  timestamp: timestamp
  total_gas: bigint
}

"""aggregate stddev on columns"""
type block_stddev_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"""
order by stddev() on columns of table "block"
"""
input block_stddev_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"""aggregate stddev_pop on columns"""
type block_stddev_pop_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"""
order by stddev_pop() on columns of table "block"
"""
input block_stddev_pop_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"""aggregate stddev_samp on columns"""
type block_stddev_samp_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"""
order by stddev_samp() on columns of table "block"
"""
input block_stddev_samp_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"""aggregate sum on columns"""
type block_sum_fields {
  height: bigint
  num_txs: Int
  total_gas: bigint
}

"""
order by sum() on columns of table "block"
"""
input block_sum_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"""
update columns of table "block"
"""
enum block_update_column {
  """column name"""
  hash

  """column name"""
  height

  """column name"""
  num_txs

  """column name"""
  proposer_address

  """column name"""
  timestamp

  """column name"""
  total_gas
}

"""aggregate var_pop on columns"""
type block_var_pop_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"""
order by var_pop() on columns of table "block"
"""
input block_var_pop_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"""aggregate var_samp on columns"""
type block_var_samp_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"""
order by var_samp() on columns of table "block"
"""
input block_var_samp_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"""aggregate variance on columns"""
type block_variance_fields {
  height: Float
  num_txs: Float
  total_gas: Float
}

"""
order by variance() on columns of table "block"
"""
input block_variance_order_by {
  height: order_by
  num_txs: order_by
  total_gas: order_by
}

"""
columns and relationships of "community_pool"
"""
type community_pool {
  coins: _dec_coin!
  height: bigint!
  one_row_id: Boolean!
}

"""
aggregated selection of "community_pool"
"""
type community_pool_aggregate {
  aggregate: community_pool_aggregate_fields
  nodes: [community_pool!]!
}

"""
aggregate fields of "community_pool"
"""
type community_pool_aggregate_fields {
  avg: community_pool_avg_fields
  count(columns: [community_pool_select_column!], distinct: Boolean): Int!
  max: community_pool_max_fields
  min: community_pool_min_fields
  stddev: community_pool_stddev_fields
  stddev_pop: community_pool_stddev_pop_fields
  stddev_samp: community_pool_stddev_samp_fields
  sum: community_pool_sum_fields
  var_pop: community_pool_var_pop_fields
  var_samp: community_pool_var_samp_fields
  variance: community_pool_variance_fields
}

"""aggregate avg on columns"""
type community_pool_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "community_pool". All fields are combined with a logical 'AND'.
"""
input community_pool_bool_exp {
  _and: [community_pool_bool_exp!]
  _not: community_pool_bool_exp
  _or: [community_pool_bool_exp!]
  coins: _dec_coin_comparison_exp
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "community_pool"
"""
enum community_pool_constraint {
  """unique or primary key constraint"""
  community_pool_pkey
}

"""
input type for incrementing numeric columns in table "community_pool"
"""
input community_pool_inc_input {
  height: bigint
}

"""
input type for inserting data into table "community_pool"
"""
input community_pool_insert_input {
  coins: _dec_coin
  height: bigint
  one_row_id: Boolean
}

"""aggregate max on columns"""
type community_pool_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type community_pool_min_fields {
  height: bigint
}

"""
response of any mutation on the table "community_pool"
"""
type community_pool_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [community_pool!]!
}

"""
on conflict condition type for table "community_pool"
"""
input community_pool_on_conflict {
  constraint: community_pool_constraint!
  update_columns: [community_pool_update_column!]! = []
  where: community_pool_bool_exp
}

"""Ordering options when selecting data from "community_pool"."""
input community_pool_order_by {
  coins: order_by
  height: order_by
  one_row_id: order_by
}

"""primary key columns input for table: community_pool"""
input community_pool_pk_columns_input {
  one_row_id: Boolean!
}

"""
select columns of table "community_pool"
"""
enum community_pool_select_column {
  """column name"""
  coins

  """column name"""
  height

  """column name"""
  one_row_id
}

"""
input type for updating data in table "community_pool"
"""
input community_pool_set_input {
  coins: _dec_coin
  height: bigint
  one_row_id: Boolean
}

"""aggregate stddev on columns"""
type community_pool_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type community_pool_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type community_pool_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type community_pool_sum_fields {
  height: bigint
}

"""
update columns of table "community_pool"
"""
enum community_pool_update_column {
  """column name"""
  coins

  """column name"""
  height

  """column name"""
  one_row_id
}

"""aggregate var_pop on columns"""
type community_pool_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type community_pool_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type community_pool_variance_fields {
  height: Float
}

"""
columns and relationships of "customparams_params"
"""
type customparams_params {
  height: bigint!
  one_row_id: Boolean!
  staking_params(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "customparams_params"
"""
type customparams_params_aggregate {
  aggregate: customparams_params_aggregate_fields
  nodes: [customparams_params!]!
}

"""
aggregate fields of "customparams_params"
"""
type customparams_params_aggregate_fields {
  avg: customparams_params_avg_fields
  count(columns: [customparams_params_select_column!], distinct: Boolean): Int!
  max: customparams_params_max_fields
  min: customparams_params_min_fields
  stddev: customparams_params_stddev_fields
  stddev_pop: customparams_params_stddev_pop_fields
  stddev_samp: customparams_params_stddev_samp_fields
  sum: customparams_params_sum_fields
  var_pop: customparams_params_var_pop_fields
  var_samp: customparams_params_var_samp_fields
  variance: customparams_params_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input customparams_params_append_input {
  staking_params: jsonb
}

"""aggregate avg on columns"""
type customparams_params_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "customparams_params". All fields are combined with a logical 'AND'.
"""
input customparams_params_bool_exp {
  _and: [customparams_params_bool_exp!]
  _not: customparams_params_bool_exp
  _or: [customparams_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  staking_params: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "customparams_params"
"""
enum customparams_params_constraint {
  """unique or primary key constraint"""
  customparams_params_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input customparams_params_delete_at_path_input {
  staking_params: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input customparams_params_delete_elem_input {
  staking_params: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input customparams_params_delete_key_input {
  staking_params: String
}

"""
input type for incrementing numeric columns in table "customparams_params"
"""
input customparams_params_inc_input {
  height: bigint
}

"""
input type for inserting data into table "customparams_params"
"""
input customparams_params_insert_input {
  height: bigint
  one_row_id: Boolean
  staking_params: jsonb
}

"""aggregate max on columns"""
type customparams_params_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type customparams_params_min_fields {
  height: bigint
}

"""
response of any mutation on the table "customparams_params"
"""
type customparams_params_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customparams_params!]!
}

"""
on conflict condition type for table "customparams_params"
"""
input customparams_params_on_conflict {
  constraint: customparams_params_constraint!
  update_columns: [customparams_params_update_column!]! = []
  where: customparams_params_bool_exp
}

"""Ordering options when selecting data from "customparams_params"."""
input customparams_params_order_by {
  height: order_by
  one_row_id: order_by
  staking_params: order_by
}

"""primary key columns input for table: customparams_params"""
input customparams_params_pk_columns_input {
  one_row_id: Boolean!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input customparams_params_prepend_input {
  staking_params: jsonb
}

"""
select columns of table "customparams_params"
"""
enum customparams_params_select_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  staking_params
}

"""
input type for updating data in table "customparams_params"
"""
input customparams_params_set_input {
  height: bigint
  one_row_id: Boolean
  staking_params: jsonb
}

"""aggregate stddev on columns"""
type customparams_params_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type customparams_params_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type customparams_params_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type customparams_params_sum_fields {
  height: bigint
}

"""
update columns of table "customparams_params"
"""
enum customparams_params_update_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  staking_params
}

"""aggregate var_pop on columns"""
type customparams_params_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type customparams_params_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type customparams_params_variance_fields {
  height: Float
}

"""
columns and relationships of "distribution_params"
"""
type distribution_params {
  height: bigint!
  one_row_id: Boolean!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "distribution_params"
"""
type distribution_params_aggregate {
  aggregate: distribution_params_aggregate_fields
  nodes: [distribution_params!]!
}

"""
aggregate fields of "distribution_params"
"""
type distribution_params_aggregate_fields {
  avg: distribution_params_avg_fields
  count(columns: [distribution_params_select_column!], distinct: Boolean): Int!
  max: distribution_params_max_fields
  min: distribution_params_min_fields
  stddev: distribution_params_stddev_fields
  stddev_pop: distribution_params_stddev_pop_fields
  stddev_samp: distribution_params_stddev_samp_fields
  sum: distribution_params_sum_fields
  var_pop: distribution_params_var_pop_fields
  var_samp: distribution_params_var_samp_fields
  variance: distribution_params_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input distribution_params_append_input {
  params: jsonb
}

"""aggregate avg on columns"""
type distribution_params_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "distribution_params". All fields are combined with a logical 'AND'.
"""
input distribution_params_bool_exp {
  _and: [distribution_params_bool_exp!]
  _not: distribution_params_bool_exp
  _or: [distribution_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "distribution_params"
"""
enum distribution_params_constraint {
  """unique or primary key constraint"""
  distribution_params_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input distribution_params_delete_at_path_input {
  params: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input distribution_params_delete_elem_input {
  params: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input distribution_params_delete_key_input {
  params: String
}

"""
input type for incrementing numeric columns in table "distribution_params"
"""
input distribution_params_inc_input {
  height: bigint
}

"""
input type for inserting data into table "distribution_params"
"""
input distribution_params_insert_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate max on columns"""
type distribution_params_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type distribution_params_min_fields {
  height: bigint
}

"""
response of any mutation on the table "distribution_params"
"""
type distribution_params_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [distribution_params!]!
}

"""
on conflict condition type for table "distribution_params"
"""
input distribution_params_on_conflict {
  constraint: distribution_params_constraint!
  update_columns: [distribution_params_update_column!]! = []
  where: distribution_params_bool_exp
}

"""Ordering options when selecting data from "distribution_params"."""
input distribution_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"""primary key columns input for table: distribution_params"""
input distribution_params_pk_columns_input {
  one_row_id: Boolean!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input distribution_params_prepend_input {
  params: jsonb
}

"""
select columns of table "distribution_params"
"""
enum distribution_params_select_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""
input type for updating data in table "distribution_params"
"""
input distribution_params_set_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate stddev on columns"""
type distribution_params_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type distribution_params_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type distribution_params_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type distribution_params_sum_fields {
  height: bigint
}

"""
update columns of table "distribution_params"
"""
enum distribution_params_update_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""aggregate var_pop on columns"""
type distribution_params_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type distribution_params_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type distribution_params_variance_fields {
  height: Float
}

"""
columns and relationships of "double_sign_evidence"
"""
type double_sign_evidence {
  """An object relationship"""
  doubleSignVoteByVoteAId: double_sign_vote!

  """An object relationship"""
  double_sign_vote: double_sign_vote!
  height: bigint!
  vote_a_id: bigint!
  vote_b_id: bigint!
}

"""
aggregated selection of "double_sign_evidence"
"""
type double_sign_evidence_aggregate {
  aggregate: double_sign_evidence_aggregate_fields
  nodes: [double_sign_evidence!]!
}

"""
aggregate fields of "double_sign_evidence"
"""
type double_sign_evidence_aggregate_fields {
  avg: double_sign_evidence_avg_fields
  count(columns: [double_sign_evidence_select_column!], distinct: Boolean): Int!
  max: double_sign_evidence_max_fields
  min: double_sign_evidence_min_fields
  stddev: double_sign_evidence_stddev_fields
  stddev_pop: double_sign_evidence_stddev_pop_fields
  stddev_samp: double_sign_evidence_stddev_samp_fields
  sum: double_sign_evidence_sum_fields
  var_pop: double_sign_evidence_var_pop_fields
  var_samp: double_sign_evidence_var_samp_fields
  variance: double_sign_evidence_variance_fields
}

"""
order by aggregate values of table "double_sign_evidence"
"""
input double_sign_evidence_aggregate_order_by {
  avg: double_sign_evidence_avg_order_by
  count: order_by
  max: double_sign_evidence_max_order_by
  min: double_sign_evidence_min_order_by
  stddev: double_sign_evidence_stddev_order_by
  stddev_pop: double_sign_evidence_stddev_pop_order_by
  stddev_samp: double_sign_evidence_stddev_samp_order_by
  sum: double_sign_evidence_sum_order_by
  var_pop: double_sign_evidence_var_pop_order_by
  var_samp: double_sign_evidence_var_samp_order_by
  variance: double_sign_evidence_variance_order_by
}

"""
input type for inserting array relation for remote table "double_sign_evidence"
"""
input double_sign_evidence_arr_rel_insert_input {
  data: [double_sign_evidence_insert_input!]!
}

"""aggregate avg on columns"""
type double_sign_evidence_avg_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"""
order by avg() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_avg_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""
Boolean expression to filter rows from the table "double_sign_evidence". All fields are combined with a logical 'AND'.
"""
input double_sign_evidence_bool_exp {
  _and: [double_sign_evidence_bool_exp!]
  _not: double_sign_evidence_bool_exp
  _or: [double_sign_evidence_bool_exp!]
  doubleSignVoteByVoteAId: double_sign_vote_bool_exp
  double_sign_vote: double_sign_vote_bool_exp
  height: bigint_comparison_exp
  vote_a_id: bigint_comparison_exp
  vote_b_id: bigint_comparison_exp
}

"""
input type for incrementing numeric columns in table "double_sign_evidence"
"""
input double_sign_evidence_inc_input {
  height: bigint
  vote_a_id: bigint
  vote_b_id: bigint
}

"""
input type for inserting data into table "double_sign_evidence"
"""
input double_sign_evidence_insert_input {
  doubleSignVoteByVoteAId: double_sign_vote_obj_rel_insert_input
  double_sign_vote: double_sign_vote_obj_rel_insert_input
  height: bigint
  vote_a_id: bigint
  vote_b_id: bigint
}

"""aggregate max on columns"""
type double_sign_evidence_max_fields {
  height: bigint
  vote_a_id: bigint
  vote_b_id: bigint
}

"""
order by max() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_max_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""aggregate min on columns"""
type double_sign_evidence_min_fields {
  height: bigint
  vote_a_id: bigint
  vote_b_id: bigint
}

"""
order by min() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_min_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""
response of any mutation on the table "double_sign_evidence"
"""
type double_sign_evidence_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [double_sign_evidence!]!
}

"""Ordering options when selecting data from "double_sign_evidence"."""
input double_sign_evidence_order_by {
  doubleSignVoteByVoteAId: double_sign_vote_order_by
  double_sign_vote: double_sign_vote_order_by
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""
select columns of table "double_sign_evidence"
"""
enum double_sign_evidence_select_column {
  """column name"""
  height

  """column name"""
  vote_a_id

  """column name"""
  vote_b_id
}

"""
input type for updating data in table "double_sign_evidence"
"""
input double_sign_evidence_set_input {
  height: bigint
  vote_a_id: bigint
  vote_b_id: bigint
}

"""aggregate stddev on columns"""
type double_sign_evidence_stddev_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"""
order by stddev() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_stddev_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""aggregate stddev_pop on columns"""
type double_sign_evidence_stddev_pop_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"""
order by stddev_pop() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_stddev_pop_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""aggregate stddev_samp on columns"""
type double_sign_evidence_stddev_samp_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"""
order by stddev_samp() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_stddev_samp_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""aggregate sum on columns"""
type double_sign_evidence_sum_fields {
  height: bigint
  vote_a_id: bigint
  vote_b_id: bigint
}

"""
order by sum() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_sum_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""aggregate var_pop on columns"""
type double_sign_evidence_var_pop_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"""
order by var_pop() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_var_pop_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""aggregate var_samp on columns"""
type double_sign_evidence_var_samp_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"""
order by var_samp() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_var_samp_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""aggregate variance on columns"""
type double_sign_evidence_variance_fields {
  height: Float
  vote_a_id: Float
  vote_b_id: Float
}

"""
order by variance() on columns of table "double_sign_evidence"
"""
input double_sign_evidence_variance_order_by {
  height: order_by
  vote_a_id: order_by
  vote_b_id: order_by
}

"""
columns and relationships of "double_sign_vote"
"""
type double_sign_vote {
  block_id: String!

  """An array relationship"""
  doubleSignEvidencesByVoteBId(
    """distinct select on columns"""
    distinct_on: [double_sign_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_evidence_order_by!]

    """filter the rows returned"""
    where: double_sign_evidence_bool_exp
  ): [double_sign_evidence!]!

  """An aggregate relationship"""
  doubleSignEvidencesByVoteBId_aggregate(
    """distinct select on columns"""
    distinct_on: [double_sign_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_evidence_order_by!]

    """filter the rows returned"""
    where: double_sign_evidence_bool_exp
  ): double_sign_evidence_aggregate!

  """An array relationship"""
  double_sign_evidences(
    """distinct select on columns"""
    distinct_on: [double_sign_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_evidence_order_by!]

    """filter the rows returned"""
    where: double_sign_evidence_bool_exp
  ): [double_sign_evidence!]!

  """An aggregate relationship"""
  double_sign_evidences_aggregate(
    """distinct select on columns"""
    distinct_on: [double_sign_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_evidence_order_by!]

    """filter the rows returned"""
    where: double_sign_evidence_bool_exp
  ): double_sign_evidence_aggregate!
  height: bigint!
  id: Int!
  round: Int!
  signature: String!
  type: smallint!

  """An object relationship"""
  validator: validator!
  validator_address: String!
  validator_index: Int!
}

"""
aggregated selection of "double_sign_vote"
"""
type double_sign_vote_aggregate {
  aggregate: double_sign_vote_aggregate_fields
  nodes: [double_sign_vote!]!
}

"""
aggregate fields of "double_sign_vote"
"""
type double_sign_vote_aggregate_fields {
  avg: double_sign_vote_avg_fields
  count(columns: [double_sign_vote_select_column!], distinct: Boolean): Int!
  max: double_sign_vote_max_fields
  min: double_sign_vote_min_fields
  stddev: double_sign_vote_stddev_fields
  stddev_pop: double_sign_vote_stddev_pop_fields
  stddev_samp: double_sign_vote_stddev_samp_fields
  sum: double_sign_vote_sum_fields
  var_pop: double_sign_vote_var_pop_fields
  var_samp: double_sign_vote_var_samp_fields
  variance: double_sign_vote_variance_fields
}

"""
order by aggregate values of table "double_sign_vote"
"""
input double_sign_vote_aggregate_order_by {
  avg: double_sign_vote_avg_order_by
  count: order_by
  max: double_sign_vote_max_order_by
  min: double_sign_vote_min_order_by
  stddev: double_sign_vote_stddev_order_by
  stddev_pop: double_sign_vote_stddev_pop_order_by
  stddev_samp: double_sign_vote_stddev_samp_order_by
  sum: double_sign_vote_sum_order_by
  var_pop: double_sign_vote_var_pop_order_by
  var_samp: double_sign_vote_var_samp_order_by
  variance: double_sign_vote_variance_order_by
}

"""
input type for inserting array relation for remote table "double_sign_vote"
"""
input double_sign_vote_arr_rel_insert_input {
  data: [double_sign_vote_insert_input!]!

  """on conflict condition"""
  on_conflict: double_sign_vote_on_conflict
}

"""aggregate avg on columns"""
type double_sign_vote_avg_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"""
order by avg() on columns of table "double_sign_vote"
"""
input double_sign_vote_avg_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"""
Boolean expression to filter rows from the table "double_sign_vote". All fields are combined with a logical 'AND'.
"""
input double_sign_vote_bool_exp {
  _and: [double_sign_vote_bool_exp!]
  _not: double_sign_vote_bool_exp
  _or: [double_sign_vote_bool_exp!]
  block_id: String_comparison_exp
  doubleSignEvidencesByVoteBId: double_sign_evidence_bool_exp
  double_sign_evidences: double_sign_evidence_bool_exp
  height: bigint_comparison_exp
  id: Int_comparison_exp
  round: Int_comparison_exp
  signature: String_comparison_exp
  type: smallint_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  validator_index: Int_comparison_exp
}

"""
unique or primary key constraints on table "double_sign_vote"
"""
enum double_sign_vote_constraint {
  """unique or primary key constraint"""
  double_sign_vote_block_id_validator_address_key

  """unique or primary key constraint"""
  double_sign_vote_pkey
}

"""
input type for incrementing numeric columns in table "double_sign_vote"
"""
input double_sign_vote_inc_input {
  height: bigint
  id: Int
  round: Int
  type: smallint
  validator_index: Int
}

"""
input type for inserting data into table "double_sign_vote"
"""
input double_sign_vote_insert_input {
  block_id: String
  doubleSignEvidencesByVoteBId: double_sign_evidence_arr_rel_insert_input
  double_sign_evidences: double_sign_evidence_arr_rel_insert_input
  height: bigint
  id: Int
  round: Int
  signature: String
  type: smallint
  validator: validator_obj_rel_insert_input
  validator_address: String
  validator_index: Int
}

"""aggregate max on columns"""
type double_sign_vote_max_fields {
  block_id: String
  height: bigint
  id: Int
  round: Int
  signature: String
  type: smallint
  validator_address: String
  validator_index: Int
}

"""
order by max() on columns of table "double_sign_vote"
"""
input double_sign_vote_max_order_by {
  block_id: order_by
  height: order_by
  id: order_by
  round: order_by
  signature: order_by
  type: order_by
  validator_address: order_by
  validator_index: order_by
}

"""aggregate min on columns"""
type double_sign_vote_min_fields {
  block_id: String
  height: bigint
  id: Int
  round: Int
  signature: String
  type: smallint
  validator_address: String
  validator_index: Int
}

"""
order by min() on columns of table "double_sign_vote"
"""
input double_sign_vote_min_order_by {
  block_id: order_by
  height: order_by
  id: order_by
  round: order_by
  signature: order_by
  type: order_by
  validator_address: order_by
  validator_index: order_by
}

"""
response of any mutation on the table "double_sign_vote"
"""
type double_sign_vote_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [double_sign_vote!]!
}

"""
input type for inserting object relation for remote table "double_sign_vote"
"""
input double_sign_vote_obj_rel_insert_input {
  data: double_sign_vote_insert_input!

  """on conflict condition"""
  on_conflict: double_sign_vote_on_conflict
}

"""
on conflict condition type for table "double_sign_vote"
"""
input double_sign_vote_on_conflict {
  constraint: double_sign_vote_constraint!
  update_columns: [double_sign_vote_update_column!]! = []
  where: double_sign_vote_bool_exp
}

"""Ordering options when selecting data from "double_sign_vote"."""
input double_sign_vote_order_by {
  block_id: order_by
  doubleSignEvidencesByVoteBId_aggregate: double_sign_evidence_aggregate_order_by
  double_sign_evidences_aggregate: double_sign_evidence_aggregate_order_by
  height: order_by
  id: order_by
  round: order_by
  signature: order_by
  type: order_by
  validator: validator_order_by
  validator_address: order_by
  validator_index: order_by
}

"""primary key columns input for table: double_sign_vote"""
input double_sign_vote_pk_columns_input {
  id: Int!
}

"""
select columns of table "double_sign_vote"
"""
enum double_sign_vote_select_column {
  """column name"""
  block_id

  """column name"""
  height

  """column name"""
  id

  """column name"""
  round

  """column name"""
  signature

  """column name"""
  type

  """column name"""
  validator_address

  """column name"""
  validator_index
}

"""
input type for updating data in table "double_sign_vote"
"""
input double_sign_vote_set_input {
  block_id: String
  height: bigint
  id: Int
  round: Int
  signature: String
  type: smallint
  validator_address: String
  validator_index: Int
}

"""aggregate stddev on columns"""
type double_sign_vote_stddev_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"""
order by stddev() on columns of table "double_sign_vote"
"""
input double_sign_vote_stddev_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"""aggregate stddev_pop on columns"""
type double_sign_vote_stddev_pop_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"""
order by stddev_pop() on columns of table "double_sign_vote"
"""
input double_sign_vote_stddev_pop_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"""aggregate stddev_samp on columns"""
type double_sign_vote_stddev_samp_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"""
order by stddev_samp() on columns of table "double_sign_vote"
"""
input double_sign_vote_stddev_samp_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"""aggregate sum on columns"""
type double_sign_vote_sum_fields {
  height: bigint
  id: Int
  round: Int
  type: smallint
  validator_index: Int
}

"""
order by sum() on columns of table "double_sign_vote"
"""
input double_sign_vote_sum_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"""
update columns of table "double_sign_vote"
"""
enum double_sign_vote_update_column {
  """column name"""
  block_id

  """column name"""
  height

  """column name"""
  id

  """column name"""
  round

  """column name"""
  signature

  """column name"""
  type

  """column name"""
  validator_address

  """column name"""
  validator_index
}

"""aggregate var_pop on columns"""
type double_sign_vote_var_pop_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"""
order by var_pop() on columns of table "double_sign_vote"
"""
input double_sign_vote_var_pop_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"""aggregate var_samp on columns"""
type double_sign_vote_var_samp_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"""
order by var_samp() on columns of table "double_sign_vote"
"""
input double_sign_vote_var_samp_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"""aggregate variance on columns"""
type double_sign_vote_variance_fields {
  height: Float
  id: Float
  round: Float
  type: Float
  validator_index: Float
}

"""
order by variance() on columns of table "double_sign_vote"
"""
input double_sign_vote_variance_order_by {
  height: order_by
  id: order_by
  round: order_by
  type: order_by
  validator_index: order_by
}

"""
columns and relationships of "fee_grant_allowance"
"""
type fee_grant_allowance {
  allowance(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  grantee: account!
  grantee_address: String!

  """An object relationship"""
  granter: account!
  granter_address: String!
  height: bigint!
  id: Int!
}

"""
aggregated selection of "fee_grant_allowance"
"""
type fee_grant_allowance_aggregate {
  aggregate: fee_grant_allowance_aggregate_fields
  nodes: [fee_grant_allowance!]!
}

"""
aggregate fields of "fee_grant_allowance"
"""
type fee_grant_allowance_aggregate_fields {
  avg: fee_grant_allowance_avg_fields
  count(columns: [fee_grant_allowance_select_column!], distinct: Boolean): Int!
  max: fee_grant_allowance_max_fields
  min: fee_grant_allowance_min_fields
  stddev: fee_grant_allowance_stddev_fields
  stddev_pop: fee_grant_allowance_stddev_pop_fields
  stddev_samp: fee_grant_allowance_stddev_samp_fields
  sum: fee_grant_allowance_sum_fields
  var_pop: fee_grant_allowance_var_pop_fields
  var_samp: fee_grant_allowance_var_samp_fields
  variance: fee_grant_allowance_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input fee_grant_allowance_append_input {
  allowance: jsonb
}

"""aggregate avg on columns"""
type fee_grant_allowance_avg_fields {
  height: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "fee_grant_allowance". All fields are combined with a logical 'AND'.
"""
input fee_grant_allowance_bool_exp {
  _and: [fee_grant_allowance_bool_exp!]
  _not: fee_grant_allowance_bool_exp
  _or: [fee_grant_allowance_bool_exp!]
  allowance: jsonb_comparison_exp
  grantee: account_bool_exp
  grantee_address: String_comparison_exp
  granter: account_bool_exp
  granter_address: String_comparison_exp
  height: bigint_comparison_exp
  id: Int_comparison_exp
}

"""
unique or primary key constraints on table "fee_grant_allowance"
"""
enum fee_grant_allowance_constraint {
  """unique or primary key constraint"""
  fee_grant_allowance_pkey

  """unique or primary key constraint"""
  unique_fee_grant_allowance
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input fee_grant_allowance_delete_at_path_input {
  allowance: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input fee_grant_allowance_delete_elem_input {
  allowance: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input fee_grant_allowance_delete_key_input {
  allowance: String
}

"""
input type for incrementing numeric columns in table "fee_grant_allowance"
"""
input fee_grant_allowance_inc_input {
  height: bigint
  id: Int
}

"""
input type for inserting data into table "fee_grant_allowance"
"""
input fee_grant_allowance_insert_input {
  allowance: jsonb
  grantee: account_obj_rel_insert_input
  grantee_address: String
  granter: account_obj_rel_insert_input
  granter_address: String
  height: bigint
  id: Int
}

"""aggregate max on columns"""
type fee_grant_allowance_max_fields {
  grantee_address: String
  granter_address: String
  height: bigint
  id: Int
}

"""aggregate min on columns"""
type fee_grant_allowance_min_fields {
  grantee_address: String
  granter_address: String
  height: bigint
  id: Int
}

"""
response of any mutation on the table "fee_grant_allowance"
"""
type fee_grant_allowance_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [fee_grant_allowance!]!
}

"""
on conflict condition type for table "fee_grant_allowance"
"""
input fee_grant_allowance_on_conflict {
  constraint: fee_grant_allowance_constraint!
  update_columns: [fee_grant_allowance_update_column!]! = []
  where: fee_grant_allowance_bool_exp
}

"""Ordering options when selecting data from "fee_grant_allowance"."""
input fee_grant_allowance_order_by {
  allowance: order_by
  grantee: account_order_by
  grantee_address: order_by
  granter: account_order_by
  granter_address: order_by
  height: order_by
  id: order_by
}

"""primary key columns input for table: fee_grant_allowance"""
input fee_grant_allowance_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input fee_grant_allowance_prepend_input {
  allowance: jsonb
}

"""
select columns of table "fee_grant_allowance"
"""
enum fee_grant_allowance_select_column {
  """column name"""
  allowance

  """column name"""
  grantee_address

  """column name"""
  granter_address

  """column name"""
  height

  """column name"""
  id
}

"""
input type for updating data in table "fee_grant_allowance"
"""
input fee_grant_allowance_set_input {
  allowance: jsonb
  grantee_address: String
  granter_address: String
  height: bigint
  id: Int
}

"""aggregate stddev on columns"""
type fee_grant_allowance_stddev_fields {
  height: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type fee_grant_allowance_stddev_pop_fields {
  height: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type fee_grant_allowance_stddev_samp_fields {
  height: Float
  id: Float
}

"""aggregate sum on columns"""
type fee_grant_allowance_sum_fields {
  height: bigint
  id: Int
}

"""
update columns of table "fee_grant_allowance"
"""
enum fee_grant_allowance_update_column {
  """column name"""
  allowance

  """column name"""
  grantee_address

  """column name"""
  granter_address

  """column name"""
  height

  """column name"""
  id
}

"""aggregate var_pop on columns"""
type fee_grant_allowance_var_pop_fields {
  height: Float
  id: Float
}

"""aggregate var_samp on columns"""
type fee_grant_allowance_var_samp_fields {
  height: Float
  id: Float
}

"""aggregate variance on columns"""
type fee_grant_allowance_variance_fields {
  height: Float
  id: Float
}

"""
columns and relationships of "feemodel_params"
"""
type feemodel_params {
  height: bigint!
  one_row_id: Boolean!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "feemodel_params"
"""
type feemodel_params_aggregate {
  aggregate: feemodel_params_aggregate_fields
  nodes: [feemodel_params!]!
}

"""
aggregate fields of "feemodel_params"
"""
type feemodel_params_aggregate_fields {
  avg: feemodel_params_avg_fields
  count(columns: [feemodel_params_select_column!], distinct: Boolean): Int!
  max: feemodel_params_max_fields
  min: feemodel_params_min_fields
  stddev: feemodel_params_stddev_fields
  stddev_pop: feemodel_params_stddev_pop_fields
  stddev_samp: feemodel_params_stddev_samp_fields
  sum: feemodel_params_sum_fields
  var_pop: feemodel_params_var_pop_fields
  var_samp: feemodel_params_var_samp_fields
  variance: feemodel_params_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input feemodel_params_append_input {
  params: jsonb
}

"""aggregate avg on columns"""
type feemodel_params_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "feemodel_params". All fields are combined with a logical 'AND'.
"""
input feemodel_params_bool_exp {
  _and: [feemodel_params_bool_exp!]
  _not: feemodel_params_bool_exp
  _or: [feemodel_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "feemodel_params"
"""
enum feemodel_params_constraint {
  """unique or primary key constraint"""
  feemodel_params_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input feemodel_params_delete_at_path_input {
  params: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input feemodel_params_delete_elem_input {
  params: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input feemodel_params_delete_key_input {
  params: String
}

"""
input type for incrementing numeric columns in table "feemodel_params"
"""
input feemodel_params_inc_input {
  height: bigint
}

"""
input type for inserting data into table "feemodel_params"
"""
input feemodel_params_insert_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate max on columns"""
type feemodel_params_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type feemodel_params_min_fields {
  height: bigint
}

"""
response of any mutation on the table "feemodel_params"
"""
type feemodel_params_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [feemodel_params!]!
}

"""
on conflict condition type for table "feemodel_params"
"""
input feemodel_params_on_conflict {
  constraint: feemodel_params_constraint!
  update_columns: [feemodel_params_update_column!]! = []
  where: feemodel_params_bool_exp
}

"""Ordering options when selecting data from "feemodel_params"."""
input feemodel_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"""primary key columns input for table: feemodel_params"""
input feemodel_params_pk_columns_input {
  one_row_id: Boolean!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input feemodel_params_prepend_input {
  params: jsonb
}

"""
select columns of table "feemodel_params"
"""
enum feemodel_params_select_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""
input type for updating data in table "feemodel_params"
"""
input feemodel_params_set_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate stddev on columns"""
type feemodel_params_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type feemodel_params_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type feemodel_params_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type feemodel_params_sum_fields {
  height: bigint
}

"""
update columns of table "feemodel_params"
"""
enum feemodel_params_update_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""aggregate var_pop on columns"""
type feemodel_params_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type feemodel_params_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type feemodel_params_variance_fields {
  height: Float
}

"""
columns and relationships of "genesis"
"""
type genesis {
  chain_id: String!
  initial_height: bigint!
  one_row_id: Boolean!
  time: timestamp!
}

"""
aggregated selection of "genesis"
"""
type genesis_aggregate {
  aggregate: genesis_aggregate_fields
  nodes: [genesis!]!
}

"""
aggregate fields of "genesis"
"""
type genesis_aggregate_fields {
  avg: genesis_avg_fields
  count(columns: [genesis_select_column!], distinct: Boolean): Int!
  max: genesis_max_fields
  min: genesis_min_fields
  stddev: genesis_stddev_fields
  stddev_pop: genesis_stddev_pop_fields
  stddev_samp: genesis_stddev_samp_fields
  sum: genesis_sum_fields
  var_pop: genesis_var_pop_fields
  var_samp: genesis_var_samp_fields
  variance: genesis_variance_fields
}

"""aggregate avg on columns"""
type genesis_avg_fields {
  initial_height: Float
}

"""
Boolean expression to filter rows from the table "genesis". All fields are combined with a logical 'AND'.
"""
input genesis_bool_exp {
  _and: [genesis_bool_exp!]
  _not: genesis_bool_exp
  _or: [genesis_bool_exp!]
  chain_id: String_comparison_exp
  initial_height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  time: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "genesis"
"""
enum genesis_constraint {
  """unique or primary key constraint"""
  genesis_pkey
}

"""
input type for incrementing numeric columns in table "genesis"
"""
input genesis_inc_input {
  initial_height: bigint
}

"""
input type for inserting data into table "genesis"
"""
input genesis_insert_input {
  chain_id: String
  initial_height: bigint
  one_row_id: Boolean
  time: timestamp
}

"""aggregate max on columns"""
type genesis_max_fields {
  chain_id: String
  initial_height: bigint
  time: timestamp
}

"""aggregate min on columns"""
type genesis_min_fields {
  chain_id: String
  initial_height: bigint
  time: timestamp
}

"""
response of any mutation on the table "genesis"
"""
type genesis_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [genesis!]!
}

"""
on conflict condition type for table "genesis"
"""
input genesis_on_conflict {
  constraint: genesis_constraint!
  update_columns: [genesis_update_column!]! = []
  where: genesis_bool_exp
}

"""Ordering options when selecting data from "genesis"."""
input genesis_order_by {
  chain_id: order_by
  initial_height: order_by
  one_row_id: order_by
  time: order_by
}

"""primary key columns input for table: genesis"""
input genesis_pk_columns_input {
  one_row_id: Boolean!
}

"""
select columns of table "genesis"
"""
enum genesis_select_column {
  """column name"""
  chain_id

  """column name"""
  initial_height

  """column name"""
  one_row_id

  """column name"""
  time
}

"""
input type for updating data in table "genesis"
"""
input genesis_set_input {
  chain_id: String
  initial_height: bigint
  one_row_id: Boolean
  time: timestamp
}

"""aggregate stddev on columns"""
type genesis_stddev_fields {
  initial_height: Float
}

"""aggregate stddev_pop on columns"""
type genesis_stddev_pop_fields {
  initial_height: Float
}

"""aggregate stddev_samp on columns"""
type genesis_stddev_samp_fields {
  initial_height: Float
}

"""aggregate sum on columns"""
type genesis_sum_fields {
  initial_height: bigint
}

"""
update columns of table "genesis"
"""
enum genesis_update_column {
  """column name"""
  chain_id

  """column name"""
  initial_height

  """column name"""
  one_row_id

  """column name"""
  time
}

"""aggregate var_pop on columns"""
type genesis_var_pop_fields {
  initial_height: Float
}

"""aggregate var_samp on columns"""
type genesis_var_samp_fields {
  initial_height: Float
}

"""aggregate variance on columns"""
type genesis_variance_fields {
  initial_height: Float
}

"""
columns and relationships of "gov_params"
"""
type gov_params {
  deposit_params(
    """JSON select path"""
    path: String
  ): jsonb!
  height: bigint!
  one_row_id: Boolean!
  tally_params(
    """JSON select path"""
    path: String
  ): jsonb!
  voting_params(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "gov_params"
"""
type gov_params_aggregate {
  aggregate: gov_params_aggregate_fields
  nodes: [gov_params!]!
}

"""
aggregate fields of "gov_params"
"""
type gov_params_aggregate_fields {
  avg: gov_params_avg_fields
  count(columns: [gov_params_select_column!], distinct: Boolean): Int!
  max: gov_params_max_fields
  min: gov_params_min_fields
  stddev: gov_params_stddev_fields
  stddev_pop: gov_params_stddev_pop_fields
  stddev_samp: gov_params_stddev_samp_fields
  sum: gov_params_sum_fields
  var_pop: gov_params_var_pop_fields
  var_samp: gov_params_var_samp_fields
  variance: gov_params_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input gov_params_append_input {
  deposit_params: jsonb
  tally_params: jsonb
  voting_params: jsonb
}

"""aggregate avg on columns"""
type gov_params_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "gov_params". All fields are combined with a logical 'AND'.
"""
input gov_params_bool_exp {
  _and: [gov_params_bool_exp!]
  _not: gov_params_bool_exp
  _or: [gov_params_bool_exp!]
  deposit_params: jsonb_comparison_exp
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  tally_params: jsonb_comparison_exp
  voting_params: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "gov_params"
"""
enum gov_params_constraint {
  """unique or primary key constraint"""
  gov_params_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input gov_params_delete_at_path_input {
  deposit_params: [String!]
  tally_params: [String!]
  voting_params: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input gov_params_delete_elem_input {
  deposit_params: Int
  tally_params: Int
  voting_params: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input gov_params_delete_key_input {
  deposit_params: String
  tally_params: String
  voting_params: String
}

"""
input type for incrementing numeric columns in table "gov_params"
"""
input gov_params_inc_input {
  height: bigint
}

"""
input type for inserting data into table "gov_params"
"""
input gov_params_insert_input {
  deposit_params: jsonb
  height: bigint
  one_row_id: Boolean
  tally_params: jsonb
  voting_params: jsonb
}

"""aggregate max on columns"""
type gov_params_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type gov_params_min_fields {
  height: bigint
}

"""
response of any mutation on the table "gov_params"
"""
type gov_params_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [gov_params!]!
}

"""
on conflict condition type for table "gov_params"
"""
input gov_params_on_conflict {
  constraint: gov_params_constraint!
  update_columns: [gov_params_update_column!]! = []
  where: gov_params_bool_exp
}

"""Ordering options when selecting data from "gov_params"."""
input gov_params_order_by {
  deposit_params: order_by
  height: order_by
  one_row_id: order_by
  tally_params: order_by
  voting_params: order_by
}

"""primary key columns input for table: gov_params"""
input gov_params_pk_columns_input {
  one_row_id: Boolean!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input gov_params_prepend_input {
  deposit_params: jsonb
  tally_params: jsonb
  voting_params: jsonb
}

"""
select columns of table "gov_params"
"""
enum gov_params_select_column {
  """column name"""
  deposit_params

  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  tally_params

  """column name"""
  voting_params
}

"""
input type for updating data in table "gov_params"
"""
input gov_params_set_input {
  deposit_params: jsonb
  height: bigint
  one_row_id: Boolean
  tally_params: jsonb
  voting_params: jsonb
}

"""aggregate stddev on columns"""
type gov_params_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type gov_params_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type gov_params_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type gov_params_sum_fields {
  height: bigint
}

"""
update columns of table "gov_params"
"""
enum gov_params_update_column {
  """column name"""
  deposit_params

  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  tally_params

  """column name"""
  voting_params
}

"""aggregate var_pop on columns"""
type gov_params_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type gov_params_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type gov_params_variance_fields {
  height: Float
}

"""
columns and relationships of "inflation"
"""
type inflation {
  height: bigint!
  one_row_id: Boolean!
  value: numeric!
}

"""
aggregated selection of "inflation"
"""
type inflation_aggregate {
  aggregate: inflation_aggregate_fields
  nodes: [inflation!]!
}

"""
aggregate fields of "inflation"
"""
type inflation_aggregate_fields {
  avg: inflation_avg_fields
  count(columns: [inflation_select_column!], distinct: Boolean): Int!
  max: inflation_max_fields
  min: inflation_min_fields
  stddev: inflation_stddev_fields
  stddev_pop: inflation_stddev_pop_fields
  stddev_samp: inflation_stddev_samp_fields
  sum: inflation_sum_fields
  var_pop: inflation_var_pop_fields
  var_samp: inflation_var_samp_fields
  variance: inflation_variance_fields
}

"""aggregate avg on columns"""
type inflation_avg_fields {
  height: Float
  value: Float
}

"""
Boolean expression to filter rows from the table "inflation". All fields are combined with a logical 'AND'.
"""
input inflation_bool_exp {
  _and: [inflation_bool_exp!]
  _not: inflation_bool_exp
  _or: [inflation_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  value: numeric_comparison_exp
}

"""
unique or primary key constraints on table "inflation"
"""
enum inflation_constraint {
  """unique or primary key constraint"""
  inflation_pkey
}

"""
input type for incrementing numeric columns in table "inflation"
"""
input inflation_inc_input {
  height: bigint
  value: numeric
}

"""
input type for inserting data into table "inflation"
"""
input inflation_insert_input {
  height: bigint
  one_row_id: Boolean
  value: numeric
}

"""aggregate max on columns"""
type inflation_max_fields {
  height: bigint
  value: numeric
}

"""aggregate min on columns"""
type inflation_min_fields {
  height: bigint
  value: numeric
}

"""
response of any mutation on the table "inflation"
"""
type inflation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [inflation!]!
}

"""
on conflict condition type for table "inflation"
"""
input inflation_on_conflict {
  constraint: inflation_constraint!
  update_columns: [inflation_update_column!]! = []
  where: inflation_bool_exp
}

"""Ordering options when selecting data from "inflation"."""
input inflation_order_by {
  height: order_by
  one_row_id: order_by
  value: order_by
}

"""primary key columns input for table: inflation"""
input inflation_pk_columns_input {
  one_row_id: Boolean!
}

"""
select columns of table "inflation"
"""
enum inflation_select_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  value
}

"""
input type for updating data in table "inflation"
"""
input inflation_set_input {
  height: bigint
  one_row_id: Boolean
  value: numeric
}

"""aggregate stddev on columns"""
type inflation_stddev_fields {
  height: Float
  value: Float
}

"""aggregate stddev_pop on columns"""
type inflation_stddev_pop_fields {
  height: Float
  value: Float
}

"""aggregate stddev_samp on columns"""
type inflation_stddev_samp_fields {
  height: Float
  value: Float
}

"""aggregate sum on columns"""
type inflation_sum_fields {
  height: bigint
  value: numeric
}

"""
update columns of table "inflation"
"""
enum inflation_update_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type inflation_var_pop_fields {
  height: Float
  value: Float
}

"""aggregate var_samp on columns"""
type inflation_var_samp_fields {
  height: Float
  value: Float
}

"""aggregate variance on columns"""
type inflation_variance_fields {
  height: Float
  value: Float
}

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "message"
"""
type message {
  height: bigint!
  index: bigint!
  involved_accounts_addresses: _text!
  partition_id: bigint!

  """An object relationship"""
  transaction: transaction
  transaction_hash: String!
  type: String!
  value(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "message"
"""
type message_aggregate {
  aggregate: message_aggregate_fields
  nodes: [message!]!
}

"""
aggregate fields of "message"
"""
type message_aggregate_fields {
  avg: message_avg_fields
  count(columns: [message_select_column!], distinct: Boolean): Int!
  max: message_max_fields
  min: message_min_fields
  stddev: message_stddev_fields
  stddev_pop: message_stddev_pop_fields
  stddev_samp: message_stddev_samp_fields
  sum: message_sum_fields
  var_pop: message_var_pop_fields
  var_samp: message_var_samp_fields
  variance: message_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input message_append_input {
  value: jsonb
}

"""aggregate avg on columns"""
type message_avg_fields {
  height: Float
  index: Float
  partition_id: Float
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input message_bool_exp {
  _and: [message_bool_exp!]
  _not: message_bool_exp
  _or: [message_bool_exp!]
  height: bigint_comparison_exp
  index: bigint_comparison_exp
  involved_accounts_addresses: _text_comparison_exp
  partition_id: bigint_comparison_exp
  transaction: transaction_bool_exp
  transaction_hash: String_comparison_exp
  type: String_comparison_exp
  value: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "message"
"""
enum message_constraint {
  """unique or primary key constraint"""
  unique_message_per_tx
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input message_delete_at_path_input {
  value: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input message_delete_elem_input {
  value: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input message_delete_key_input {
  value: String
}

"""
input type for incrementing numeric columns in table "message"
"""
input message_inc_input {
  height: bigint
  index: bigint
  partition_id: bigint
}

"""
input type for inserting data into table "message"
"""
input message_insert_input {
  height: bigint
  index: bigint
  involved_accounts_addresses: _text
  partition_id: bigint
  transaction: transaction_obj_rel_insert_input
  transaction_hash: String
  type: String
  value: jsonb
}

"""aggregate max on columns"""
type message_max_fields {
  height: bigint
  index: bigint
  partition_id: bigint
  transaction_hash: String
  type: String
}

"""aggregate min on columns"""
type message_min_fields {
  height: bigint
  index: bigint
  partition_id: bigint
  transaction_hash: String
  type: String
}

"""
response of any mutation on the table "message"
"""
type message_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [message!]!
}

"""
on conflict condition type for table "message"
"""
input message_on_conflict {
  constraint: message_constraint!
  update_columns: [message_update_column!]! = []
  where: message_bool_exp
}

"""Ordering options when selecting data from "message"."""
input message_order_by {
  height: order_by
  index: order_by
  involved_accounts_addresses: order_by
  partition_id: order_by
  transaction: transaction_order_by
  transaction_hash: order_by
  type: order_by
  value: order_by
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input message_prepend_input {
  value: jsonb
}

"""
select columns of table "message"
"""
enum message_select_column {
  """column name"""
  height

  """column name"""
  index

  """column name"""
  involved_accounts_addresses

  """column name"""
  partition_id

  """column name"""
  transaction_hash

  """column name"""
  type

  """column name"""
  value
}

"""
input type for updating data in table "message"
"""
input message_set_input {
  height: bigint
  index: bigint
  involved_accounts_addresses: _text
  partition_id: bigint
  transaction_hash: String
  type: String
  value: jsonb
}

"""aggregate stddev on columns"""
type message_stddev_fields {
  height: Float
  index: Float
  partition_id: Float
}

"""aggregate stddev_pop on columns"""
type message_stddev_pop_fields {
  height: Float
  index: Float
  partition_id: Float
}

"""aggregate stddev_samp on columns"""
type message_stddev_samp_fields {
  height: Float
  index: Float
  partition_id: Float
}

"""aggregate sum on columns"""
type message_sum_fields {
  height: bigint
  index: bigint
  partition_id: bigint
}

"""
update columns of table "message"
"""
enum message_update_column {
  """column name"""
  height

  """column name"""
  index

  """column name"""
  involved_accounts_addresses

  """column name"""
  partition_id

  """column name"""
  transaction_hash

  """column name"""
  type

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type message_var_pop_fields {
  height: Float
  index: Float
  partition_id: Float
}

"""aggregate var_samp on columns"""
type message_var_samp_fields {
  height: Float
  index: Float
  partition_id: Float
}

"""aggregate variance on columns"""
type message_variance_fields {
  height: Float
  index: Float
  partition_id: Float
}

input messages_by_address_args {
  addresses: _text
  limit: bigint
  offset: bigint
  types: _text
}

"""
columns and relationships of "mint_params"
"""
type mint_params {
  height: bigint!
  one_row_id: Boolean!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "mint_params"
"""
type mint_params_aggregate {
  aggregate: mint_params_aggregate_fields
  nodes: [mint_params!]!
}

"""
aggregate fields of "mint_params"
"""
type mint_params_aggregate_fields {
  avg: mint_params_avg_fields
  count(columns: [mint_params_select_column!], distinct: Boolean): Int!
  max: mint_params_max_fields
  min: mint_params_min_fields
  stddev: mint_params_stddev_fields
  stddev_pop: mint_params_stddev_pop_fields
  stddev_samp: mint_params_stddev_samp_fields
  sum: mint_params_sum_fields
  var_pop: mint_params_var_pop_fields
  var_samp: mint_params_var_samp_fields
  variance: mint_params_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input mint_params_append_input {
  params: jsonb
}

"""aggregate avg on columns"""
type mint_params_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "mint_params". All fields are combined with a logical 'AND'.
"""
input mint_params_bool_exp {
  _and: [mint_params_bool_exp!]
  _not: mint_params_bool_exp
  _or: [mint_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "mint_params"
"""
enum mint_params_constraint {
  """unique or primary key constraint"""
  mint_params_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input mint_params_delete_at_path_input {
  params: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input mint_params_delete_elem_input {
  params: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input mint_params_delete_key_input {
  params: String
}

"""
input type for incrementing numeric columns in table "mint_params"
"""
input mint_params_inc_input {
  height: bigint
}

"""
input type for inserting data into table "mint_params"
"""
input mint_params_insert_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate max on columns"""
type mint_params_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type mint_params_min_fields {
  height: bigint
}

"""
response of any mutation on the table "mint_params"
"""
type mint_params_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [mint_params!]!
}

"""
on conflict condition type for table "mint_params"
"""
input mint_params_on_conflict {
  constraint: mint_params_constraint!
  update_columns: [mint_params_update_column!]! = []
  where: mint_params_bool_exp
}

"""Ordering options when selecting data from "mint_params"."""
input mint_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"""primary key columns input for table: mint_params"""
input mint_params_pk_columns_input {
  one_row_id: Boolean!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input mint_params_prepend_input {
  params: jsonb
}

"""
select columns of table "mint_params"
"""
enum mint_params_select_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""
input type for updating data in table "mint_params"
"""
input mint_params_set_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate stddev on columns"""
type mint_params_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type mint_params_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type mint_params_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type mint_params_sum_fields {
  height: bigint
}

"""
update columns of table "mint_params"
"""
enum mint_params_update_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""aggregate var_pop on columns"""
type mint_params_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type mint_params_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type mint_params_variance_fields {
  height: Float
}

"""
columns and relationships of "modules"
"""
type modules {
  module_name: String!
}

"""
aggregated selection of "modules"
"""
type modules_aggregate {
  aggregate: modules_aggregate_fields
  nodes: [modules!]!
}

"""
aggregate fields of "modules"
"""
type modules_aggregate_fields {
  count(columns: [modules_select_column!], distinct: Boolean): Int!
  max: modules_max_fields
  min: modules_min_fields
}

"""
Boolean expression to filter rows from the table "modules". All fields are combined with a logical 'AND'.
"""
input modules_bool_exp {
  _and: [modules_bool_exp!]
  _not: modules_bool_exp
  _or: [modules_bool_exp!]
  module_name: String_comparison_exp
}

"""
unique or primary key constraints on table "modules"
"""
enum modules_constraint {
  """unique or primary key constraint"""
  modules_pkey
}

"""
input type for inserting data into table "modules"
"""
input modules_insert_input {
  module_name: String
}

"""aggregate max on columns"""
type modules_max_fields {
  module_name: String
}

"""aggregate min on columns"""
type modules_min_fields {
  module_name: String
}

"""
response of any mutation on the table "modules"
"""
type modules_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [modules!]!
}

"""
on conflict condition type for table "modules"
"""
input modules_on_conflict {
  constraint: modules_constraint!
  update_columns: [modules_update_column!]! = []
  where: modules_bool_exp
}

"""Ordering options when selecting data from "modules"."""
input modules_order_by {
  module_name: order_by
}

"""primary key columns input for table: modules"""
input modules_pk_columns_input {
  module_name: String!
}

"""
select columns of table "modules"
"""
enum modules_select_column {
  """column name"""
  module_name
}

"""
input type for updating data in table "modules"
"""
input modules_set_input {
  module_name: String
}

"""
update columns of table "modules"
"""
enum modules_update_column {
  """column name"""
  module_name
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "account"
  """
  delete_account(
    """filter the rows which have to be deleted"""
    where: account_bool_exp!
  ): account_mutation_response

  """
  delete single row from the table: "account"
  """
  delete_account_by_pk(address: String!): account

  """
  delete data from the table: "assetft_params"
  """
  delete_assetft_params(
    """filter the rows which have to be deleted"""
    where: assetft_params_bool_exp!
  ): assetft_params_mutation_response

  """
  delete single row from the table: "assetft_params"
  """
  delete_assetft_params_by_pk(one_row_id: Boolean!): assetft_params

  """
  delete data from the table: "assetnft_params"
  """
  delete_assetnft_params(
    """filter the rows which have to be deleted"""
    where: assetnft_params_bool_exp!
  ): assetnft_params_mutation_response

  """
  delete single row from the table: "assetnft_params"
  """
  delete_assetnft_params_by_pk(one_row_id: Boolean!): assetnft_params

  """
  delete data from the table: "average_block_time_from_genesis"
  """
  delete_average_block_time_from_genesis(
    """filter the rows which have to be deleted"""
    where: average_block_time_from_genesis_bool_exp!
  ): average_block_time_from_genesis_mutation_response

  """
  delete single row from the table: "average_block_time_from_genesis"
  """
  delete_average_block_time_from_genesis_by_pk(one_row_id: Boolean!): average_block_time_from_genesis

  """
  delete data from the table: "average_block_time_per_day"
  """
  delete_average_block_time_per_day(
    """filter the rows which have to be deleted"""
    where: average_block_time_per_day_bool_exp!
  ): average_block_time_per_day_mutation_response

  """
  delete single row from the table: "average_block_time_per_day"
  """
  delete_average_block_time_per_day_by_pk(one_row_id: Boolean!): average_block_time_per_day

  """
  delete data from the table: "average_block_time_per_hour"
  """
  delete_average_block_time_per_hour(
    """filter the rows which have to be deleted"""
    where: average_block_time_per_hour_bool_exp!
  ): average_block_time_per_hour_mutation_response

  """
  delete single row from the table: "average_block_time_per_hour"
  """
  delete_average_block_time_per_hour_by_pk(one_row_id: Boolean!): average_block_time_per_hour

  """
  delete data from the table: "average_block_time_per_minute"
  """
  delete_average_block_time_per_minute(
    """filter the rows which have to be deleted"""
    where: average_block_time_per_minute_bool_exp!
  ): average_block_time_per_minute_mutation_response

  """
  delete single row from the table: "average_block_time_per_minute"
  """
  delete_average_block_time_per_minute_by_pk(one_row_id: Boolean!): average_block_time_per_minute

  """
  delete data from the table: "block"
  """
  delete_block(
    """filter the rows which have to be deleted"""
    where: block_bool_exp!
  ): block_mutation_response

  """
  delete single row from the table: "block"
  """
  delete_block_by_pk(height: bigint!): block

  """
  delete data from the table: "community_pool"
  """
  delete_community_pool(
    """filter the rows which have to be deleted"""
    where: community_pool_bool_exp!
  ): community_pool_mutation_response

  """
  delete single row from the table: "community_pool"
  """
  delete_community_pool_by_pk(one_row_id: Boolean!): community_pool

  """
  delete data from the table: "customparams_params"
  """
  delete_customparams_params(
    """filter the rows which have to be deleted"""
    where: customparams_params_bool_exp!
  ): customparams_params_mutation_response

  """
  delete single row from the table: "customparams_params"
  """
  delete_customparams_params_by_pk(one_row_id: Boolean!): customparams_params

  """
  delete data from the table: "distribution_params"
  """
  delete_distribution_params(
    """filter the rows which have to be deleted"""
    where: distribution_params_bool_exp!
  ): distribution_params_mutation_response

  """
  delete single row from the table: "distribution_params"
  """
  delete_distribution_params_by_pk(one_row_id: Boolean!): distribution_params

  """
  delete data from the table: "double_sign_evidence"
  """
  delete_double_sign_evidence(
    """filter the rows which have to be deleted"""
    where: double_sign_evidence_bool_exp!
  ): double_sign_evidence_mutation_response

  """
  delete data from the table: "double_sign_vote"
  """
  delete_double_sign_vote(
    """filter the rows which have to be deleted"""
    where: double_sign_vote_bool_exp!
  ): double_sign_vote_mutation_response

  """
  delete single row from the table: "double_sign_vote"
  """
  delete_double_sign_vote_by_pk(id: Int!): double_sign_vote

  """
  delete data from the table: "fee_grant_allowance"
  """
  delete_fee_grant_allowance(
    """filter the rows which have to be deleted"""
    where: fee_grant_allowance_bool_exp!
  ): fee_grant_allowance_mutation_response

  """
  delete single row from the table: "fee_grant_allowance"
  """
  delete_fee_grant_allowance_by_pk(id: Int!): fee_grant_allowance

  """
  delete data from the table: "feemodel_params"
  """
  delete_feemodel_params(
    """filter the rows which have to be deleted"""
    where: feemodel_params_bool_exp!
  ): feemodel_params_mutation_response

  """
  delete single row from the table: "feemodel_params"
  """
  delete_feemodel_params_by_pk(one_row_id: Boolean!): feemodel_params

  """
  delete data from the table: "genesis"
  """
  delete_genesis(
    """filter the rows which have to be deleted"""
    where: genesis_bool_exp!
  ): genesis_mutation_response

  """
  delete single row from the table: "genesis"
  """
  delete_genesis_by_pk(one_row_id: Boolean!): genesis

  """
  delete data from the table: "gov_params"
  """
  delete_gov_params(
    """filter the rows which have to be deleted"""
    where: gov_params_bool_exp!
  ): gov_params_mutation_response

  """
  delete single row from the table: "gov_params"
  """
  delete_gov_params_by_pk(one_row_id: Boolean!): gov_params

  """
  delete data from the table: "inflation"
  """
  delete_inflation(
    """filter the rows which have to be deleted"""
    where: inflation_bool_exp!
  ): inflation_mutation_response

  """
  delete single row from the table: "inflation"
  """
  delete_inflation_by_pk(one_row_id: Boolean!): inflation

  """
  delete data from the table: "message"
  """
  delete_message(
    """filter the rows which have to be deleted"""
    where: message_bool_exp!
  ): message_mutation_response

  """
  delete data from the table: "mint_params"
  """
  delete_mint_params(
    """filter the rows which have to be deleted"""
    where: mint_params_bool_exp!
  ): mint_params_mutation_response

  """
  delete single row from the table: "mint_params"
  """
  delete_mint_params_by_pk(one_row_id: Boolean!): mint_params

  """
  delete data from the table: "modules"
  """
  delete_modules(
    """filter the rows which have to be deleted"""
    where: modules_bool_exp!
  ): modules_mutation_response

  """
  delete single row from the table: "modules"
  """
  delete_modules_by_pk(module_name: String!): modules

  """
  delete data from the table: "pre_commit"
  """
  delete_pre_commit(
    """filter the rows which have to be deleted"""
    where: pre_commit_bool_exp!
  ): pre_commit_mutation_response

  """
  delete data from the table: "proposal"
  """
  delete_proposal(
    """filter the rows which have to be deleted"""
    where: proposal_bool_exp!
  ): proposal_mutation_response

  """
  delete single row from the table: "proposal"
  """
  delete_proposal_by_pk(id: Int!): proposal

  """
  delete data from the table: "proposal_deposit"
  """
  delete_proposal_deposit(
    """filter the rows which have to be deleted"""
    where: proposal_deposit_bool_exp!
  ): proposal_deposit_mutation_response

  """
  delete data from the table: "proposal_staking_pool_snapshot"
  """
  delete_proposal_staking_pool_snapshot(
    """filter the rows which have to be deleted"""
    where: proposal_staking_pool_snapshot_bool_exp!
  ): proposal_staking_pool_snapshot_mutation_response

  """
  delete single row from the table: "proposal_staking_pool_snapshot"
  """
  delete_proposal_staking_pool_snapshot_by_pk(proposal_id: Int!): proposal_staking_pool_snapshot

  """
  delete data from the table: "proposal_tally_result"
  """
  delete_proposal_tally_result(
    """filter the rows which have to be deleted"""
    where: proposal_tally_result_bool_exp!
  ): proposal_tally_result_mutation_response

  """
  delete single row from the table: "proposal_tally_result"
  """
  delete_proposal_tally_result_by_pk(proposal_id: Int!): proposal_tally_result

  """
  delete data from the table: "proposal_validator_status_snapshot"
  """
  delete_proposal_validator_status_snapshot(
    """filter the rows which have to be deleted"""
    where: proposal_validator_status_snapshot_bool_exp!
  ): proposal_validator_status_snapshot_mutation_response

  """
  delete single row from the table: "proposal_validator_status_snapshot"
  """
  delete_proposal_validator_status_snapshot_by_pk(id: Int!): proposal_validator_status_snapshot

  """
  delete data from the table: "proposal_vote"
  """
  delete_proposal_vote(
    """filter the rows which have to be deleted"""
    where: proposal_vote_bool_exp!
  ): proposal_vote_mutation_response

  """
  delete data from the table: "slashing_params"
  """
  delete_slashing_params(
    """filter the rows which have to be deleted"""
    where: slashing_params_bool_exp!
  ): slashing_params_mutation_response

  """
  delete single row from the table: "slashing_params"
  """
  delete_slashing_params_by_pk(one_row_id: Boolean!): slashing_params

  """
  delete data from the table: "staking_params"
  """
  delete_staking_params(
    """filter the rows which have to be deleted"""
    where: staking_params_bool_exp!
  ): staking_params_mutation_response

  """
  delete single row from the table: "staking_params"
  """
  delete_staking_params_by_pk(one_row_id: Boolean!): staking_params

  """
  delete data from the table: "staking_pool"
  """
  delete_staking_pool(
    """filter the rows which have to be deleted"""
    where: staking_pool_bool_exp!
  ): staking_pool_mutation_response

  """
  delete single row from the table: "staking_pool"
  """
  delete_staking_pool_by_pk(one_row_id: Boolean!): staking_pool

  """
  delete data from the table: "supply"
  """
  delete_supply(
    """filter the rows which have to be deleted"""
    where: supply_bool_exp!
  ): supply_mutation_response

  """
  delete single row from the table: "supply"
  """
  delete_supply_by_pk(one_row_id: Boolean!): supply

  """
  delete data from the table: "token"
  """
  delete_token(
    """filter the rows which have to be deleted"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  delete data from the table: "token_price"
  """
  delete_token_price(
    """filter the rows which have to be deleted"""
    where: token_price_bool_exp!
  ): token_price_mutation_response

  """
  delete single row from the table: "token_price"
  """
  delete_token_price_by_pk(id: Int!): token_price

  """
  delete data from the table: "token_price_history"
  """
  delete_token_price_history(
    """filter the rows which have to be deleted"""
    where: token_price_history_bool_exp!
  ): token_price_history_mutation_response

  """
  delete single row from the table: "token_price_history"
  """
  delete_token_price_history_by_pk(id: Int!): token_price_history

  """
  delete data from the table: "token_unit"
  """
  delete_token_unit(
    """filter the rows which have to be deleted"""
    where: token_unit_bool_exp!
  ): token_unit_mutation_response

  """
  delete data from the table: "transaction"
  """
  delete_transaction(
    """filter the rows which have to be deleted"""
    where: transaction_bool_exp!
  ): transaction_mutation_response

  """
  delete data from the table: "validator"
  """
  delete_validator(
    """filter the rows which have to be deleted"""
    where: validator_bool_exp!
  ): validator_mutation_response

  """
  delete single row from the table: "validator"
  """
  delete_validator_by_pk(consensus_address: String!): validator

  """
  delete data from the table: "validator_commission"
  """
  delete_validator_commission(
    """filter the rows which have to be deleted"""
    where: validator_commission_bool_exp!
  ): validator_commission_mutation_response

  """
  delete single row from the table: "validator_commission"
  """
  delete_validator_commission_by_pk(validator_address: String!): validator_commission

  """
  delete data from the table: "validator_description"
  """
  delete_validator_description(
    """filter the rows which have to be deleted"""
    where: validator_description_bool_exp!
  ): validator_description_mutation_response

  """
  delete single row from the table: "validator_description"
  """
  delete_validator_description_by_pk(validator_address: String!): validator_description

  """
  delete data from the table: "validator_info"
  """
  delete_validator_info(
    """filter the rows which have to be deleted"""
    where: validator_info_bool_exp!
  ): validator_info_mutation_response

  """
  delete single row from the table: "validator_info"
  """
  delete_validator_info_by_pk(consensus_address: String!): validator_info

  """
  delete data from the table: "validator_signing_info"
  """
  delete_validator_signing_info(
    """filter the rows which have to be deleted"""
    where: validator_signing_info_bool_exp!
  ): validator_signing_info_mutation_response

  """
  delete single row from the table: "validator_signing_info"
  """
  delete_validator_signing_info_by_pk(validator_address: String!): validator_signing_info

  """
  delete data from the table: "validator_status"
  """
  delete_validator_status(
    """filter the rows which have to be deleted"""
    where: validator_status_bool_exp!
  ): validator_status_mutation_response

  """
  delete single row from the table: "validator_status"
  """
  delete_validator_status_by_pk(validator_address: String!): validator_status

  """
  delete data from the table: "validator_voting_power"
  """
  delete_validator_voting_power(
    """filter the rows which have to be deleted"""
    where: validator_voting_power_bool_exp!
  ): validator_voting_power_mutation_response

  """
  delete single row from the table: "validator_voting_power"
  """
  delete_validator_voting_power_by_pk(validator_address: String!): validator_voting_power

  """
  delete data from the table: "vesting_account"
  """
  delete_vesting_account(
    """filter the rows which have to be deleted"""
    where: vesting_account_bool_exp!
  ): vesting_account_mutation_response

  """
  delete single row from the table: "vesting_account"
  """
  delete_vesting_account_by_pk(id: Int!): vesting_account

  """
  delete data from the table: "vesting_period"
  """
  delete_vesting_period(
    """filter the rows which have to be deleted"""
    where: vesting_period_bool_exp!
  ): vesting_period_mutation_response

  """
  insert data into the table: "account"
  """
  insert_account(
    """the rows to be inserted"""
    objects: [account_insert_input!]!

    """on conflict condition"""
    on_conflict: account_on_conflict
  ): account_mutation_response

  """
  insert a single row into the table: "account"
  """
  insert_account_one(
    """the row to be inserted"""
    object: account_insert_input!

    """on conflict condition"""
    on_conflict: account_on_conflict
  ): account

  """
  insert data into the table: "assetft_params"
  """
  insert_assetft_params(
    """the rows to be inserted"""
    objects: [assetft_params_insert_input!]!

    """on conflict condition"""
    on_conflict: assetft_params_on_conflict
  ): assetft_params_mutation_response

  """
  insert a single row into the table: "assetft_params"
  """
  insert_assetft_params_one(
    """the row to be inserted"""
    object: assetft_params_insert_input!

    """on conflict condition"""
    on_conflict: assetft_params_on_conflict
  ): assetft_params

  """
  insert data into the table: "assetnft_params"
  """
  insert_assetnft_params(
    """the rows to be inserted"""
    objects: [assetnft_params_insert_input!]!

    """on conflict condition"""
    on_conflict: assetnft_params_on_conflict
  ): assetnft_params_mutation_response

  """
  insert a single row into the table: "assetnft_params"
  """
  insert_assetnft_params_one(
    """the row to be inserted"""
    object: assetnft_params_insert_input!

    """on conflict condition"""
    on_conflict: assetnft_params_on_conflict
  ): assetnft_params

  """
  insert data into the table: "average_block_time_from_genesis"
  """
  insert_average_block_time_from_genesis(
    """the rows to be inserted"""
    objects: [average_block_time_from_genesis_insert_input!]!

    """on conflict condition"""
    on_conflict: average_block_time_from_genesis_on_conflict
  ): average_block_time_from_genesis_mutation_response

  """
  insert a single row into the table: "average_block_time_from_genesis"
  """
  insert_average_block_time_from_genesis_one(
    """the row to be inserted"""
    object: average_block_time_from_genesis_insert_input!

    """on conflict condition"""
    on_conflict: average_block_time_from_genesis_on_conflict
  ): average_block_time_from_genesis

  """
  insert data into the table: "average_block_time_per_day"
  """
  insert_average_block_time_per_day(
    """the rows to be inserted"""
    objects: [average_block_time_per_day_insert_input!]!

    """on conflict condition"""
    on_conflict: average_block_time_per_day_on_conflict
  ): average_block_time_per_day_mutation_response

  """
  insert a single row into the table: "average_block_time_per_day"
  """
  insert_average_block_time_per_day_one(
    """the row to be inserted"""
    object: average_block_time_per_day_insert_input!

    """on conflict condition"""
    on_conflict: average_block_time_per_day_on_conflict
  ): average_block_time_per_day

  """
  insert data into the table: "average_block_time_per_hour"
  """
  insert_average_block_time_per_hour(
    """the rows to be inserted"""
    objects: [average_block_time_per_hour_insert_input!]!

    """on conflict condition"""
    on_conflict: average_block_time_per_hour_on_conflict
  ): average_block_time_per_hour_mutation_response

  """
  insert a single row into the table: "average_block_time_per_hour"
  """
  insert_average_block_time_per_hour_one(
    """the row to be inserted"""
    object: average_block_time_per_hour_insert_input!

    """on conflict condition"""
    on_conflict: average_block_time_per_hour_on_conflict
  ): average_block_time_per_hour

  """
  insert data into the table: "average_block_time_per_minute"
  """
  insert_average_block_time_per_minute(
    """the rows to be inserted"""
    objects: [average_block_time_per_minute_insert_input!]!

    """on conflict condition"""
    on_conflict: average_block_time_per_minute_on_conflict
  ): average_block_time_per_minute_mutation_response

  """
  insert a single row into the table: "average_block_time_per_minute"
  """
  insert_average_block_time_per_minute_one(
    """the row to be inserted"""
    object: average_block_time_per_minute_insert_input!

    """on conflict condition"""
    on_conflict: average_block_time_per_minute_on_conflict
  ): average_block_time_per_minute

  """
  insert data into the table: "block"
  """
  insert_block(
    """the rows to be inserted"""
    objects: [block_insert_input!]!

    """on conflict condition"""
    on_conflict: block_on_conflict
  ): block_mutation_response

  """
  insert a single row into the table: "block"
  """
  insert_block_one(
    """the row to be inserted"""
    object: block_insert_input!

    """on conflict condition"""
    on_conflict: block_on_conflict
  ): block

  """
  insert data into the table: "community_pool"
  """
  insert_community_pool(
    """the rows to be inserted"""
    objects: [community_pool_insert_input!]!

    """on conflict condition"""
    on_conflict: community_pool_on_conflict
  ): community_pool_mutation_response

  """
  insert a single row into the table: "community_pool"
  """
  insert_community_pool_one(
    """the row to be inserted"""
    object: community_pool_insert_input!

    """on conflict condition"""
    on_conflict: community_pool_on_conflict
  ): community_pool

  """
  insert data into the table: "customparams_params"
  """
  insert_customparams_params(
    """the rows to be inserted"""
    objects: [customparams_params_insert_input!]!

    """on conflict condition"""
    on_conflict: customparams_params_on_conflict
  ): customparams_params_mutation_response

  """
  insert a single row into the table: "customparams_params"
  """
  insert_customparams_params_one(
    """the row to be inserted"""
    object: customparams_params_insert_input!

    """on conflict condition"""
    on_conflict: customparams_params_on_conflict
  ): customparams_params

  """
  insert data into the table: "distribution_params"
  """
  insert_distribution_params(
    """the rows to be inserted"""
    objects: [distribution_params_insert_input!]!

    """on conflict condition"""
    on_conflict: distribution_params_on_conflict
  ): distribution_params_mutation_response

  """
  insert a single row into the table: "distribution_params"
  """
  insert_distribution_params_one(
    """the row to be inserted"""
    object: distribution_params_insert_input!

    """on conflict condition"""
    on_conflict: distribution_params_on_conflict
  ): distribution_params

  """
  insert data into the table: "double_sign_evidence"
  """
  insert_double_sign_evidence(
    """the rows to be inserted"""
    objects: [double_sign_evidence_insert_input!]!
  ): double_sign_evidence_mutation_response

  """
  insert a single row into the table: "double_sign_evidence"
  """
  insert_double_sign_evidence_one(
    """the row to be inserted"""
    object: double_sign_evidence_insert_input!
  ): double_sign_evidence

  """
  insert data into the table: "double_sign_vote"
  """
  insert_double_sign_vote(
    """the rows to be inserted"""
    objects: [double_sign_vote_insert_input!]!

    """on conflict condition"""
    on_conflict: double_sign_vote_on_conflict
  ): double_sign_vote_mutation_response

  """
  insert a single row into the table: "double_sign_vote"
  """
  insert_double_sign_vote_one(
    """the row to be inserted"""
    object: double_sign_vote_insert_input!

    """on conflict condition"""
    on_conflict: double_sign_vote_on_conflict
  ): double_sign_vote

  """
  insert data into the table: "fee_grant_allowance"
  """
  insert_fee_grant_allowance(
    """the rows to be inserted"""
    objects: [fee_grant_allowance_insert_input!]!

    """on conflict condition"""
    on_conflict: fee_grant_allowance_on_conflict
  ): fee_grant_allowance_mutation_response

  """
  insert a single row into the table: "fee_grant_allowance"
  """
  insert_fee_grant_allowance_one(
    """the row to be inserted"""
    object: fee_grant_allowance_insert_input!

    """on conflict condition"""
    on_conflict: fee_grant_allowance_on_conflict
  ): fee_grant_allowance

  """
  insert data into the table: "feemodel_params"
  """
  insert_feemodel_params(
    """the rows to be inserted"""
    objects: [feemodel_params_insert_input!]!

    """on conflict condition"""
    on_conflict: feemodel_params_on_conflict
  ): feemodel_params_mutation_response

  """
  insert a single row into the table: "feemodel_params"
  """
  insert_feemodel_params_one(
    """the row to be inserted"""
    object: feemodel_params_insert_input!

    """on conflict condition"""
    on_conflict: feemodel_params_on_conflict
  ): feemodel_params

  """
  insert data into the table: "genesis"
  """
  insert_genesis(
    """the rows to be inserted"""
    objects: [genesis_insert_input!]!

    """on conflict condition"""
    on_conflict: genesis_on_conflict
  ): genesis_mutation_response

  """
  insert a single row into the table: "genesis"
  """
  insert_genesis_one(
    """the row to be inserted"""
    object: genesis_insert_input!

    """on conflict condition"""
    on_conflict: genesis_on_conflict
  ): genesis

  """
  insert data into the table: "gov_params"
  """
  insert_gov_params(
    """the rows to be inserted"""
    objects: [gov_params_insert_input!]!

    """on conflict condition"""
    on_conflict: gov_params_on_conflict
  ): gov_params_mutation_response

  """
  insert a single row into the table: "gov_params"
  """
  insert_gov_params_one(
    """the row to be inserted"""
    object: gov_params_insert_input!

    """on conflict condition"""
    on_conflict: gov_params_on_conflict
  ): gov_params

  """
  insert data into the table: "inflation"
  """
  insert_inflation(
    """the rows to be inserted"""
    objects: [inflation_insert_input!]!

    """on conflict condition"""
    on_conflict: inflation_on_conflict
  ): inflation_mutation_response

  """
  insert a single row into the table: "inflation"
  """
  insert_inflation_one(
    """the row to be inserted"""
    object: inflation_insert_input!

    """on conflict condition"""
    on_conflict: inflation_on_conflict
  ): inflation

  """
  insert data into the table: "message"
  """
  insert_message(
    """the rows to be inserted"""
    objects: [message_insert_input!]!

    """on conflict condition"""
    on_conflict: message_on_conflict
  ): message_mutation_response

  """
  insert a single row into the table: "message"
  """
  insert_message_one(
    """the row to be inserted"""
    object: message_insert_input!

    """on conflict condition"""
    on_conflict: message_on_conflict
  ): message

  """
  insert data into the table: "mint_params"
  """
  insert_mint_params(
    """the rows to be inserted"""
    objects: [mint_params_insert_input!]!

    """on conflict condition"""
    on_conflict: mint_params_on_conflict
  ): mint_params_mutation_response

  """
  insert a single row into the table: "mint_params"
  """
  insert_mint_params_one(
    """the row to be inserted"""
    object: mint_params_insert_input!

    """on conflict condition"""
    on_conflict: mint_params_on_conflict
  ): mint_params

  """
  insert data into the table: "modules"
  """
  insert_modules(
    """the rows to be inserted"""
    objects: [modules_insert_input!]!

    """on conflict condition"""
    on_conflict: modules_on_conflict
  ): modules_mutation_response

  """
  insert a single row into the table: "modules"
  """
  insert_modules_one(
    """the row to be inserted"""
    object: modules_insert_input!

    """on conflict condition"""
    on_conflict: modules_on_conflict
  ): modules

  """
  insert data into the table: "pre_commit"
  """
  insert_pre_commit(
    """the rows to be inserted"""
    objects: [pre_commit_insert_input!]!

    """on conflict condition"""
    on_conflict: pre_commit_on_conflict
  ): pre_commit_mutation_response

  """
  insert a single row into the table: "pre_commit"
  """
  insert_pre_commit_one(
    """the row to be inserted"""
    object: pre_commit_insert_input!

    """on conflict condition"""
    on_conflict: pre_commit_on_conflict
  ): pre_commit

  """
  insert data into the table: "proposal"
  """
  insert_proposal(
    """the rows to be inserted"""
    objects: [proposal_insert_input!]!

    """on conflict condition"""
    on_conflict: proposal_on_conflict
  ): proposal_mutation_response

  """
  insert data into the table: "proposal_deposit"
  """
  insert_proposal_deposit(
    """the rows to be inserted"""
    objects: [proposal_deposit_insert_input!]!

    """on conflict condition"""
    on_conflict: proposal_deposit_on_conflict
  ): proposal_deposit_mutation_response

  """
  insert a single row into the table: "proposal_deposit"
  """
  insert_proposal_deposit_one(
    """the row to be inserted"""
    object: proposal_deposit_insert_input!

    """on conflict condition"""
    on_conflict: proposal_deposit_on_conflict
  ): proposal_deposit

  """
  insert a single row into the table: "proposal"
  """
  insert_proposal_one(
    """the row to be inserted"""
    object: proposal_insert_input!

    """on conflict condition"""
    on_conflict: proposal_on_conflict
  ): proposal

  """
  insert data into the table: "proposal_staking_pool_snapshot"
  """
  insert_proposal_staking_pool_snapshot(
    """the rows to be inserted"""
    objects: [proposal_staking_pool_snapshot_insert_input!]!

    """on conflict condition"""
    on_conflict: proposal_staking_pool_snapshot_on_conflict
  ): proposal_staking_pool_snapshot_mutation_response

  """
  insert a single row into the table: "proposal_staking_pool_snapshot"
  """
  insert_proposal_staking_pool_snapshot_one(
    """the row to be inserted"""
    object: proposal_staking_pool_snapshot_insert_input!

    """on conflict condition"""
    on_conflict: proposal_staking_pool_snapshot_on_conflict
  ): proposal_staking_pool_snapshot

  """
  insert data into the table: "proposal_tally_result"
  """
  insert_proposal_tally_result(
    """the rows to be inserted"""
    objects: [proposal_tally_result_insert_input!]!

    """on conflict condition"""
    on_conflict: proposal_tally_result_on_conflict
  ): proposal_tally_result_mutation_response

  """
  insert a single row into the table: "proposal_tally_result"
  """
  insert_proposal_tally_result_one(
    """the row to be inserted"""
    object: proposal_tally_result_insert_input!

    """on conflict condition"""
    on_conflict: proposal_tally_result_on_conflict
  ): proposal_tally_result

  """
  insert data into the table: "proposal_validator_status_snapshot"
  """
  insert_proposal_validator_status_snapshot(
    """the rows to be inserted"""
    objects: [proposal_validator_status_snapshot_insert_input!]!

    """on conflict condition"""
    on_conflict: proposal_validator_status_snapshot_on_conflict
  ): proposal_validator_status_snapshot_mutation_response

  """
  insert a single row into the table: "proposal_validator_status_snapshot"
  """
  insert_proposal_validator_status_snapshot_one(
    """the row to be inserted"""
    object: proposal_validator_status_snapshot_insert_input!

    """on conflict condition"""
    on_conflict: proposal_validator_status_snapshot_on_conflict
  ): proposal_validator_status_snapshot

  """
  insert data into the table: "proposal_vote"
  """
  insert_proposal_vote(
    """the rows to be inserted"""
    objects: [proposal_vote_insert_input!]!

    """on conflict condition"""
    on_conflict: proposal_vote_on_conflict
  ): proposal_vote_mutation_response

  """
  insert a single row into the table: "proposal_vote"
  """
  insert_proposal_vote_one(
    """the row to be inserted"""
    object: proposal_vote_insert_input!

    """on conflict condition"""
    on_conflict: proposal_vote_on_conflict
  ): proposal_vote

  """
  insert data into the table: "slashing_params"
  """
  insert_slashing_params(
    """the rows to be inserted"""
    objects: [slashing_params_insert_input!]!

    """on conflict condition"""
    on_conflict: slashing_params_on_conflict
  ): slashing_params_mutation_response

  """
  insert a single row into the table: "slashing_params"
  """
  insert_slashing_params_one(
    """the row to be inserted"""
    object: slashing_params_insert_input!

    """on conflict condition"""
    on_conflict: slashing_params_on_conflict
  ): slashing_params

  """
  insert data into the table: "staking_params"
  """
  insert_staking_params(
    """the rows to be inserted"""
    objects: [staking_params_insert_input!]!

    """on conflict condition"""
    on_conflict: staking_params_on_conflict
  ): staking_params_mutation_response

  """
  insert a single row into the table: "staking_params"
  """
  insert_staking_params_one(
    """the row to be inserted"""
    object: staking_params_insert_input!

    """on conflict condition"""
    on_conflict: staking_params_on_conflict
  ): staking_params

  """
  insert data into the table: "staking_pool"
  """
  insert_staking_pool(
    """the rows to be inserted"""
    objects: [staking_pool_insert_input!]!

    """on conflict condition"""
    on_conflict: staking_pool_on_conflict
  ): staking_pool_mutation_response

  """
  insert a single row into the table: "staking_pool"
  """
  insert_staking_pool_one(
    """the row to be inserted"""
    object: staking_pool_insert_input!

    """on conflict condition"""
    on_conflict: staking_pool_on_conflict
  ): staking_pool

  """
  insert data into the table: "supply"
  """
  insert_supply(
    """the rows to be inserted"""
    objects: [supply_insert_input!]!

    """on conflict condition"""
    on_conflict: supply_on_conflict
  ): supply_mutation_response

  """
  insert a single row into the table: "supply"
  """
  insert_supply_one(
    """the row to be inserted"""
    object: supply_insert_input!

    """on conflict condition"""
    on_conflict: supply_on_conflict
  ): supply

  """
  insert data into the table: "token"
  """
  insert_token(
    """the rows to be inserted"""
    objects: [token_insert_input!]!

    """on conflict condition"""
    on_conflict: token_on_conflict
  ): token_mutation_response

  """
  insert a single row into the table: "token"
  """
  insert_token_one(
    """the row to be inserted"""
    object: token_insert_input!

    """on conflict condition"""
    on_conflict: token_on_conflict
  ): token

  """
  insert data into the table: "token_price"
  """
  insert_token_price(
    """the rows to be inserted"""
    objects: [token_price_insert_input!]!

    """on conflict condition"""
    on_conflict: token_price_on_conflict
  ): token_price_mutation_response

  """
  insert data into the table: "token_price_history"
  """
  insert_token_price_history(
    """the rows to be inserted"""
    objects: [token_price_history_insert_input!]!

    """on conflict condition"""
    on_conflict: token_price_history_on_conflict
  ): token_price_history_mutation_response

  """
  insert a single row into the table: "token_price_history"
  """
  insert_token_price_history_one(
    """the row to be inserted"""
    object: token_price_history_insert_input!

    """on conflict condition"""
    on_conflict: token_price_history_on_conflict
  ): token_price_history

  """
  insert a single row into the table: "token_price"
  """
  insert_token_price_one(
    """the row to be inserted"""
    object: token_price_insert_input!

    """on conflict condition"""
    on_conflict: token_price_on_conflict
  ): token_price

  """
  insert data into the table: "token_unit"
  """
  insert_token_unit(
    """the rows to be inserted"""
    objects: [token_unit_insert_input!]!

    """on conflict condition"""
    on_conflict: token_unit_on_conflict
  ): token_unit_mutation_response

  """
  insert a single row into the table: "token_unit"
  """
  insert_token_unit_one(
    """the row to be inserted"""
    object: token_unit_insert_input!

    """on conflict condition"""
    on_conflict: token_unit_on_conflict
  ): token_unit

  """
  insert data into the table: "transaction"
  """
  insert_transaction(
    """the rows to be inserted"""
    objects: [transaction_insert_input!]!

    """on conflict condition"""
    on_conflict: transaction_on_conflict
  ): transaction_mutation_response

  """
  insert a single row into the table: "transaction"
  """
  insert_transaction_one(
    """the row to be inserted"""
    object: transaction_insert_input!

    """on conflict condition"""
    on_conflict: transaction_on_conflict
  ): transaction

  """
  insert data into the table: "validator"
  """
  insert_validator(
    """the rows to be inserted"""
    objects: [validator_insert_input!]!

    """on conflict condition"""
    on_conflict: validator_on_conflict
  ): validator_mutation_response

  """
  insert data into the table: "validator_commission"
  """
  insert_validator_commission(
    """the rows to be inserted"""
    objects: [validator_commission_insert_input!]!

    """on conflict condition"""
    on_conflict: validator_commission_on_conflict
  ): validator_commission_mutation_response

  """
  insert a single row into the table: "validator_commission"
  """
  insert_validator_commission_one(
    """the row to be inserted"""
    object: validator_commission_insert_input!

    """on conflict condition"""
    on_conflict: validator_commission_on_conflict
  ): validator_commission

  """
  insert data into the table: "validator_description"
  """
  insert_validator_description(
    """the rows to be inserted"""
    objects: [validator_description_insert_input!]!

    """on conflict condition"""
    on_conflict: validator_description_on_conflict
  ): validator_description_mutation_response

  """
  insert a single row into the table: "validator_description"
  """
  insert_validator_description_one(
    """the row to be inserted"""
    object: validator_description_insert_input!

    """on conflict condition"""
    on_conflict: validator_description_on_conflict
  ): validator_description

  """
  insert data into the table: "validator_info"
  """
  insert_validator_info(
    """the rows to be inserted"""
    objects: [validator_info_insert_input!]!

    """on conflict condition"""
    on_conflict: validator_info_on_conflict
  ): validator_info_mutation_response

  """
  insert a single row into the table: "validator_info"
  """
  insert_validator_info_one(
    """the row to be inserted"""
    object: validator_info_insert_input!

    """on conflict condition"""
    on_conflict: validator_info_on_conflict
  ): validator_info

  """
  insert a single row into the table: "validator"
  """
  insert_validator_one(
    """the row to be inserted"""
    object: validator_insert_input!

    """on conflict condition"""
    on_conflict: validator_on_conflict
  ): validator

  """
  insert data into the table: "validator_signing_info"
  """
  insert_validator_signing_info(
    """the rows to be inserted"""
    objects: [validator_signing_info_insert_input!]!

    """on conflict condition"""
    on_conflict: validator_signing_info_on_conflict
  ): validator_signing_info_mutation_response

  """
  insert a single row into the table: "validator_signing_info"
  """
  insert_validator_signing_info_one(
    """the row to be inserted"""
    object: validator_signing_info_insert_input!

    """on conflict condition"""
    on_conflict: validator_signing_info_on_conflict
  ): validator_signing_info

  """
  insert data into the table: "validator_status"
  """
  insert_validator_status(
    """the rows to be inserted"""
    objects: [validator_status_insert_input!]!

    """on conflict condition"""
    on_conflict: validator_status_on_conflict
  ): validator_status_mutation_response

  """
  insert a single row into the table: "validator_status"
  """
  insert_validator_status_one(
    """the row to be inserted"""
    object: validator_status_insert_input!

    """on conflict condition"""
    on_conflict: validator_status_on_conflict
  ): validator_status

  """
  insert data into the table: "validator_voting_power"
  """
  insert_validator_voting_power(
    """the rows to be inserted"""
    objects: [validator_voting_power_insert_input!]!

    """on conflict condition"""
    on_conflict: validator_voting_power_on_conflict
  ): validator_voting_power_mutation_response

  """
  insert a single row into the table: "validator_voting_power"
  """
  insert_validator_voting_power_one(
    """the row to be inserted"""
    object: validator_voting_power_insert_input!

    """on conflict condition"""
    on_conflict: validator_voting_power_on_conflict
  ): validator_voting_power

  """
  insert data into the table: "vesting_account"
  """
  insert_vesting_account(
    """the rows to be inserted"""
    objects: [vesting_account_insert_input!]!

    """on conflict condition"""
    on_conflict: vesting_account_on_conflict
  ): vesting_account_mutation_response

  """
  insert a single row into the table: "vesting_account"
  """
  insert_vesting_account_one(
    """the row to be inserted"""
    object: vesting_account_insert_input!

    """on conflict condition"""
    on_conflict: vesting_account_on_conflict
  ): vesting_account

  """
  insert data into the table: "vesting_period"
  """
  insert_vesting_period(
    """the rows to be inserted"""
    objects: [vesting_period_insert_input!]!
  ): vesting_period_mutation_response

  """
  insert a single row into the table: "vesting_period"
  """
  insert_vesting_period_one(
    """the row to be inserted"""
    object: vesting_period_insert_input!
  ): vesting_period

  """
  update data of the table: "account"
  """
  update_account(
    """sets the columns of the filtered rows to the given values"""
    _set: account_set_input

    """filter the rows which have to be updated"""
    where: account_bool_exp!
  ): account_mutation_response

  """
  update single row of the table: "account"
  """
  update_account_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: account_set_input
    pk_columns: account_pk_columns_input!
  ): account

  """
  update data of the table: "assetft_params"
  """
  update_assetft_params(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: assetft_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: assetft_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: assetft_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: assetft_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: assetft_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: assetft_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: assetft_params_set_input

    """filter the rows which have to be updated"""
    where: assetft_params_bool_exp!
  ): assetft_params_mutation_response

  """
  update single row of the table: "assetft_params"
  """
  update_assetft_params_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: assetft_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: assetft_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: assetft_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: assetft_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: assetft_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: assetft_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: assetft_params_set_input
    pk_columns: assetft_params_pk_columns_input!
  ): assetft_params

  """
  update data of the table: "assetnft_params"
  """
  update_assetnft_params(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: assetnft_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: assetnft_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: assetnft_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: assetnft_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: assetnft_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: assetnft_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: assetnft_params_set_input

    """filter the rows which have to be updated"""
    where: assetnft_params_bool_exp!
  ): assetnft_params_mutation_response

  """
  update single row of the table: "assetnft_params"
  """
  update_assetnft_params_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: assetnft_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: assetnft_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: assetnft_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: assetnft_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: assetnft_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: assetnft_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: assetnft_params_set_input
    pk_columns: assetnft_params_pk_columns_input!
  ): assetnft_params

  """
  update data of the table: "average_block_time_from_genesis"
  """
  update_average_block_time_from_genesis(
    """increments the numeric columns with given value of the filtered values"""
    _inc: average_block_time_from_genesis_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: average_block_time_from_genesis_set_input

    """filter the rows which have to be updated"""
    where: average_block_time_from_genesis_bool_exp!
  ): average_block_time_from_genesis_mutation_response

  """
  update single row of the table: "average_block_time_from_genesis"
  """
  update_average_block_time_from_genesis_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: average_block_time_from_genesis_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: average_block_time_from_genesis_set_input
    pk_columns: average_block_time_from_genesis_pk_columns_input!
  ): average_block_time_from_genesis

  """
  update data of the table: "average_block_time_per_day"
  """
  update_average_block_time_per_day(
    """increments the numeric columns with given value of the filtered values"""
    _inc: average_block_time_per_day_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: average_block_time_per_day_set_input

    """filter the rows which have to be updated"""
    where: average_block_time_per_day_bool_exp!
  ): average_block_time_per_day_mutation_response

  """
  update single row of the table: "average_block_time_per_day"
  """
  update_average_block_time_per_day_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: average_block_time_per_day_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: average_block_time_per_day_set_input
    pk_columns: average_block_time_per_day_pk_columns_input!
  ): average_block_time_per_day

  """
  update data of the table: "average_block_time_per_hour"
  """
  update_average_block_time_per_hour(
    """increments the numeric columns with given value of the filtered values"""
    _inc: average_block_time_per_hour_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: average_block_time_per_hour_set_input

    """filter the rows which have to be updated"""
    where: average_block_time_per_hour_bool_exp!
  ): average_block_time_per_hour_mutation_response

  """
  update single row of the table: "average_block_time_per_hour"
  """
  update_average_block_time_per_hour_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: average_block_time_per_hour_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: average_block_time_per_hour_set_input
    pk_columns: average_block_time_per_hour_pk_columns_input!
  ): average_block_time_per_hour

  """
  update data of the table: "average_block_time_per_minute"
  """
  update_average_block_time_per_minute(
    """increments the numeric columns with given value of the filtered values"""
    _inc: average_block_time_per_minute_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: average_block_time_per_minute_set_input

    """filter the rows which have to be updated"""
    where: average_block_time_per_minute_bool_exp!
  ): average_block_time_per_minute_mutation_response

  """
  update single row of the table: "average_block_time_per_minute"
  """
  update_average_block_time_per_minute_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: average_block_time_per_minute_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: average_block_time_per_minute_set_input
    pk_columns: average_block_time_per_minute_pk_columns_input!
  ): average_block_time_per_minute

  """
  update data of the table: "block"
  """
  update_block(
    """increments the numeric columns with given value of the filtered values"""
    _inc: block_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: block_set_input

    """filter the rows which have to be updated"""
    where: block_bool_exp!
  ): block_mutation_response

  """
  update single row of the table: "block"
  """
  update_block_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: block_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: block_set_input
    pk_columns: block_pk_columns_input!
  ): block

  """
  update data of the table: "community_pool"
  """
  update_community_pool(
    """increments the numeric columns with given value of the filtered values"""
    _inc: community_pool_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: community_pool_set_input

    """filter the rows which have to be updated"""
    where: community_pool_bool_exp!
  ): community_pool_mutation_response

  """
  update single row of the table: "community_pool"
  """
  update_community_pool_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: community_pool_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: community_pool_set_input
    pk_columns: community_pool_pk_columns_input!
  ): community_pool

  """
  update data of the table: "customparams_params"
  """
  update_customparams_params(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: customparams_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: customparams_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: customparams_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: customparams_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: customparams_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: customparams_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: customparams_params_set_input

    """filter the rows which have to be updated"""
    where: customparams_params_bool_exp!
  ): customparams_params_mutation_response

  """
  update single row of the table: "customparams_params"
  """
  update_customparams_params_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: customparams_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: customparams_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: customparams_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: customparams_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: customparams_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: customparams_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: customparams_params_set_input
    pk_columns: customparams_params_pk_columns_input!
  ): customparams_params

  """
  update data of the table: "distribution_params"
  """
  update_distribution_params(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: distribution_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: distribution_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: distribution_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: distribution_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: distribution_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: distribution_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: distribution_params_set_input

    """filter the rows which have to be updated"""
    where: distribution_params_bool_exp!
  ): distribution_params_mutation_response

  """
  update single row of the table: "distribution_params"
  """
  update_distribution_params_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: distribution_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: distribution_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: distribution_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: distribution_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: distribution_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: distribution_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: distribution_params_set_input
    pk_columns: distribution_params_pk_columns_input!
  ): distribution_params

  """
  update data of the table: "double_sign_evidence"
  """
  update_double_sign_evidence(
    """increments the numeric columns with given value of the filtered values"""
    _inc: double_sign_evidence_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: double_sign_evidence_set_input

    """filter the rows which have to be updated"""
    where: double_sign_evidence_bool_exp!
  ): double_sign_evidence_mutation_response

  """
  update data of the table: "double_sign_vote"
  """
  update_double_sign_vote(
    """increments the numeric columns with given value of the filtered values"""
    _inc: double_sign_vote_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: double_sign_vote_set_input

    """filter the rows which have to be updated"""
    where: double_sign_vote_bool_exp!
  ): double_sign_vote_mutation_response

  """
  update single row of the table: "double_sign_vote"
  """
  update_double_sign_vote_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: double_sign_vote_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: double_sign_vote_set_input
    pk_columns: double_sign_vote_pk_columns_input!
  ): double_sign_vote

  """
  update data of the table: "fee_grant_allowance"
  """
  update_fee_grant_allowance(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: fee_grant_allowance_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: fee_grant_allowance_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: fee_grant_allowance_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: fee_grant_allowance_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: fee_grant_allowance_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: fee_grant_allowance_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: fee_grant_allowance_set_input

    """filter the rows which have to be updated"""
    where: fee_grant_allowance_bool_exp!
  ): fee_grant_allowance_mutation_response

  """
  update single row of the table: "fee_grant_allowance"
  """
  update_fee_grant_allowance_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: fee_grant_allowance_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: fee_grant_allowance_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: fee_grant_allowance_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: fee_grant_allowance_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: fee_grant_allowance_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: fee_grant_allowance_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: fee_grant_allowance_set_input
    pk_columns: fee_grant_allowance_pk_columns_input!
  ): fee_grant_allowance

  """
  update data of the table: "feemodel_params"
  """
  update_feemodel_params(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: feemodel_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feemodel_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feemodel_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feemodel_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: feemodel_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: feemodel_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: feemodel_params_set_input

    """filter the rows which have to be updated"""
    where: feemodel_params_bool_exp!
  ): feemodel_params_mutation_response

  """
  update single row of the table: "feemodel_params"
  """
  update_feemodel_params_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: feemodel_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feemodel_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feemodel_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feemodel_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: feemodel_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: feemodel_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: feemodel_params_set_input
    pk_columns: feemodel_params_pk_columns_input!
  ): feemodel_params

  """
  update data of the table: "genesis"
  """
  update_genesis(
    """increments the numeric columns with given value of the filtered values"""
    _inc: genesis_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: genesis_set_input

    """filter the rows which have to be updated"""
    where: genesis_bool_exp!
  ): genesis_mutation_response

  """
  update single row of the table: "genesis"
  """
  update_genesis_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: genesis_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: genesis_set_input
    pk_columns: genesis_pk_columns_input!
  ): genesis

  """
  update data of the table: "gov_params"
  """
  update_gov_params(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: gov_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: gov_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: gov_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: gov_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: gov_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: gov_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: gov_params_set_input

    """filter the rows which have to be updated"""
    where: gov_params_bool_exp!
  ): gov_params_mutation_response

  """
  update single row of the table: "gov_params"
  """
  update_gov_params_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: gov_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: gov_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: gov_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: gov_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: gov_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: gov_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: gov_params_set_input
    pk_columns: gov_params_pk_columns_input!
  ): gov_params

  """
  update data of the table: "inflation"
  """
  update_inflation(
    """increments the numeric columns with given value of the filtered values"""
    _inc: inflation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: inflation_set_input

    """filter the rows which have to be updated"""
    where: inflation_bool_exp!
  ): inflation_mutation_response

  """
  update single row of the table: "inflation"
  """
  update_inflation_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: inflation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: inflation_set_input
    pk_columns: inflation_pk_columns_input!
  ): inflation

  """
  update data of the table: "message"
  """
  update_message(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: message_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: message_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: message_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: message_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: message_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: message_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: message_set_input

    """filter the rows which have to be updated"""
    where: message_bool_exp!
  ): message_mutation_response

  """
  update data of the table: "mint_params"
  """
  update_mint_params(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: mint_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: mint_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: mint_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: mint_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: mint_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: mint_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: mint_params_set_input

    """filter the rows which have to be updated"""
    where: mint_params_bool_exp!
  ): mint_params_mutation_response

  """
  update single row of the table: "mint_params"
  """
  update_mint_params_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: mint_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: mint_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: mint_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: mint_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: mint_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: mint_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: mint_params_set_input
    pk_columns: mint_params_pk_columns_input!
  ): mint_params

  """
  update data of the table: "modules"
  """
  update_modules(
    """sets the columns of the filtered rows to the given values"""
    _set: modules_set_input

    """filter the rows which have to be updated"""
    where: modules_bool_exp!
  ): modules_mutation_response

  """
  update single row of the table: "modules"
  """
  update_modules_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: modules_set_input
    pk_columns: modules_pk_columns_input!
  ): modules

  """
  update data of the table: "pre_commit"
  """
  update_pre_commit(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pre_commit_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pre_commit_set_input

    """filter the rows which have to be updated"""
    where: pre_commit_bool_exp!
  ): pre_commit_mutation_response

  """
  update data of the table: "proposal"
  """
  update_proposal(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: proposal_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: proposal_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: proposal_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: proposal_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: proposal_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_set_input

    """filter the rows which have to be updated"""
    where: proposal_bool_exp!
  ): proposal_mutation_response

  """
  update single row of the table: "proposal"
  """
  update_proposal_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: proposal_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: proposal_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: proposal_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: proposal_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: proposal_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_set_input
    pk_columns: proposal_pk_columns_input!
  ): proposal

  """
  update data of the table: "proposal_deposit"
  """
  update_proposal_deposit(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_deposit_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_deposit_set_input

    """filter the rows which have to be updated"""
    where: proposal_deposit_bool_exp!
  ): proposal_deposit_mutation_response

  """
  update data of the table: "proposal_staking_pool_snapshot"
  """
  update_proposal_staking_pool_snapshot(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_staking_pool_snapshot_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_staking_pool_snapshot_set_input

    """filter the rows which have to be updated"""
    where: proposal_staking_pool_snapshot_bool_exp!
  ): proposal_staking_pool_snapshot_mutation_response

  """
  update single row of the table: "proposal_staking_pool_snapshot"
  """
  update_proposal_staking_pool_snapshot_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_staking_pool_snapshot_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_staking_pool_snapshot_set_input
    pk_columns: proposal_staking_pool_snapshot_pk_columns_input!
  ): proposal_staking_pool_snapshot

  """
  update data of the table: "proposal_tally_result"
  """
  update_proposal_tally_result(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_tally_result_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_tally_result_set_input

    """filter the rows which have to be updated"""
    where: proposal_tally_result_bool_exp!
  ): proposal_tally_result_mutation_response

  """
  update single row of the table: "proposal_tally_result"
  """
  update_proposal_tally_result_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_tally_result_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_tally_result_set_input
    pk_columns: proposal_tally_result_pk_columns_input!
  ): proposal_tally_result

  """
  update data of the table: "proposal_validator_status_snapshot"
  """
  update_proposal_validator_status_snapshot(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_validator_status_snapshot_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_validator_status_snapshot_set_input

    """filter the rows which have to be updated"""
    where: proposal_validator_status_snapshot_bool_exp!
  ): proposal_validator_status_snapshot_mutation_response

  """
  update single row of the table: "proposal_validator_status_snapshot"
  """
  update_proposal_validator_status_snapshot_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_validator_status_snapshot_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_validator_status_snapshot_set_input
    pk_columns: proposal_validator_status_snapshot_pk_columns_input!
  ): proposal_validator_status_snapshot

  """
  update data of the table: "proposal_vote"
  """
  update_proposal_vote(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_vote_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_vote_set_input

    """filter the rows which have to be updated"""
    where: proposal_vote_bool_exp!
  ): proposal_vote_mutation_response

  """
  update data of the table: "slashing_params"
  """
  update_slashing_params(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: slashing_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: slashing_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: slashing_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: slashing_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: slashing_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: slashing_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: slashing_params_set_input

    """filter the rows which have to be updated"""
    where: slashing_params_bool_exp!
  ): slashing_params_mutation_response

  """
  update single row of the table: "slashing_params"
  """
  update_slashing_params_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: slashing_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: slashing_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: slashing_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: slashing_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: slashing_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: slashing_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: slashing_params_set_input
    pk_columns: slashing_params_pk_columns_input!
  ): slashing_params

  """
  update data of the table: "staking_params"
  """
  update_staking_params(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: staking_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: staking_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: staking_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: staking_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: staking_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: staking_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: staking_params_set_input

    """filter the rows which have to be updated"""
    where: staking_params_bool_exp!
  ): staking_params_mutation_response

  """
  update single row of the table: "staking_params"
  """
  update_staking_params_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: staking_params_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: staking_params_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: staking_params_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: staking_params_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: staking_params_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: staking_params_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: staking_params_set_input
    pk_columns: staking_params_pk_columns_input!
  ): staking_params

  """
  update data of the table: "staking_pool"
  """
  update_staking_pool(
    """increments the numeric columns with given value of the filtered values"""
    _inc: staking_pool_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: staking_pool_set_input

    """filter the rows which have to be updated"""
    where: staking_pool_bool_exp!
  ): staking_pool_mutation_response

  """
  update single row of the table: "staking_pool"
  """
  update_staking_pool_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: staking_pool_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: staking_pool_set_input
    pk_columns: staking_pool_pk_columns_input!
  ): staking_pool

  """
  update data of the table: "supply"
  """
  update_supply(
    """increments the numeric columns with given value of the filtered values"""
    _inc: supply_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: supply_set_input

    """filter the rows which have to be updated"""
    where: supply_bool_exp!
  ): supply_mutation_response

  """
  update single row of the table: "supply"
  """
  update_supply_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: supply_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: supply_set_input
    pk_columns: supply_pk_columns_input!
  ): supply

  """
  update data of the table: "token"
  """
  update_token(
    """sets the columns of the filtered rows to the given values"""
    _set: token_set_input

    """filter the rows which have to be updated"""
    where: token_bool_exp!
  ): token_mutation_response

  """
  update data of the table: "token_price"
  """
  update_token_price(
    """increments the numeric columns with given value of the filtered values"""
    _inc: token_price_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: token_price_set_input

    """filter the rows which have to be updated"""
    where: token_price_bool_exp!
  ): token_price_mutation_response

  """
  update single row of the table: "token_price"
  """
  update_token_price_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: token_price_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: token_price_set_input
    pk_columns: token_price_pk_columns_input!
  ): token_price

  """
  update data of the table: "token_price_history"
  """
  update_token_price_history(
    """increments the numeric columns with given value of the filtered values"""
    _inc: token_price_history_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: token_price_history_set_input

    """filter the rows which have to be updated"""
    where: token_price_history_bool_exp!
  ): token_price_history_mutation_response

  """
  update single row of the table: "token_price_history"
  """
  update_token_price_history_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: token_price_history_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: token_price_history_set_input
    pk_columns: token_price_history_pk_columns_input!
  ): token_price_history

  """
  update data of the table: "token_unit"
  """
  update_token_unit(
    """increments the numeric columns with given value of the filtered values"""
    _inc: token_unit_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: token_unit_set_input

    """filter the rows which have to be updated"""
    where: token_unit_bool_exp!
  ): token_unit_mutation_response

  """
  update data of the table: "transaction"
  """
  update_transaction(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: transaction_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transaction_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transaction_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transaction_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: transaction_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: transaction_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: transaction_set_input

    """filter the rows which have to be updated"""
    where: transaction_bool_exp!
  ): transaction_mutation_response

  """
  update data of the table: "validator"
  """
  update_validator(
    """sets the columns of the filtered rows to the given values"""
    _set: validator_set_input

    """filter the rows which have to be updated"""
    where: validator_bool_exp!
  ): validator_mutation_response

  """
  update single row of the table: "validator"
  """
  update_validator_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: validator_set_input
    pk_columns: validator_pk_columns_input!
  ): validator

  """
  update data of the table: "validator_commission"
  """
  update_validator_commission(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_commission_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_commission_set_input

    """filter the rows which have to be updated"""
    where: validator_commission_bool_exp!
  ): validator_commission_mutation_response

  """
  update single row of the table: "validator_commission"
  """
  update_validator_commission_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_commission_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_commission_set_input
    pk_columns: validator_commission_pk_columns_input!
  ): validator_commission

  """
  update data of the table: "validator_description"
  """
  update_validator_description(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_description_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_description_set_input

    """filter the rows which have to be updated"""
    where: validator_description_bool_exp!
  ): validator_description_mutation_response

  """
  update single row of the table: "validator_description"
  """
  update_validator_description_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_description_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_description_set_input
    pk_columns: validator_description_pk_columns_input!
  ): validator_description

  """
  update data of the table: "validator_info"
  """
  update_validator_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_info_set_input

    """filter the rows which have to be updated"""
    where: validator_info_bool_exp!
  ): validator_info_mutation_response

  """
  update single row of the table: "validator_info"
  """
  update_validator_info_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_info_set_input
    pk_columns: validator_info_pk_columns_input!
  ): validator_info

  """
  update data of the table: "validator_signing_info"
  """
  update_validator_signing_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_signing_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_signing_info_set_input

    """filter the rows which have to be updated"""
    where: validator_signing_info_bool_exp!
  ): validator_signing_info_mutation_response

  """
  update single row of the table: "validator_signing_info"
  """
  update_validator_signing_info_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_signing_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_signing_info_set_input
    pk_columns: validator_signing_info_pk_columns_input!
  ): validator_signing_info

  """
  update data of the table: "validator_status"
  """
  update_validator_status(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_status_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_status_set_input

    """filter the rows which have to be updated"""
    where: validator_status_bool_exp!
  ): validator_status_mutation_response

  """
  update single row of the table: "validator_status"
  """
  update_validator_status_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_status_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_status_set_input
    pk_columns: validator_status_pk_columns_input!
  ): validator_status

  """
  update data of the table: "validator_voting_power"
  """
  update_validator_voting_power(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_voting_power_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_voting_power_set_input

    """filter the rows which have to be updated"""
    where: validator_voting_power_bool_exp!
  ): validator_voting_power_mutation_response

  """
  update single row of the table: "validator_voting_power"
  """
  update_validator_voting_power_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: validator_voting_power_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: validator_voting_power_set_input
    pk_columns: validator_voting_power_pk_columns_input!
  ): validator_voting_power

  """
  update data of the table: "vesting_account"
  """
  update_vesting_account(
    """increments the numeric columns with given value of the filtered values"""
    _inc: vesting_account_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vesting_account_set_input

    """filter the rows which have to be updated"""
    where: vesting_account_bool_exp!
  ): vesting_account_mutation_response

  """
  update single row of the table: "vesting_account"
  """
  update_vesting_account_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: vesting_account_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vesting_account_set_input
    pk_columns: vesting_account_pk_columns_input!
  ): vesting_account

  """
  update data of the table: "vesting_period"
  """
  update_vesting_period(
    """increments the numeric columns with given value of the filtered values"""
    _inc: vesting_period_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vesting_period_set_input

    """filter the rows which have to be updated"""
    where: vesting_period_bool_exp!
  ): vesting_period_mutation_response
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "pre_commit"
"""
type pre_commit {
  height: bigint!
  proposer_priority: bigint!
  timestamp: timestamp!

  """An object relationship"""
  validator: validator!
  validator_address: String!
  voting_power: bigint!
}

"""
aggregated selection of "pre_commit"
"""
type pre_commit_aggregate {
  aggregate: pre_commit_aggregate_fields
  nodes: [pre_commit!]!
}

"""
aggregate fields of "pre_commit"
"""
type pre_commit_aggregate_fields {
  avg: pre_commit_avg_fields
  count(columns: [pre_commit_select_column!], distinct: Boolean): Int!
  max: pre_commit_max_fields
  min: pre_commit_min_fields
  stddev: pre_commit_stddev_fields
  stddev_pop: pre_commit_stddev_pop_fields
  stddev_samp: pre_commit_stddev_samp_fields
  sum: pre_commit_sum_fields
  var_pop: pre_commit_var_pop_fields
  var_samp: pre_commit_var_samp_fields
  variance: pre_commit_variance_fields
}

"""
order by aggregate values of table "pre_commit"
"""
input pre_commit_aggregate_order_by {
  avg: pre_commit_avg_order_by
  count: order_by
  max: pre_commit_max_order_by
  min: pre_commit_min_order_by
  stddev: pre_commit_stddev_order_by
  stddev_pop: pre_commit_stddev_pop_order_by
  stddev_samp: pre_commit_stddev_samp_order_by
  sum: pre_commit_sum_order_by
  var_pop: pre_commit_var_pop_order_by
  var_samp: pre_commit_var_samp_order_by
  variance: pre_commit_variance_order_by
}

"""
input type for inserting array relation for remote table "pre_commit"
"""
input pre_commit_arr_rel_insert_input {
  data: [pre_commit_insert_input!]!

  """on conflict condition"""
  on_conflict: pre_commit_on_conflict
}

"""aggregate avg on columns"""
type pre_commit_avg_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"""
order by avg() on columns of table "pre_commit"
"""
input pre_commit_avg_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"""
Boolean expression to filter rows from the table "pre_commit". All fields are combined with a logical 'AND'.
"""
input pre_commit_bool_exp {
  _and: [pre_commit_bool_exp!]
  _not: pre_commit_bool_exp
  _or: [pre_commit_bool_exp!]
  height: bigint_comparison_exp
  proposer_priority: bigint_comparison_exp
  timestamp: timestamp_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  voting_power: bigint_comparison_exp
}

"""
unique or primary key constraints on table "pre_commit"
"""
enum pre_commit_constraint {
  """unique or primary key constraint"""
  pre_commit_validator_address_timestamp_key
}

"""
input type for incrementing numeric columns in table "pre_commit"
"""
input pre_commit_inc_input {
  height: bigint
  proposer_priority: bigint
  voting_power: bigint
}

"""
input type for inserting data into table "pre_commit"
"""
input pre_commit_insert_input {
  height: bigint
  proposer_priority: bigint
  timestamp: timestamp
  validator: validator_obj_rel_insert_input
  validator_address: String
  voting_power: bigint
}

"""aggregate max on columns"""
type pre_commit_max_fields {
  height: bigint
  proposer_priority: bigint
  timestamp: timestamp
  validator_address: String
  voting_power: bigint
}

"""
order by max() on columns of table "pre_commit"
"""
input pre_commit_max_order_by {
  height: order_by
  proposer_priority: order_by
  timestamp: order_by
  validator_address: order_by
  voting_power: order_by
}

"""aggregate min on columns"""
type pre_commit_min_fields {
  height: bigint
  proposer_priority: bigint
  timestamp: timestamp
  validator_address: String
  voting_power: bigint
}

"""
order by min() on columns of table "pre_commit"
"""
input pre_commit_min_order_by {
  height: order_by
  proposer_priority: order_by
  timestamp: order_by
  validator_address: order_by
  voting_power: order_by
}

"""
response of any mutation on the table "pre_commit"
"""
type pre_commit_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pre_commit!]!
}

"""
on conflict condition type for table "pre_commit"
"""
input pre_commit_on_conflict {
  constraint: pre_commit_constraint!
  update_columns: [pre_commit_update_column!]! = []
  where: pre_commit_bool_exp
}

"""Ordering options when selecting data from "pre_commit"."""
input pre_commit_order_by {
  height: order_by
  proposer_priority: order_by
  timestamp: order_by
  validator: validator_order_by
  validator_address: order_by
  voting_power: order_by
}

"""
select columns of table "pre_commit"
"""
enum pre_commit_select_column {
  """column name"""
  height

  """column name"""
  proposer_priority

  """column name"""
  timestamp

  """column name"""
  validator_address

  """column name"""
  voting_power
}

"""
input type for updating data in table "pre_commit"
"""
input pre_commit_set_input {
  height: bigint
  proposer_priority: bigint
  timestamp: timestamp
  validator_address: String
  voting_power: bigint
}

"""aggregate stddev on columns"""
type pre_commit_stddev_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"""
order by stddev() on columns of table "pre_commit"
"""
input pre_commit_stddev_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"""aggregate stddev_pop on columns"""
type pre_commit_stddev_pop_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"""
order by stddev_pop() on columns of table "pre_commit"
"""
input pre_commit_stddev_pop_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"""aggregate stddev_samp on columns"""
type pre_commit_stddev_samp_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"""
order by stddev_samp() on columns of table "pre_commit"
"""
input pre_commit_stddev_samp_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"""aggregate sum on columns"""
type pre_commit_sum_fields {
  height: bigint
  proposer_priority: bigint
  voting_power: bigint
}

"""
order by sum() on columns of table "pre_commit"
"""
input pre_commit_sum_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"""
update columns of table "pre_commit"
"""
enum pre_commit_update_column {
  """column name"""
  height

  """column name"""
  proposer_priority

  """column name"""
  timestamp

  """column name"""
  validator_address

  """column name"""
  voting_power
}

"""aggregate var_pop on columns"""
type pre_commit_var_pop_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"""
order by var_pop() on columns of table "pre_commit"
"""
input pre_commit_var_pop_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"""aggregate var_samp on columns"""
type pre_commit_var_samp_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"""
order by var_samp() on columns of table "pre_commit"
"""
input pre_commit_var_samp_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"""aggregate variance on columns"""
type pre_commit_variance_fields {
  height: Float
  proposer_priority: Float
  voting_power: Float
}

"""
order by variance() on columns of table "pre_commit"
"""
input pre_commit_variance_order_by {
  height: order_by
  proposer_priority: order_by
  voting_power: order_by
}

"""
columns and relationships of "proposal"
"""
type proposal {
  content(
    """JSON select path"""
    path: String
  ): jsonb!
  deposit_end_time: timestamp
  description: String!
  id: Int!

  """An array relationship"""
  proposal_deposits(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): [proposal_deposit!]!

  """An aggregate relationship"""
  proposal_deposits_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): proposal_deposit_aggregate!
  proposal_route: String!

  """An object relationship"""
  proposal_tally_result: proposal_tally_result

  """An array relationship"""
  proposal_tally_results(
    """distinct select on columns"""
    distinct_on: [proposal_tally_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_tally_result_order_by!]

    """filter the rows returned"""
    where: proposal_tally_result_bool_exp
  ): [proposal_tally_result!]!

  """An aggregate relationship"""
  proposal_tally_results_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_tally_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_tally_result_order_by!]

    """filter the rows returned"""
    where: proposal_tally_result_bool_exp
  ): proposal_tally_result_aggregate!
  proposal_type: String!

  """An array relationship"""
  proposal_votes(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): [proposal_vote!]!

  """An aggregate relationship"""
  proposal_votes_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): proposal_vote_aggregate!

  """An object relationship"""
  proposer: account!
  proposer_address: String!

  """An object relationship"""
  staking_pool_snapshot: proposal_staking_pool_snapshot
  status: String
  submit_time: timestamp!
  title: String!

  """An array relationship"""
  validator_status_snapshots(
    """distinct select on columns"""
    distinct_on: [proposal_validator_status_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_validator_status_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_validator_status_snapshot_bool_exp
  ): [proposal_validator_status_snapshot!]!

  """An aggregate relationship"""
  validator_status_snapshots_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_validator_status_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_validator_status_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_validator_status_snapshot_bool_exp
  ): proposal_validator_status_snapshot_aggregate!
  voting_end_time: timestamp
  voting_start_time: timestamp
}

"""
aggregated selection of "proposal"
"""
type proposal_aggregate {
  aggregate: proposal_aggregate_fields
  nodes: [proposal!]!
}

"""
aggregate fields of "proposal"
"""
type proposal_aggregate_fields {
  avg: proposal_avg_fields
  count(columns: [proposal_select_column!], distinct: Boolean): Int!
  max: proposal_max_fields
  min: proposal_min_fields
  stddev: proposal_stddev_fields
  stddev_pop: proposal_stddev_pop_fields
  stddev_samp: proposal_stddev_samp_fields
  sum: proposal_sum_fields
  var_pop: proposal_var_pop_fields
  var_samp: proposal_var_samp_fields
  variance: proposal_variance_fields
}

"""
order by aggregate values of table "proposal"
"""
input proposal_aggregate_order_by {
  avg: proposal_avg_order_by
  count: order_by
  max: proposal_max_order_by
  min: proposal_min_order_by
  stddev: proposal_stddev_order_by
  stddev_pop: proposal_stddev_pop_order_by
  stddev_samp: proposal_stddev_samp_order_by
  sum: proposal_sum_order_by
  var_pop: proposal_var_pop_order_by
  var_samp: proposal_var_samp_order_by
  variance: proposal_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input proposal_append_input {
  content: jsonb
}

"""
input type for inserting array relation for remote table "proposal"
"""
input proposal_arr_rel_insert_input {
  data: [proposal_insert_input!]!

  """on conflict condition"""
  on_conflict: proposal_on_conflict
}

"""aggregate avg on columns"""
type proposal_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "proposal"
"""
input proposal_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "proposal". All fields are combined with a logical 'AND'.
"""
input proposal_bool_exp {
  _and: [proposal_bool_exp!]
  _not: proposal_bool_exp
  _or: [proposal_bool_exp!]
  content: jsonb_comparison_exp
  deposit_end_time: timestamp_comparison_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  proposal_deposits: proposal_deposit_bool_exp
  proposal_route: String_comparison_exp
  proposal_tally_result: proposal_tally_result_bool_exp
  proposal_tally_results: proposal_tally_result_bool_exp
  proposal_type: String_comparison_exp
  proposal_votes: proposal_vote_bool_exp
  proposer: account_bool_exp
  proposer_address: String_comparison_exp
  staking_pool_snapshot: proposal_staking_pool_snapshot_bool_exp
  status: String_comparison_exp
  submit_time: timestamp_comparison_exp
  title: String_comparison_exp
  validator_status_snapshots: proposal_validator_status_snapshot_bool_exp
  voting_end_time: timestamp_comparison_exp
  voting_start_time: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "proposal"
"""
enum proposal_constraint {
  """unique or primary key constraint"""
  proposal_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input proposal_delete_at_path_input {
  content: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input proposal_delete_elem_input {
  content: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input proposal_delete_key_input {
  content: String
}

"""
columns and relationships of "proposal_deposit"
"""
type proposal_deposit {
  amount: _coin

  """An object relationship"""
  block: block

  """An object relationship"""
  depositor: account
  depositor_address: String
  height: bigint!

  """An object relationship"""
  proposal: proposal!
  proposal_id: Int!
}

"""
aggregated selection of "proposal_deposit"
"""
type proposal_deposit_aggregate {
  aggregate: proposal_deposit_aggregate_fields
  nodes: [proposal_deposit!]!
}

"""
aggregate fields of "proposal_deposit"
"""
type proposal_deposit_aggregate_fields {
  avg: proposal_deposit_avg_fields
  count(columns: [proposal_deposit_select_column!], distinct: Boolean): Int!
  max: proposal_deposit_max_fields
  min: proposal_deposit_min_fields
  stddev: proposal_deposit_stddev_fields
  stddev_pop: proposal_deposit_stddev_pop_fields
  stddev_samp: proposal_deposit_stddev_samp_fields
  sum: proposal_deposit_sum_fields
  var_pop: proposal_deposit_var_pop_fields
  var_samp: proposal_deposit_var_samp_fields
  variance: proposal_deposit_variance_fields
}

"""
order by aggregate values of table "proposal_deposit"
"""
input proposal_deposit_aggregate_order_by {
  avg: proposal_deposit_avg_order_by
  count: order_by
  max: proposal_deposit_max_order_by
  min: proposal_deposit_min_order_by
  stddev: proposal_deposit_stddev_order_by
  stddev_pop: proposal_deposit_stddev_pop_order_by
  stddev_samp: proposal_deposit_stddev_samp_order_by
  sum: proposal_deposit_sum_order_by
  var_pop: proposal_deposit_var_pop_order_by
  var_samp: proposal_deposit_var_samp_order_by
  variance: proposal_deposit_variance_order_by
}

"""
input type for inserting array relation for remote table "proposal_deposit"
"""
input proposal_deposit_arr_rel_insert_input {
  data: [proposal_deposit_insert_input!]!

  """on conflict condition"""
  on_conflict: proposal_deposit_on_conflict
}

"""aggregate avg on columns"""
type proposal_deposit_avg_fields {
  height: Float
  proposal_id: Float
}

"""
order by avg() on columns of table "proposal_deposit"
"""
input proposal_deposit_avg_order_by {
  height: order_by
  proposal_id: order_by
}

"""
Boolean expression to filter rows from the table "proposal_deposit". All fields are combined with a logical 'AND'.
"""
input proposal_deposit_bool_exp {
  _and: [proposal_deposit_bool_exp!]
  _not: proposal_deposit_bool_exp
  _or: [proposal_deposit_bool_exp!]
  amount: _coin_comparison_exp
  block: block_bool_exp
  depositor: account_bool_exp
  depositor_address: String_comparison_exp
  height: bigint_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "proposal_deposit"
"""
enum proposal_deposit_constraint {
  """unique or primary key constraint"""
  unique_deposit
}

"""
input type for incrementing numeric columns in table "proposal_deposit"
"""
input proposal_deposit_inc_input {
  height: bigint
  proposal_id: Int
}

"""
input type for inserting data into table "proposal_deposit"
"""
input proposal_deposit_insert_input {
  amount: _coin
  block: block_obj_rel_insert_input
  depositor: account_obj_rel_insert_input
  depositor_address: String
  height: bigint
  proposal: proposal_obj_rel_insert_input
  proposal_id: Int
}

"""aggregate max on columns"""
type proposal_deposit_max_fields {
  depositor_address: String
  height: bigint
  proposal_id: Int
}

"""
order by max() on columns of table "proposal_deposit"
"""
input proposal_deposit_max_order_by {
  depositor_address: order_by
  height: order_by
  proposal_id: order_by
}

"""aggregate min on columns"""
type proposal_deposit_min_fields {
  depositor_address: String
  height: bigint
  proposal_id: Int
}

"""
order by min() on columns of table "proposal_deposit"
"""
input proposal_deposit_min_order_by {
  depositor_address: order_by
  height: order_by
  proposal_id: order_by
}

"""
response of any mutation on the table "proposal_deposit"
"""
type proposal_deposit_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [proposal_deposit!]!
}

"""
on conflict condition type for table "proposal_deposit"
"""
input proposal_deposit_on_conflict {
  constraint: proposal_deposit_constraint!
  update_columns: [proposal_deposit_update_column!]! = []
  where: proposal_deposit_bool_exp
}

"""Ordering options when selecting data from "proposal_deposit"."""
input proposal_deposit_order_by {
  amount: order_by
  block: block_order_by
  depositor: account_order_by
  depositor_address: order_by
  height: order_by
  proposal: proposal_order_by
  proposal_id: order_by
}

"""
select columns of table "proposal_deposit"
"""
enum proposal_deposit_select_column {
  """column name"""
  amount

  """column name"""
  depositor_address

  """column name"""
  height

  """column name"""
  proposal_id
}

"""
input type for updating data in table "proposal_deposit"
"""
input proposal_deposit_set_input {
  amount: _coin
  depositor_address: String
  height: bigint
  proposal_id: Int
}

"""aggregate stddev on columns"""
type proposal_deposit_stddev_fields {
  height: Float
  proposal_id: Float
}

"""
order by stddev() on columns of table "proposal_deposit"
"""
input proposal_deposit_stddev_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate stddev_pop on columns"""
type proposal_deposit_stddev_pop_fields {
  height: Float
  proposal_id: Float
}

"""
order by stddev_pop() on columns of table "proposal_deposit"
"""
input proposal_deposit_stddev_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate stddev_samp on columns"""
type proposal_deposit_stddev_samp_fields {
  height: Float
  proposal_id: Float
}

"""
order by stddev_samp() on columns of table "proposal_deposit"
"""
input proposal_deposit_stddev_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate sum on columns"""
type proposal_deposit_sum_fields {
  height: bigint
  proposal_id: Int
}

"""
order by sum() on columns of table "proposal_deposit"
"""
input proposal_deposit_sum_order_by {
  height: order_by
  proposal_id: order_by
}

"""
update columns of table "proposal_deposit"
"""
enum proposal_deposit_update_column {
  """column name"""
  amount

  """column name"""
  depositor_address

  """column name"""
  height

  """column name"""
  proposal_id
}

"""aggregate var_pop on columns"""
type proposal_deposit_var_pop_fields {
  height: Float
  proposal_id: Float
}

"""
order by var_pop() on columns of table "proposal_deposit"
"""
input proposal_deposit_var_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate var_samp on columns"""
type proposal_deposit_var_samp_fields {
  height: Float
  proposal_id: Float
}

"""
order by var_samp() on columns of table "proposal_deposit"
"""
input proposal_deposit_var_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate variance on columns"""
type proposal_deposit_variance_fields {
  height: Float
  proposal_id: Float
}

"""
order by variance() on columns of table "proposal_deposit"
"""
input proposal_deposit_variance_order_by {
  height: order_by
  proposal_id: order_by
}

"""
input type for incrementing numeric columns in table "proposal"
"""
input proposal_inc_input {
  id: Int
}

"""
input type for inserting data into table "proposal"
"""
input proposal_insert_input {
  content: jsonb
  deposit_end_time: timestamp
  description: String
  id: Int
  proposal_deposits: proposal_deposit_arr_rel_insert_input
  proposal_route: String
  proposal_tally_result: proposal_tally_result_obj_rel_insert_input
  proposal_tally_results: proposal_tally_result_arr_rel_insert_input
  proposal_type: String
  proposal_votes: proposal_vote_arr_rel_insert_input
  proposer: account_obj_rel_insert_input
  proposer_address: String
  staking_pool_snapshot: proposal_staking_pool_snapshot_obj_rel_insert_input
  status: String
  submit_time: timestamp
  title: String
  validator_status_snapshots: proposal_validator_status_snapshot_arr_rel_insert_input
  voting_end_time: timestamp
  voting_start_time: timestamp
}

"""aggregate max on columns"""
type proposal_max_fields {
  deposit_end_time: timestamp
  description: String
  id: Int
  proposal_route: String
  proposal_type: String
  proposer_address: String
  status: String
  submit_time: timestamp
  title: String
  voting_end_time: timestamp
  voting_start_time: timestamp
}

"""
order by max() on columns of table "proposal"
"""
input proposal_max_order_by {
  deposit_end_time: order_by
  description: order_by
  id: order_by
  proposal_route: order_by
  proposal_type: order_by
  proposer_address: order_by
  status: order_by
  submit_time: order_by
  title: order_by
  voting_end_time: order_by
  voting_start_time: order_by
}

"""aggregate min on columns"""
type proposal_min_fields {
  deposit_end_time: timestamp
  description: String
  id: Int
  proposal_route: String
  proposal_type: String
  proposer_address: String
  status: String
  submit_time: timestamp
  title: String
  voting_end_time: timestamp
  voting_start_time: timestamp
}

"""
order by min() on columns of table "proposal"
"""
input proposal_min_order_by {
  deposit_end_time: order_by
  description: order_by
  id: order_by
  proposal_route: order_by
  proposal_type: order_by
  proposer_address: order_by
  status: order_by
  submit_time: order_by
  title: order_by
  voting_end_time: order_by
  voting_start_time: order_by
}

"""
response of any mutation on the table "proposal"
"""
type proposal_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [proposal!]!
}

"""
input type for inserting object relation for remote table "proposal"
"""
input proposal_obj_rel_insert_input {
  data: proposal_insert_input!

  """on conflict condition"""
  on_conflict: proposal_on_conflict
}

"""
on conflict condition type for table "proposal"
"""
input proposal_on_conflict {
  constraint: proposal_constraint!
  update_columns: [proposal_update_column!]! = []
  where: proposal_bool_exp
}

"""Ordering options when selecting data from "proposal"."""
input proposal_order_by {
  content: order_by
  deposit_end_time: order_by
  description: order_by
  id: order_by
  proposal_deposits_aggregate: proposal_deposit_aggregate_order_by
  proposal_route: order_by
  proposal_tally_result: proposal_tally_result_order_by
  proposal_tally_results_aggregate: proposal_tally_result_aggregate_order_by
  proposal_type: order_by
  proposal_votes_aggregate: proposal_vote_aggregate_order_by
  proposer: account_order_by
  proposer_address: order_by
  staking_pool_snapshot: proposal_staking_pool_snapshot_order_by
  status: order_by
  submit_time: order_by
  title: order_by
  validator_status_snapshots_aggregate: proposal_validator_status_snapshot_aggregate_order_by
  voting_end_time: order_by
  voting_start_time: order_by
}

"""primary key columns input for table: proposal"""
input proposal_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input proposal_prepend_input {
  content: jsonb
}

"""
select columns of table "proposal"
"""
enum proposal_select_column {
  """column name"""
  content

  """column name"""
  deposit_end_time

  """column name"""
  description

  """column name"""
  id

  """column name"""
  proposal_route

  """column name"""
  proposal_type

  """column name"""
  proposer_address

  """column name"""
  status

  """column name"""
  submit_time

  """column name"""
  title

  """column name"""
  voting_end_time

  """column name"""
  voting_start_time
}

"""
input type for updating data in table "proposal"
"""
input proposal_set_input {
  content: jsonb
  deposit_end_time: timestamp
  description: String
  id: Int
  proposal_route: String
  proposal_type: String
  proposer_address: String
  status: String
  submit_time: timestamp
  title: String
  voting_end_time: timestamp
  voting_start_time: timestamp
}

"""
columns and relationships of "proposal_staking_pool_snapshot"
"""
type proposal_staking_pool_snapshot {
  bonded_tokens: String!
  height: bigint!
  not_bonded_tokens: String!

  """An object relationship"""
  proposal: proposal!
  proposal_id: Int!
}

"""
aggregated selection of "proposal_staking_pool_snapshot"
"""
type proposal_staking_pool_snapshot_aggregate {
  aggregate: proposal_staking_pool_snapshot_aggregate_fields
  nodes: [proposal_staking_pool_snapshot!]!
}

"""
aggregate fields of "proposal_staking_pool_snapshot"
"""
type proposal_staking_pool_snapshot_aggregate_fields {
  avg: proposal_staking_pool_snapshot_avg_fields
  count(columns: [proposal_staking_pool_snapshot_select_column!], distinct: Boolean): Int!
  max: proposal_staking_pool_snapshot_max_fields
  min: proposal_staking_pool_snapshot_min_fields
  stddev: proposal_staking_pool_snapshot_stddev_fields
  stddev_pop: proposal_staking_pool_snapshot_stddev_pop_fields
  stddev_samp: proposal_staking_pool_snapshot_stddev_samp_fields
  sum: proposal_staking_pool_snapshot_sum_fields
  var_pop: proposal_staking_pool_snapshot_var_pop_fields
  var_samp: proposal_staking_pool_snapshot_var_samp_fields
  variance: proposal_staking_pool_snapshot_variance_fields
}

"""aggregate avg on columns"""
type proposal_staking_pool_snapshot_avg_fields {
  height: Float
  proposal_id: Float
}

"""
Boolean expression to filter rows from the table "proposal_staking_pool_snapshot". All fields are combined with a logical 'AND'.
"""
input proposal_staking_pool_snapshot_bool_exp {
  _and: [proposal_staking_pool_snapshot_bool_exp!]
  _not: proposal_staking_pool_snapshot_bool_exp
  _or: [proposal_staking_pool_snapshot_bool_exp!]
  bonded_tokens: String_comparison_exp
  height: bigint_comparison_exp
  not_bonded_tokens: String_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "proposal_staking_pool_snapshot"
"""
enum proposal_staking_pool_snapshot_constraint {
  """unique or primary key constraint"""
  unique_staking_pool_snapshot
}

"""
input type for incrementing numeric columns in table "proposal_staking_pool_snapshot"
"""
input proposal_staking_pool_snapshot_inc_input {
  height: bigint
  proposal_id: Int
}

"""
input type for inserting data into table "proposal_staking_pool_snapshot"
"""
input proposal_staking_pool_snapshot_insert_input {
  bonded_tokens: String
  height: bigint
  not_bonded_tokens: String
  proposal: proposal_obj_rel_insert_input
  proposal_id: Int
}

"""aggregate max on columns"""
type proposal_staking_pool_snapshot_max_fields {
  bonded_tokens: String
  height: bigint
  not_bonded_tokens: String
  proposal_id: Int
}

"""aggregate min on columns"""
type proposal_staking_pool_snapshot_min_fields {
  bonded_tokens: String
  height: bigint
  not_bonded_tokens: String
  proposal_id: Int
}

"""
response of any mutation on the table "proposal_staking_pool_snapshot"
"""
type proposal_staking_pool_snapshot_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [proposal_staking_pool_snapshot!]!
}

"""
input type for inserting object relation for remote table "proposal_staking_pool_snapshot"
"""
input proposal_staking_pool_snapshot_obj_rel_insert_input {
  data: proposal_staking_pool_snapshot_insert_input!

  """on conflict condition"""
  on_conflict: proposal_staking_pool_snapshot_on_conflict
}

"""
on conflict condition type for table "proposal_staking_pool_snapshot"
"""
input proposal_staking_pool_snapshot_on_conflict {
  constraint: proposal_staking_pool_snapshot_constraint!
  update_columns: [proposal_staking_pool_snapshot_update_column!]! = []
  where: proposal_staking_pool_snapshot_bool_exp
}

"""
Ordering options when selecting data from "proposal_staking_pool_snapshot".
"""
input proposal_staking_pool_snapshot_order_by {
  bonded_tokens: order_by
  height: order_by
  not_bonded_tokens: order_by
  proposal: proposal_order_by
  proposal_id: order_by
}

"""primary key columns input for table: proposal_staking_pool_snapshot"""
input proposal_staking_pool_snapshot_pk_columns_input {
  proposal_id: Int!
}

"""
select columns of table "proposal_staking_pool_snapshot"
"""
enum proposal_staking_pool_snapshot_select_column {
  """column name"""
  bonded_tokens

  """column name"""
  height

  """column name"""
  not_bonded_tokens

  """column name"""
  proposal_id
}

"""
input type for updating data in table "proposal_staking_pool_snapshot"
"""
input proposal_staking_pool_snapshot_set_input {
  bonded_tokens: String
  height: bigint
  not_bonded_tokens: String
  proposal_id: Int
}

"""aggregate stddev on columns"""
type proposal_staking_pool_snapshot_stddev_fields {
  height: Float
  proposal_id: Float
}

"""aggregate stddev_pop on columns"""
type proposal_staking_pool_snapshot_stddev_pop_fields {
  height: Float
  proposal_id: Float
}

"""aggregate stddev_samp on columns"""
type proposal_staking_pool_snapshot_stddev_samp_fields {
  height: Float
  proposal_id: Float
}

"""aggregate sum on columns"""
type proposal_staking_pool_snapshot_sum_fields {
  height: bigint
  proposal_id: Int
}

"""
update columns of table "proposal_staking_pool_snapshot"
"""
enum proposal_staking_pool_snapshot_update_column {
  """column name"""
  bonded_tokens

  """column name"""
  height

  """column name"""
  not_bonded_tokens

  """column name"""
  proposal_id
}

"""aggregate var_pop on columns"""
type proposal_staking_pool_snapshot_var_pop_fields {
  height: Float
  proposal_id: Float
}

"""aggregate var_samp on columns"""
type proposal_staking_pool_snapshot_var_samp_fields {
  height: Float
  proposal_id: Float
}

"""aggregate variance on columns"""
type proposal_staking_pool_snapshot_variance_fields {
  height: Float
  proposal_id: Float
}

"""aggregate stddev on columns"""
type proposal_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "proposal"
"""
input proposal_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type proposal_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "proposal"
"""
input proposal_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type proposal_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "proposal"
"""
input proposal_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type proposal_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "proposal"
"""
input proposal_sum_order_by {
  id: order_by
}

"""
columns and relationships of "proposal_tally_result"
"""
type proposal_tally_result {
  abstain: String!
  height: bigint!
  no: String!
  no_with_veto: String!

  """An object relationship"""
  proposal: proposal!
  proposal_id: Int!
  yes: String!
}

"""
aggregated selection of "proposal_tally_result"
"""
type proposal_tally_result_aggregate {
  aggregate: proposal_tally_result_aggregate_fields
  nodes: [proposal_tally_result!]!
}

"""
aggregate fields of "proposal_tally_result"
"""
type proposal_tally_result_aggregate_fields {
  avg: proposal_tally_result_avg_fields
  count(columns: [proposal_tally_result_select_column!], distinct: Boolean): Int!
  max: proposal_tally_result_max_fields
  min: proposal_tally_result_min_fields
  stddev: proposal_tally_result_stddev_fields
  stddev_pop: proposal_tally_result_stddev_pop_fields
  stddev_samp: proposal_tally_result_stddev_samp_fields
  sum: proposal_tally_result_sum_fields
  var_pop: proposal_tally_result_var_pop_fields
  var_samp: proposal_tally_result_var_samp_fields
  variance: proposal_tally_result_variance_fields
}

"""
order by aggregate values of table "proposal_tally_result"
"""
input proposal_tally_result_aggregate_order_by {
  avg: proposal_tally_result_avg_order_by
  count: order_by
  max: proposal_tally_result_max_order_by
  min: proposal_tally_result_min_order_by
  stddev: proposal_tally_result_stddev_order_by
  stddev_pop: proposal_tally_result_stddev_pop_order_by
  stddev_samp: proposal_tally_result_stddev_samp_order_by
  sum: proposal_tally_result_sum_order_by
  var_pop: proposal_tally_result_var_pop_order_by
  var_samp: proposal_tally_result_var_samp_order_by
  variance: proposal_tally_result_variance_order_by
}

"""
input type for inserting array relation for remote table "proposal_tally_result"
"""
input proposal_tally_result_arr_rel_insert_input {
  data: [proposal_tally_result_insert_input!]!

  """on conflict condition"""
  on_conflict: proposal_tally_result_on_conflict
}

"""aggregate avg on columns"""
type proposal_tally_result_avg_fields {
  height: Float
  proposal_id: Float
}

"""
order by avg() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_avg_order_by {
  height: order_by
  proposal_id: order_by
}

"""
Boolean expression to filter rows from the table "proposal_tally_result". All fields are combined with a logical 'AND'.
"""
input proposal_tally_result_bool_exp {
  _and: [proposal_tally_result_bool_exp!]
  _not: proposal_tally_result_bool_exp
  _or: [proposal_tally_result_bool_exp!]
  abstain: String_comparison_exp
  height: bigint_comparison_exp
  no: String_comparison_exp
  no_with_veto: String_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
  yes: String_comparison_exp
}

"""
unique or primary key constraints on table "proposal_tally_result"
"""
enum proposal_tally_result_constraint {
  """unique or primary key constraint"""
  unique_tally_result
}

"""
input type for incrementing numeric columns in table "proposal_tally_result"
"""
input proposal_tally_result_inc_input {
  height: bigint
  proposal_id: Int
}

"""
input type for inserting data into table "proposal_tally_result"
"""
input proposal_tally_result_insert_input {
  abstain: String
  height: bigint
  no: String
  no_with_veto: String
  proposal: proposal_obj_rel_insert_input
  proposal_id: Int
  yes: String
}

"""aggregate max on columns"""
type proposal_tally_result_max_fields {
  abstain: String
  height: bigint
  no: String
  no_with_veto: String
  proposal_id: Int
  yes: String
}

"""
order by max() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_max_order_by {
  abstain: order_by
  height: order_by
  no: order_by
  no_with_veto: order_by
  proposal_id: order_by
  yes: order_by
}

"""aggregate min on columns"""
type proposal_tally_result_min_fields {
  abstain: String
  height: bigint
  no: String
  no_with_veto: String
  proposal_id: Int
  yes: String
}

"""
order by min() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_min_order_by {
  abstain: order_by
  height: order_by
  no: order_by
  no_with_veto: order_by
  proposal_id: order_by
  yes: order_by
}

"""
response of any mutation on the table "proposal_tally_result"
"""
type proposal_tally_result_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [proposal_tally_result!]!
}

"""
input type for inserting object relation for remote table "proposal_tally_result"
"""
input proposal_tally_result_obj_rel_insert_input {
  data: proposal_tally_result_insert_input!

  """on conflict condition"""
  on_conflict: proposal_tally_result_on_conflict
}

"""
on conflict condition type for table "proposal_tally_result"
"""
input proposal_tally_result_on_conflict {
  constraint: proposal_tally_result_constraint!
  update_columns: [proposal_tally_result_update_column!]! = []
  where: proposal_tally_result_bool_exp
}

"""Ordering options when selecting data from "proposal_tally_result"."""
input proposal_tally_result_order_by {
  abstain: order_by
  height: order_by
  no: order_by
  no_with_veto: order_by
  proposal: proposal_order_by
  proposal_id: order_by
  yes: order_by
}

"""primary key columns input for table: proposal_tally_result"""
input proposal_tally_result_pk_columns_input {
  proposal_id: Int!
}

"""
select columns of table "proposal_tally_result"
"""
enum proposal_tally_result_select_column {
  """column name"""
  abstain

  """column name"""
  height

  """column name"""
  no

  """column name"""
  no_with_veto

  """column name"""
  proposal_id

  """column name"""
  yes
}

"""
input type for updating data in table "proposal_tally_result"
"""
input proposal_tally_result_set_input {
  abstain: String
  height: bigint
  no: String
  no_with_veto: String
  proposal_id: Int
  yes: String
}

"""aggregate stddev on columns"""
type proposal_tally_result_stddev_fields {
  height: Float
  proposal_id: Float
}

"""
order by stddev() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_stddev_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate stddev_pop on columns"""
type proposal_tally_result_stddev_pop_fields {
  height: Float
  proposal_id: Float
}

"""
order by stddev_pop() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_stddev_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate stddev_samp on columns"""
type proposal_tally_result_stddev_samp_fields {
  height: Float
  proposal_id: Float
}

"""
order by stddev_samp() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_stddev_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate sum on columns"""
type proposal_tally_result_sum_fields {
  height: bigint
  proposal_id: Int
}

"""
order by sum() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_sum_order_by {
  height: order_by
  proposal_id: order_by
}

"""
update columns of table "proposal_tally_result"
"""
enum proposal_tally_result_update_column {
  """column name"""
  abstain

  """column name"""
  height

  """column name"""
  no

  """column name"""
  no_with_veto

  """column name"""
  proposal_id

  """column name"""
  yes
}

"""aggregate var_pop on columns"""
type proposal_tally_result_var_pop_fields {
  height: Float
  proposal_id: Float
}

"""
order by var_pop() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_var_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate var_samp on columns"""
type proposal_tally_result_var_samp_fields {
  height: Float
  proposal_id: Float
}

"""
order by var_samp() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_var_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate variance on columns"""
type proposal_tally_result_variance_fields {
  height: Float
  proposal_id: Float
}

"""
order by variance() on columns of table "proposal_tally_result"
"""
input proposal_tally_result_variance_order_by {
  height: order_by
  proposal_id: order_by
}

"""
update columns of table "proposal"
"""
enum proposal_update_column {
  """column name"""
  content

  """column name"""
  deposit_end_time

  """column name"""
  description

  """column name"""
  id

  """column name"""
  proposal_route

  """column name"""
  proposal_type

  """column name"""
  proposer_address

  """column name"""
  status

  """column name"""
  submit_time

  """column name"""
  title

  """column name"""
  voting_end_time

  """column name"""
  voting_start_time
}

"""
columns and relationships of "proposal_validator_status_snapshot"
"""
type proposal_validator_status_snapshot {
  height: bigint!
  id: Int!
  jailed: Boolean!

  """An object relationship"""
  proposal: proposal
  proposal_id: Int
  status: Int!

  """An object relationship"""
  validator: validator!
  validator_address: String!
  voting_power: bigint!
}

"""
aggregated selection of "proposal_validator_status_snapshot"
"""
type proposal_validator_status_snapshot_aggregate {
  aggregate: proposal_validator_status_snapshot_aggregate_fields
  nodes: [proposal_validator_status_snapshot!]!
}

"""
aggregate fields of "proposal_validator_status_snapshot"
"""
type proposal_validator_status_snapshot_aggregate_fields {
  avg: proposal_validator_status_snapshot_avg_fields
  count(columns: [proposal_validator_status_snapshot_select_column!], distinct: Boolean): Int!
  max: proposal_validator_status_snapshot_max_fields
  min: proposal_validator_status_snapshot_min_fields
  stddev: proposal_validator_status_snapshot_stddev_fields
  stddev_pop: proposal_validator_status_snapshot_stddev_pop_fields
  stddev_samp: proposal_validator_status_snapshot_stddev_samp_fields
  sum: proposal_validator_status_snapshot_sum_fields
  var_pop: proposal_validator_status_snapshot_var_pop_fields
  var_samp: proposal_validator_status_snapshot_var_samp_fields
  variance: proposal_validator_status_snapshot_variance_fields
}

"""
order by aggregate values of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_aggregate_order_by {
  avg: proposal_validator_status_snapshot_avg_order_by
  count: order_by
  max: proposal_validator_status_snapshot_max_order_by
  min: proposal_validator_status_snapshot_min_order_by
  stddev: proposal_validator_status_snapshot_stddev_order_by
  stddev_pop: proposal_validator_status_snapshot_stddev_pop_order_by
  stddev_samp: proposal_validator_status_snapshot_stddev_samp_order_by
  sum: proposal_validator_status_snapshot_sum_order_by
  var_pop: proposal_validator_status_snapshot_var_pop_order_by
  var_samp: proposal_validator_status_snapshot_var_samp_order_by
  variance: proposal_validator_status_snapshot_variance_order_by
}

"""
input type for inserting array relation for remote table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_arr_rel_insert_input {
  data: [proposal_validator_status_snapshot_insert_input!]!

  """on conflict condition"""
  on_conflict: proposal_validator_status_snapshot_on_conflict
}

"""aggregate avg on columns"""
type proposal_validator_status_snapshot_avg_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"""
order by avg() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_avg_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"""
Boolean expression to filter rows from the table "proposal_validator_status_snapshot". All fields are combined with a logical 'AND'.
"""
input proposal_validator_status_snapshot_bool_exp {
  _and: [proposal_validator_status_snapshot_bool_exp!]
  _not: proposal_validator_status_snapshot_bool_exp
  _or: [proposal_validator_status_snapshot_bool_exp!]
  height: bigint_comparison_exp
  id: Int_comparison_exp
  jailed: Boolean_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
  status: Int_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  voting_power: bigint_comparison_exp
}

"""
unique or primary key constraints on table "proposal_validator_status_snapshot"
"""
enum proposal_validator_status_snapshot_constraint {
  """unique or primary key constraint"""
  proposal_validator_status_snapshot_pkey

  """unique or primary key constraint"""
  unique_validator_status_snapshot
}

"""
input type for incrementing numeric columns in table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_inc_input {
  height: bigint
  id: Int
  proposal_id: Int
  status: Int
  voting_power: bigint
}

"""
input type for inserting data into table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_insert_input {
  height: bigint
  id: Int
  jailed: Boolean
  proposal: proposal_obj_rel_insert_input
  proposal_id: Int
  status: Int
  validator: validator_obj_rel_insert_input
  validator_address: String
  voting_power: bigint
}

"""aggregate max on columns"""
type proposal_validator_status_snapshot_max_fields {
  height: bigint
  id: Int
  proposal_id: Int
  status: Int
  validator_address: String
  voting_power: bigint
}

"""
order by max() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_max_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  validator_address: order_by
  voting_power: order_by
}

"""aggregate min on columns"""
type proposal_validator_status_snapshot_min_fields {
  height: bigint
  id: Int
  proposal_id: Int
  status: Int
  validator_address: String
  voting_power: bigint
}

"""
order by min() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_min_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  validator_address: order_by
  voting_power: order_by
}

"""
response of any mutation on the table "proposal_validator_status_snapshot"
"""
type proposal_validator_status_snapshot_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [proposal_validator_status_snapshot!]!
}

"""
input type for inserting object relation for remote table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_obj_rel_insert_input {
  data: proposal_validator_status_snapshot_insert_input!

  """on conflict condition"""
  on_conflict: proposal_validator_status_snapshot_on_conflict
}

"""
on conflict condition type for table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_on_conflict {
  constraint: proposal_validator_status_snapshot_constraint!
  update_columns: [proposal_validator_status_snapshot_update_column!]! = []
  where: proposal_validator_status_snapshot_bool_exp
}

"""
Ordering options when selecting data from "proposal_validator_status_snapshot".
"""
input proposal_validator_status_snapshot_order_by {
  height: order_by
  id: order_by
  jailed: order_by
  proposal: proposal_order_by
  proposal_id: order_by
  status: order_by
  validator: validator_order_by
  validator_address: order_by
  voting_power: order_by
}

"""
primary key columns input for table: proposal_validator_status_snapshot
"""
input proposal_validator_status_snapshot_pk_columns_input {
  id: Int!
}

"""
select columns of table "proposal_validator_status_snapshot"
"""
enum proposal_validator_status_snapshot_select_column {
  """column name"""
  height

  """column name"""
  id

  """column name"""
  jailed

  """column name"""
  proposal_id

  """column name"""
  status

  """column name"""
  validator_address

  """column name"""
  voting_power
}

"""
input type for updating data in table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_set_input {
  height: bigint
  id: Int
  jailed: Boolean
  proposal_id: Int
  status: Int
  validator_address: String
  voting_power: bigint
}

"""aggregate stddev on columns"""
type proposal_validator_status_snapshot_stddev_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"""
order by stddev() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_stddev_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"""aggregate stddev_pop on columns"""
type proposal_validator_status_snapshot_stddev_pop_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"""
order by stddev_pop() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_stddev_pop_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"""aggregate stddev_samp on columns"""
type proposal_validator_status_snapshot_stddev_samp_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"""
order by stddev_samp() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_stddev_samp_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"""aggregate sum on columns"""
type proposal_validator_status_snapshot_sum_fields {
  height: bigint
  id: Int
  proposal_id: Int
  status: Int
  voting_power: bigint
}

"""
order by sum() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_sum_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"""
update columns of table "proposal_validator_status_snapshot"
"""
enum proposal_validator_status_snapshot_update_column {
  """column name"""
  height

  """column name"""
  id

  """column name"""
  jailed

  """column name"""
  proposal_id

  """column name"""
  status

  """column name"""
  validator_address

  """column name"""
  voting_power
}

"""aggregate var_pop on columns"""
type proposal_validator_status_snapshot_var_pop_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"""
order by var_pop() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_var_pop_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"""aggregate var_samp on columns"""
type proposal_validator_status_snapshot_var_samp_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"""
order by var_samp() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_var_samp_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"""aggregate variance on columns"""
type proposal_validator_status_snapshot_variance_fields {
  height: Float
  id: Float
  proposal_id: Float
  status: Float
  voting_power: Float
}

"""
order by variance() on columns of table "proposal_validator_status_snapshot"
"""
input proposal_validator_status_snapshot_variance_order_by {
  height: order_by
  id: order_by
  proposal_id: order_by
  status: order_by
  voting_power: order_by
}

"""aggregate var_pop on columns"""
type proposal_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "proposal"
"""
input proposal_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type proposal_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "proposal"
"""
input proposal_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type proposal_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "proposal"
"""
input proposal_variance_order_by {
  id: order_by
}

"""
columns and relationships of "proposal_vote"
"""
type proposal_vote {
  """An object relationship"""
  account: account!

  """An object relationship"""
  block: block!
  height: bigint!
  option: String!

  """An object relationship"""
  proposal: proposal!
  proposal_id: Int!
  voter_address: String!
}

"""
aggregated selection of "proposal_vote"
"""
type proposal_vote_aggregate {
  aggregate: proposal_vote_aggregate_fields
  nodes: [proposal_vote!]!
}

"""
aggregate fields of "proposal_vote"
"""
type proposal_vote_aggregate_fields {
  avg: proposal_vote_avg_fields
  count(columns: [proposal_vote_select_column!], distinct: Boolean): Int!
  max: proposal_vote_max_fields
  min: proposal_vote_min_fields
  stddev: proposal_vote_stddev_fields
  stddev_pop: proposal_vote_stddev_pop_fields
  stddev_samp: proposal_vote_stddev_samp_fields
  sum: proposal_vote_sum_fields
  var_pop: proposal_vote_var_pop_fields
  var_samp: proposal_vote_var_samp_fields
  variance: proposal_vote_variance_fields
}

"""
order by aggregate values of table "proposal_vote"
"""
input proposal_vote_aggregate_order_by {
  avg: proposal_vote_avg_order_by
  count: order_by
  max: proposal_vote_max_order_by
  min: proposal_vote_min_order_by
  stddev: proposal_vote_stddev_order_by
  stddev_pop: proposal_vote_stddev_pop_order_by
  stddev_samp: proposal_vote_stddev_samp_order_by
  sum: proposal_vote_sum_order_by
  var_pop: proposal_vote_var_pop_order_by
  var_samp: proposal_vote_var_samp_order_by
  variance: proposal_vote_variance_order_by
}

"""
input type for inserting array relation for remote table "proposal_vote"
"""
input proposal_vote_arr_rel_insert_input {
  data: [proposal_vote_insert_input!]!

  """on conflict condition"""
  on_conflict: proposal_vote_on_conflict
}

"""aggregate avg on columns"""
type proposal_vote_avg_fields {
  height: Float
  proposal_id: Float
}

"""
order by avg() on columns of table "proposal_vote"
"""
input proposal_vote_avg_order_by {
  height: order_by
  proposal_id: order_by
}

"""
Boolean expression to filter rows from the table "proposal_vote". All fields are combined with a logical 'AND'.
"""
input proposal_vote_bool_exp {
  _and: [proposal_vote_bool_exp!]
  _not: proposal_vote_bool_exp
  _or: [proposal_vote_bool_exp!]
  account: account_bool_exp
  block: block_bool_exp
  height: bigint_comparison_exp
  option: String_comparison_exp
  proposal: proposal_bool_exp
  proposal_id: Int_comparison_exp
  voter_address: String_comparison_exp
}

"""
unique or primary key constraints on table "proposal_vote"
"""
enum proposal_vote_constraint {
  """unique or primary key constraint"""
  unique_vote
}

"""
input type for incrementing numeric columns in table "proposal_vote"
"""
input proposal_vote_inc_input {
  height: bigint
  proposal_id: Int
}

"""
input type for inserting data into table "proposal_vote"
"""
input proposal_vote_insert_input {
  account: account_obj_rel_insert_input
  block: block_obj_rel_insert_input
  height: bigint
  option: String
  proposal: proposal_obj_rel_insert_input
  proposal_id: Int
  voter_address: String
}

"""aggregate max on columns"""
type proposal_vote_max_fields {
  height: bigint
  option: String
  proposal_id: Int
  voter_address: String
}

"""
order by max() on columns of table "proposal_vote"
"""
input proposal_vote_max_order_by {
  height: order_by
  option: order_by
  proposal_id: order_by
  voter_address: order_by
}

"""aggregate min on columns"""
type proposal_vote_min_fields {
  height: bigint
  option: String
  proposal_id: Int
  voter_address: String
}

"""
order by min() on columns of table "proposal_vote"
"""
input proposal_vote_min_order_by {
  height: order_by
  option: order_by
  proposal_id: order_by
  voter_address: order_by
}

"""
response of any mutation on the table "proposal_vote"
"""
type proposal_vote_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [proposal_vote!]!
}

"""
on conflict condition type for table "proposal_vote"
"""
input proposal_vote_on_conflict {
  constraint: proposal_vote_constraint!
  update_columns: [proposal_vote_update_column!]! = []
  where: proposal_vote_bool_exp
}

"""Ordering options when selecting data from "proposal_vote"."""
input proposal_vote_order_by {
  account: account_order_by
  block: block_order_by
  height: order_by
  option: order_by
  proposal: proposal_order_by
  proposal_id: order_by
  voter_address: order_by
}

"""
select columns of table "proposal_vote"
"""
enum proposal_vote_select_column {
  """column name"""
  height

  """column name"""
  option

  """column name"""
  proposal_id

  """column name"""
  voter_address
}

"""
input type for updating data in table "proposal_vote"
"""
input proposal_vote_set_input {
  height: bigint
  option: String
  proposal_id: Int
  voter_address: String
}

"""aggregate stddev on columns"""
type proposal_vote_stddev_fields {
  height: Float
  proposal_id: Float
}

"""
order by stddev() on columns of table "proposal_vote"
"""
input proposal_vote_stddev_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate stddev_pop on columns"""
type proposal_vote_stddev_pop_fields {
  height: Float
  proposal_id: Float
}

"""
order by stddev_pop() on columns of table "proposal_vote"
"""
input proposal_vote_stddev_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate stddev_samp on columns"""
type proposal_vote_stddev_samp_fields {
  height: Float
  proposal_id: Float
}

"""
order by stddev_samp() on columns of table "proposal_vote"
"""
input proposal_vote_stddev_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate sum on columns"""
type proposal_vote_sum_fields {
  height: bigint
  proposal_id: Int
}

"""
order by sum() on columns of table "proposal_vote"
"""
input proposal_vote_sum_order_by {
  height: order_by
  proposal_id: order_by
}

"""
update columns of table "proposal_vote"
"""
enum proposal_vote_update_column {
  """column name"""
  height

  """column name"""
  option

  """column name"""
  proposal_id

  """column name"""
  voter_address
}

"""aggregate var_pop on columns"""
type proposal_vote_var_pop_fields {
  height: Float
  proposal_id: Float
}

"""
order by var_pop() on columns of table "proposal_vote"
"""
input proposal_vote_var_pop_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate var_samp on columns"""
type proposal_vote_var_samp_fields {
  height: Float
  proposal_id: Float
}

"""
order by var_samp() on columns of table "proposal_vote"
"""
input proposal_vote_var_samp_order_by {
  height: order_by
  proposal_id: order_by
}

"""aggregate variance on columns"""
type proposal_vote_variance_fields {
  height: Float
  proposal_id: Float
}

"""
order by variance() on columns of table "proposal_vote"
"""
input proposal_vote_variance_order_by {
  height: order_by
  proposal_id: order_by
}

type query_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(address: String!): account
  action_account_balance(address: String!, height: Int): ActionBalance
  action_delegation(address: String!, count_total: Boolean, height: Int, limit: Int, offset: Int): ActionDelegationResponse
  action_delegation_reward(address: String!, height: Int): [ActionDelegationReward]
  action_delegation_total(address: String!, height: Int): ActionBalance
  action_delegator_withdraw_address(address: String!): ActionAddress!
  action_redelegation(address: String!, count_total: Boolean, height: Int, limit: Int, offset: Int): ActionRedelegationResponse
  action_unbonding_delegation(address: String!, count_total: Boolean, height: Int, limit: Int, offset: Int): ActionUnbondingDelegationResponse
  action_unbonding_delegation_total(address: String!, height: Int): ActionBalance
  action_validator_commission_amount(address: String!): ActionValidatorCommissionAmount
  action_validator_delegations(address: String!, count_total: Boolean, limit: Int, offset: Int): ActionDelegationResponse
  action_validator_redelegations_from(address: String!, count_total: Boolean, height: Int, limit: Int, offset: Int): ActionRedelegationResponse
  action_validator_unbonding_delegations(address: String!, count_total: Boolean, limit: Int, offset: Int): ActionUnbondingDelegationResponse

  """
  fetch data from the table: "assetft_params"
  """
  assetft_params(
    """distinct select on columns"""
    distinct_on: [assetft_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [assetft_params_order_by!]

    """filter the rows returned"""
    where: assetft_params_bool_exp
  ): [assetft_params!]!

  """
  fetch aggregated fields from the table: "assetft_params"
  """
  assetft_params_aggregate(
    """distinct select on columns"""
    distinct_on: [assetft_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [assetft_params_order_by!]

    """filter the rows returned"""
    where: assetft_params_bool_exp
  ): assetft_params_aggregate!

  """fetch data from the table: "assetft_params" using primary key columns"""
  assetft_params_by_pk(one_row_id: Boolean!): assetft_params

  """
  fetch data from the table: "assetnft_params"
  """
  assetnft_params(
    """distinct select on columns"""
    distinct_on: [assetnft_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [assetnft_params_order_by!]

    """filter the rows returned"""
    where: assetnft_params_bool_exp
  ): [assetnft_params!]!

  """
  fetch aggregated fields from the table: "assetnft_params"
  """
  assetnft_params_aggregate(
    """distinct select on columns"""
    distinct_on: [assetnft_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [assetnft_params_order_by!]

    """filter the rows returned"""
    where: assetnft_params_bool_exp
  ): assetnft_params_aggregate!

  """fetch data from the table: "assetnft_params" using primary key columns"""
  assetnft_params_by_pk(one_row_id: Boolean!): assetnft_params

  """
  fetch data from the table: "average_block_time_from_genesis"
  """
  average_block_time_from_genesis(
    """distinct select on columns"""
    distinct_on: [average_block_time_from_genesis_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_from_genesis_order_by!]

    """filter the rows returned"""
    where: average_block_time_from_genesis_bool_exp
  ): [average_block_time_from_genesis!]!

  """
  fetch aggregated fields from the table: "average_block_time_from_genesis"
  """
  average_block_time_from_genesis_aggregate(
    """distinct select on columns"""
    distinct_on: [average_block_time_from_genesis_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_from_genesis_order_by!]

    """filter the rows returned"""
    where: average_block_time_from_genesis_bool_exp
  ): average_block_time_from_genesis_aggregate!

  """
  fetch data from the table: "average_block_time_from_genesis" using primary key columns
  """
  average_block_time_from_genesis_by_pk(one_row_id: Boolean!): average_block_time_from_genesis

  """
  fetch data from the table: "average_block_time_per_day"
  """
  average_block_time_per_day(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_day_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_day_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_day_bool_exp
  ): [average_block_time_per_day!]!

  """
  fetch aggregated fields from the table: "average_block_time_per_day"
  """
  average_block_time_per_day_aggregate(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_day_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_day_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_day_bool_exp
  ): average_block_time_per_day_aggregate!

  """
  fetch data from the table: "average_block_time_per_day" using primary key columns
  """
  average_block_time_per_day_by_pk(one_row_id: Boolean!): average_block_time_per_day

  """
  fetch data from the table: "average_block_time_per_hour"
  """
  average_block_time_per_hour(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_hour_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_hour_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_hour_bool_exp
  ): [average_block_time_per_hour!]!

  """
  fetch aggregated fields from the table: "average_block_time_per_hour"
  """
  average_block_time_per_hour_aggregate(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_hour_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_hour_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_hour_bool_exp
  ): average_block_time_per_hour_aggregate!

  """
  fetch data from the table: "average_block_time_per_hour" using primary key columns
  """
  average_block_time_per_hour_by_pk(one_row_id: Boolean!): average_block_time_per_hour

  """
  fetch data from the table: "average_block_time_per_minute"
  """
  average_block_time_per_minute(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_minute_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_minute_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_minute_bool_exp
  ): [average_block_time_per_minute!]!

  """
  fetch aggregated fields from the table: "average_block_time_per_minute"
  """
  average_block_time_per_minute_aggregate(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_minute_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_minute_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_minute_bool_exp
  ): average_block_time_per_minute_aggregate!

  """
  fetch data from the table: "average_block_time_per_minute" using primary key columns
  """
  average_block_time_per_minute_by_pk(one_row_id: Boolean!): average_block_time_per_minute

  """
  fetch data from the table: "block"
  """
  block(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): [block!]!

  """
  fetch aggregated fields from the table: "block"
  """
  block_aggregate(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): block_aggregate!

  """fetch data from the table: "block" using primary key columns"""
  block_by_pk(height: bigint!): block

  """
  fetch data from the table: "community_pool"
  """
  community_pool(
    """distinct select on columns"""
    distinct_on: [community_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [community_pool_order_by!]

    """filter the rows returned"""
    where: community_pool_bool_exp
  ): [community_pool!]!

  """
  fetch aggregated fields from the table: "community_pool"
  """
  community_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [community_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [community_pool_order_by!]

    """filter the rows returned"""
    where: community_pool_bool_exp
  ): community_pool_aggregate!

  """fetch data from the table: "community_pool" using primary key columns"""
  community_pool_by_pk(one_row_id: Boolean!): community_pool

  """
  fetch data from the table: "customparams_params"
  """
  customparams_params(
    """distinct select on columns"""
    distinct_on: [customparams_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customparams_params_order_by!]

    """filter the rows returned"""
    where: customparams_params_bool_exp
  ): [customparams_params!]!

  """
  fetch aggregated fields from the table: "customparams_params"
  """
  customparams_params_aggregate(
    """distinct select on columns"""
    distinct_on: [customparams_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customparams_params_order_by!]

    """filter the rows returned"""
    where: customparams_params_bool_exp
  ): customparams_params_aggregate!

  """
  fetch data from the table: "customparams_params" using primary key columns
  """
  customparams_params_by_pk(one_row_id: Boolean!): customparams_params

  """
  fetch data from the table: "distribution_params"
  """
  distribution_params(
    """distinct select on columns"""
    distinct_on: [distribution_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [distribution_params_order_by!]

    """filter the rows returned"""
    where: distribution_params_bool_exp
  ): [distribution_params!]!

  """
  fetch aggregated fields from the table: "distribution_params"
  """
  distribution_params_aggregate(
    """distinct select on columns"""
    distinct_on: [distribution_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [distribution_params_order_by!]

    """filter the rows returned"""
    where: distribution_params_bool_exp
  ): distribution_params_aggregate!

  """
  fetch data from the table: "distribution_params" using primary key columns
  """
  distribution_params_by_pk(one_row_id: Boolean!): distribution_params

  """
  fetch data from the table: "double_sign_evidence"
  """
  double_sign_evidence(
    """distinct select on columns"""
    distinct_on: [double_sign_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_evidence_order_by!]

    """filter the rows returned"""
    where: double_sign_evidence_bool_exp
  ): [double_sign_evidence!]!

  """
  fetch aggregated fields from the table: "double_sign_evidence"
  """
  double_sign_evidence_aggregate(
    """distinct select on columns"""
    distinct_on: [double_sign_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_evidence_order_by!]

    """filter the rows returned"""
    where: double_sign_evidence_bool_exp
  ): double_sign_evidence_aggregate!

  """
  fetch data from the table: "double_sign_vote"
  """
  double_sign_vote(
    """distinct select on columns"""
    distinct_on: [double_sign_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_vote_order_by!]

    """filter the rows returned"""
    where: double_sign_vote_bool_exp
  ): [double_sign_vote!]!

  """
  fetch aggregated fields from the table: "double_sign_vote"
  """
  double_sign_vote_aggregate(
    """distinct select on columns"""
    distinct_on: [double_sign_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_vote_order_by!]

    """filter the rows returned"""
    where: double_sign_vote_bool_exp
  ): double_sign_vote_aggregate!

  """
  fetch data from the table: "double_sign_vote" using primary key columns
  """
  double_sign_vote_by_pk(id: Int!): double_sign_vote

  """
  fetch data from the table: "fee_grant_allowance"
  """
  fee_grant_allowance(
    """distinct select on columns"""
    distinct_on: [fee_grant_allowance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fee_grant_allowance_order_by!]

    """filter the rows returned"""
    where: fee_grant_allowance_bool_exp
  ): [fee_grant_allowance!]!

  """
  fetch aggregated fields from the table: "fee_grant_allowance"
  """
  fee_grant_allowance_aggregate(
    """distinct select on columns"""
    distinct_on: [fee_grant_allowance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fee_grant_allowance_order_by!]

    """filter the rows returned"""
    where: fee_grant_allowance_bool_exp
  ): fee_grant_allowance_aggregate!

  """
  fetch data from the table: "fee_grant_allowance" using primary key columns
  """
  fee_grant_allowance_by_pk(id: Int!): fee_grant_allowance

  """
  fetch data from the table: "feemodel_params"
  """
  feemodel_params(
    """distinct select on columns"""
    distinct_on: [feemodel_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feemodel_params_order_by!]

    """filter the rows returned"""
    where: feemodel_params_bool_exp
  ): [feemodel_params!]!

  """
  fetch aggregated fields from the table: "feemodel_params"
  """
  feemodel_params_aggregate(
    """distinct select on columns"""
    distinct_on: [feemodel_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feemodel_params_order_by!]

    """filter the rows returned"""
    where: feemodel_params_bool_exp
  ): feemodel_params_aggregate!

  """fetch data from the table: "feemodel_params" using primary key columns"""
  feemodel_params_by_pk(one_row_id: Boolean!): feemodel_params

  """
  fetch data from the table: "genesis"
  """
  genesis(
    """distinct select on columns"""
    distinct_on: [genesis_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [genesis_order_by!]

    """filter the rows returned"""
    where: genesis_bool_exp
  ): [genesis!]!

  """
  fetch aggregated fields from the table: "genesis"
  """
  genesis_aggregate(
    """distinct select on columns"""
    distinct_on: [genesis_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [genesis_order_by!]

    """filter the rows returned"""
    where: genesis_bool_exp
  ): genesis_aggregate!

  """fetch data from the table: "genesis" using primary key columns"""
  genesis_by_pk(one_row_id: Boolean!): genesis

  """
  fetch data from the table: "gov_params"
  """
  gov_params(
    """distinct select on columns"""
    distinct_on: [gov_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gov_params_order_by!]

    """filter the rows returned"""
    where: gov_params_bool_exp
  ): [gov_params!]!

  """
  fetch aggregated fields from the table: "gov_params"
  """
  gov_params_aggregate(
    """distinct select on columns"""
    distinct_on: [gov_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gov_params_order_by!]

    """filter the rows returned"""
    where: gov_params_bool_exp
  ): gov_params_aggregate!

  """fetch data from the table: "gov_params" using primary key columns"""
  gov_params_by_pk(one_row_id: Boolean!): gov_params

  """
  fetch data from the table: "inflation"
  """
  inflation(
    """distinct select on columns"""
    distinct_on: [inflation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inflation_order_by!]

    """filter the rows returned"""
    where: inflation_bool_exp
  ): [inflation!]!

  """
  fetch aggregated fields from the table: "inflation"
  """
  inflation_aggregate(
    """distinct select on columns"""
    distinct_on: [inflation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inflation_order_by!]

    """filter the rows returned"""
    where: inflation_bool_exp
  ): inflation_aggregate!

  """fetch data from the table: "inflation" using primary key columns"""
  inflation_by_pk(one_row_id: Boolean!): inflation

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """
  execute function "messages_by_address" which returns "message"
  """
  messages_by_address(
    """
    input parameters for function "messages_by_address"
    """
    args: messages_by_address_args!

    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  execute function "messages_by_address" and query aggregates on result of table type "message"
  """
  messages_by_address_aggregate(
    """
    input parameters for function "messages_by_address_aggregate"
    """
    args: messages_by_address_args!

    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """
  fetch data from the table: "mint_params"
  """
  mint_params(
    """distinct select on columns"""
    distinct_on: [mint_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_params_order_by!]

    """filter the rows returned"""
    where: mint_params_bool_exp
  ): [mint_params!]!

  """
  fetch aggregated fields from the table: "mint_params"
  """
  mint_params_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_params_order_by!]

    """filter the rows returned"""
    where: mint_params_bool_exp
  ): mint_params_aggregate!

  """fetch data from the table: "mint_params" using primary key columns"""
  mint_params_by_pk(one_row_id: Boolean!): mint_params

  """
  fetch data from the table: "modules"
  """
  modules(
    """distinct select on columns"""
    distinct_on: [modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [modules_order_by!]

    """filter the rows returned"""
    where: modules_bool_exp
  ): [modules!]!

  """
  fetch aggregated fields from the table: "modules"
  """
  modules_aggregate(
    """distinct select on columns"""
    distinct_on: [modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [modules_order_by!]

    """filter the rows returned"""
    where: modules_bool_exp
  ): modules_aggregate!

  """fetch data from the table: "modules" using primary key columns"""
  modules_by_pk(module_name: String!): modules

  """
  fetch data from the table: "pre_commit"
  """
  pre_commit(
    """distinct select on columns"""
    distinct_on: [pre_commit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pre_commit_order_by!]

    """filter the rows returned"""
    where: pre_commit_bool_exp
  ): [pre_commit!]!

  """
  fetch aggregated fields from the table: "pre_commit"
  """
  pre_commit_aggregate(
    """distinct select on columns"""
    distinct_on: [pre_commit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pre_commit_order_by!]

    """filter the rows returned"""
    where: pre_commit_bool_exp
  ): pre_commit_aggregate!

  """
  fetch data from the table: "proposal"
  """
  proposal(
    """distinct select on columns"""
    distinct_on: [proposal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_order_by!]

    """filter the rows returned"""
    where: proposal_bool_exp
  ): [proposal!]!

  """
  fetch aggregated fields from the table: "proposal"
  """
  proposal_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_order_by!]

    """filter the rows returned"""
    where: proposal_bool_exp
  ): proposal_aggregate!

  """fetch data from the table: "proposal" using primary key columns"""
  proposal_by_pk(id: Int!): proposal

  """
  fetch data from the table: "proposal_deposit"
  """
  proposal_deposit(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): [proposal_deposit!]!

  """
  fetch aggregated fields from the table: "proposal_deposit"
  """
  proposal_deposit_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): proposal_deposit_aggregate!

  """
  fetch data from the table: "proposal_staking_pool_snapshot"
  """
  proposal_staking_pool_snapshot(
    """distinct select on columns"""
    distinct_on: [proposal_staking_pool_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_staking_pool_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_staking_pool_snapshot_bool_exp
  ): [proposal_staking_pool_snapshot!]!

  """
  fetch aggregated fields from the table: "proposal_staking_pool_snapshot"
  """
  proposal_staking_pool_snapshot_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_staking_pool_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_staking_pool_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_staking_pool_snapshot_bool_exp
  ): proposal_staking_pool_snapshot_aggregate!

  """
  fetch data from the table: "proposal_staking_pool_snapshot" using primary key columns
  """
  proposal_staking_pool_snapshot_by_pk(proposal_id: Int!): proposal_staking_pool_snapshot

  """
  fetch data from the table: "proposal_tally_result"
  """
  proposal_tally_result(
    """distinct select on columns"""
    distinct_on: [proposal_tally_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_tally_result_order_by!]

    """filter the rows returned"""
    where: proposal_tally_result_bool_exp
  ): [proposal_tally_result!]!

  """
  fetch aggregated fields from the table: "proposal_tally_result"
  """
  proposal_tally_result_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_tally_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_tally_result_order_by!]

    """filter the rows returned"""
    where: proposal_tally_result_bool_exp
  ): proposal_tally_result_aggregate!

  """
  fetch data from the table: "proposal_tally_result" using primary key columns
  """
  proposal_tally_result_by_pk(proposal_id: Int!): proposal_tally_result

  """
  fetch data from the table: "proposal_validator_status_snapshot"
  """
  proposal_validator_status_snapshot(
    """distinct select on columns"""
    distinct_on: [proposal_validator_status_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_validator_status_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_validator_status_snapshot_bool_exp
  ): [proposal_validator_status_snapshot!]!

  """
  fetch aggregated fields from the table: "proposal_validator_status_snapshot"
  """
  proposal_validator_status_snapshot_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_validator_status_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_validator_status_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_validator_status_snapshot_bool_exp
  ): proposal_validator_status_snapshot_aggregate!

  """
  fetch data from the table: "proposal_validator_status_snapshot" using primary key columns
  """
  proposal_validator_status_snapshot_by_pk(id: Int!): proposal_validator_status_snapshot

  """
  fetch data from the table: "proposal_vote"
  """
  proposal_vote(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): [proposal_vote!]!

  """
  fetch aggregated fields from the table: "proposal_vote"
  """
  proposal_vote_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): proposal_vote_aggregate!

  """
  fetch data from the table: "slashing_params"
  """
  slashing_params(
    """distinct select on columns"""
    distinct_on: [slashing_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [slashing_params_order_by!]

    """filter the rows returned"""
    where: slashing_params_bool_exp
  ): [slashing_params!]!

  """
  fetch aggregated fields from the table: "slashing_params"
  """
  slashing_params_aggregate(
    """distinct select on columns"""
    distinct_on: [slashing_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [slashing_params_order_by!]

    """filter the rows returned"""
    where: slashing_params_bool_exp
  ): slashing_params_aggregate!

  """fetch data from the table: "slashing_params" using primary key columns"""
  slashing_params_by_pk(one_row_id: Boolean!): slashing_params

  """
  fetch data from the table: "staking_params"
  """
  staking_params(
    """distinct select on columns"""
    distinct_on: [staking_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staking_params_order_by!]

    """filter the rows returned"""
    where: staking_params_bool_exp
  ): [staking_params!]!

  """
  fetch aggregated fields from the table: "staking_params"
  """
  staking_params_aggregate(
    """distinct select on columns"""
    distinct_on: [staking_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staking_params_order_by!]

    """filter the rows returned"""
    where: staking_params_bool_exp
  ): staking_params_aggregate!

  """fetch data from the table: "staking_params" using primary key columns"""
  staking_params_by_pk(one_row_id: Boolean!): staking_params

  """
  fetch data from the table: "staking_pool"
  """
  staking_pool(
    """distinct select on columns"""
    distinct_on: [staking_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staking_pool_order_by!]

    """filter the rows returned"""
    where: staking_pool_bool_exp
  ): [staking_pool!]!

  """
  fetch aggregated fields from the table: "staking_pool"
  """
  staking_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [staking_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staking_pool_order_by!]

    """filter the rows returned"""
    where: staking_pool_bool_exp
  ): staking_pool_aggregate!

  """fetch data from the table: "staking_pool" using primary key columns"""
  staking_pool_by_pk(one_row_id: Boolean!): staking_pool

  """
  fetch data from the table: "supply"
  """
  supply(
    """distinct select on columns"""
    distinct_on: [supply_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supply_order_by!]

    """filter the rows returned"""
    where: supply_bool_exp
  ): [supply!]!

  """
  fetch aggregated fields from the table: "supply"
  """
  supply_aggregate(
    """distinct select on columns"""
    distinct_on: [supply_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supply_order_by!]

    """filter the rows returned"""
    where: supply_bool_exp
  ): supply_aggregate!

  """fetch data from the table: "supply" using primary key columns"""
  supply_by_pk(one_row_id: Boolean!): supply

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """
  fetch data from the table: "token_price"
  """
  token_price(
    """distinct select on columns"""
    distinct_on: [token_price_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_order_by!]

    """filter the rows returned"""
    where: token_price_bool_exp
  ): [token_price!]!

  """
  fetch aggregated fields from the table: "token_price"
  """
  token_price_aggregate(
    """distinct select on columns"""
    distinct_on: [token_price_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_order_by!]

    """filter the rows returned"""
    where: token_price_bool_exp
  ): token_price_aggregate!

  """fetch data from the table: "token_price" using primary key columns"""
  token_price_by_pk(id: Int!): token_price

  """
  fetch data from the table: "token_price_history"
  """
  token_price_history(
    """distinct select on columns"""
    distinct_on: [token_price_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_history_order_by!]

    """filter the rows returned"""
    where: token_price_history_bool_exp
  ): [token_price_history!]!

  """
  fetch aggregated fields from the table: "token_price_history"
  """
  token_price_history_aggregate(
    """distinct select on columns"""
    distinct_on: [token_price_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_history_order_by!]

    """filter the rows returned"""
    where: token_price_history_bool_exp
  ): token_price_history_aggregate!

  """
  fetch data from the table: "token_price_history" using primary key columns
  """
  token_price_history_by_pk(id: Int!): token_price_history

  """
  fetch data from the table: "token_unit"
  """
  token_unit(
    """distinct select on columns"""
    distinct_on: [token_unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_unit_order_by!]

    """filter the rows returned"""
    where: token_unit_bool_exp
  ): [token_unit!]!

  """
  fetch aggregated fields from the table: "token_unit"
  """
  token_unit_aggregate(
    """distinct select on columns"""
    distinct_on: [token_unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_unit_order_by!]

    """filter the rows returned"""
    where: token_unit_bool_exp
  ): token_unit_aggregate!

  """
  fetch data from the table: "transaction"
  """
  transaction(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch aggregated fields from the table: "transaction"
  """
  transaction_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """
  fetch data from the table: "validator"
  """
  validator(
    """distinct select on columns"""
    distinct_on: [validator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_order_by!]

    """filter the rows returned"""
    where: validator_bool_exp
  ): [validator!]!

  """
  fetch aggregated fields from the table: "validator"
  """
  validator_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_order_by!]

    """filter the rows returned"""
    where: validator_bool_exp
  ): validator_aggregate!

  """fetch data from the table: "validator" using primary key columns"""
  validator_by_pk(consensus_address: String!): validator

  """
  fetch data from the table: "validator_commission"
  """
  validator_commission(
    """distinct select on columns"""
    distinct_on: [validator_commission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_commission_order_by!]

    """filter the rows returned"""
    where: validator_commission_bool_exp
  ): [validator_commission!]!

  """
  fetch aggregated fields from the table: "validator_commission"
  """
  validator_commission_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_commission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_commission_order_by!]

    """filter the rows returned"""
    where: validator_commission_bool_exp
  ): validator_commission_aggregate!

  """
  fetch data from the table: "validator_commission" using primary key columns
  """
  validator_commission_by_pk(validator_address: String!): validator_commission

  """
  fetch data from the table: "validator_description"
  """
  validator_description(
    """distinct select on columns"""
    distinct_on: [validator_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_description_order_by!]

    """filter the rows returned"""
    where: validator_description_bool_exp
  ): [validator_description!]!

  """
  fetch aggregated fields from the table: "validator_description"
  """
  validator_description_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_description_order_by!]

    """filter the rows returned"""
    where: validator_description_bool_exp
  ): validator_description_aggregate!

  """
  fetch data from the table: "validator_description" using primary key columns
  """
  validator_description_by_pk(validator_address: String!): validator_description

  """
  fetch data from the table: "validator_info"
  """
  validator_info(
    """distinct select on columns"""
    distinct_on: [validator_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_info_order_by!]

    """filter the rows returned"""
    where: validator_info_bool_exp
  ): [validator_info!]!

  """
  fetch aggregated fields from the table: "validator_info"
  """
  validator_info_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_info_order_by!]

    """filter the rows returned"""
    where: validator_info_bool_exp
  ): validator_info_aggregate!

  """fetch data from the table: "validator_info" using primary key columns"""
  validator_info_by_pk(consensus_address: String!): validator_info

  """
  fetch data from the table: "validator_signing_info"
  """
  validator_signing_info(
    """distinct select on columns"""
    distinct_on: [validator_signing_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_signing_info_order_by!]

    """filter the rows returned"""
    where: validator_signing_info_bool_exp
  ): [validator_signing_info!]!

  """
  fetch aggregated fields from the table: "validator_signing_info"
  """
  validator_signing_info_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_signing_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_signing_info_order_by!]

    """filter the rows returned"""
    where: validator_signing_info_bool_exp
  ): validator_signing_info_aggregate!

  """
  fetch data from the table: "validator_signing_info" using primary key columns
  """
  validator_signing_info_by_pk(validator_address: String!): validator_signing_info

  """
  fetch data from the table: "validator_status"
  """
  validator_status(
    """distinct select on columns"""
    distinct_on: [validator_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_status_order_by!]

    """filter the rows returned"""
    where: validator_status_bool_exp
  ): [validator_status!]!

  """
  fetch aggregated fields from the table: "validator_status"
  """
  validator_status_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_status_order_by!]

    """filter the rows returned"""
    where: validator_status_bool_exp
  ): validator_status_aggregate!

  """
  fetch data from the table: "validator_status" using primary key columns
  """
  validator_status_by_pk(validator_address: String!): validator_status

  """
  fetch data from the table: "validator_voting_power"
  """
  validator_voting_power(
    """distinct select on columns"""
    distinct_on: [validator_voting_power_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_voting_power_order_by!]

    """filter the rows returned"""
    where: validator_voting_power_bool_exp
  ): [validator_voting_power!]!

  """
  fetch aggregated fields from the table: "validator_voting_power"
  """
  validator_voting_power_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_voting_power_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_voting_power_order_by!]

    """filter the rows returned"""
    where: validator_voting_power_bool_exp
  ): validator_voting_power_aggregate!

  """
  fetch data from the table: "validator_voting_power" using primary key columns
  """
  validator_voting_power_by_pk(validator_address: String!): validator_voting_power

  """
  fetch data from the table: "vesting_account"
  """
  vesting_account(
    """distinct select on columns"""
    distinct_on: [vesting_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_account_order_by!]

    """filter the rows returned"""
    where: vesting_account_bool_exp
  ): [vesting_account!]!

  """
  fetch aggregated fields from the table: "vesting_account"
  """
  vesting_account_aggregate(
    """distinct select on columns"""
    distinct_on: [vesting_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_account_order_by!]

    """filter the rows returned"""
    where: vesting_account_bool_exp
  ): vesting_account_aggregate!

  """fetch data from the table: "vesting_account" using primary key columns"""
  vesting_account_by_pk(id: Int!): vesting_account

  """
  fetch data from the table: "vesting_period"
  """
  vesting_period(
    """distinct select on columns"""
    distinct_on: [vesting_period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_period_order_by!]

    """filter the rows returned"""
    where: vesting_period_bool_exp
  ): [vesting_period!]!

  """
  fetch aggregated fields from the table: "vesting_period"
  """
  vesting_period_aggregate(
    """distinct select on columns"""
    distinct_on: [vesting_period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_period_order_by!]

    """filter the rows returned"""
    where: vesting_period_bool_exp
  ): vesting_period_aggregate!
}

"""
columns and relationships of "slashing_params"
"""
type slashing_params {
  height: bigint!
  one_row_id: Boolean!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "slashing_params"
"""
type slashing_params_aggregate {
  aggregate: slashing_params_aggregate_fields
  nodes: [slashing_params!]!
}

"""
aggregate fields of "slashing_params"
"""
type slashing_params_aggregate_fields {
  avg: slashing_params_avg_fields
  count(columns: [slashing_params_select_column!], distinct: Boolean): Int!
  max: slashing_params_max_fields
  min: slashing_params_min_fields
  stddev: slashing_params_stddev_fields
  stddev_pop: slashing_params_stddev_pop_fields
  stddev_samp: slashing_params_stddev_samp_fields
  sum: slashing_params_sum_fields
  var_pop: slashing_params_var_pop_fields
  var_samp: slashing_params_var_samp_fields
  variance: slashing_params_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input slashing_params_append_input {
  params: jsonb
}

"""aggregate avg on columns"""
type slashing_params_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "slashing_params". All fields are combined with a logical 'AND'.
"""
input slashing_params_bool_exp {
  _and: [slashing_params_bool_exp!]
  _not: slashing_params_bool_exp
  _or: [slashing_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "slashing_params"
"""
enum slashing_params_constraint {
  """unique or primary key constraint"""
  slashing_params_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input slashing_params_delete_at_path_input {
  params: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input slashing_params_delete_elem_input {
  params: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input slashing_params_delete_key_input {
  params: String
}

"""
input type for incrementing numeric columns in table "slashing_params"
"""
input slashing_params_inc_input {
  height: bigint
}

"""
input type for inserting data into table "slashing_params"
"""
input slashing_params_insert_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate max on columns"""
type slashing_params_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type slashing_params_min_fields {
  height: bigint
}

"""
response of any mutation on the table "slashing_params"
"""
type slashing_params_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [slashing_params!]!
}

"""
on conflict condition type for table "slashing_params"
"""
input slashing_params_on_conflict {
  constraint: slashing_params_constraint!
  update_columns: [slashing_params_update_column!]! = []
  where: slashing_params_bool_exp
}

"""Ordering options when selecting data from "slashing_params"."""
input slashing_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"""primary key columns input for table: slashing_params"""
input slashing_params_pk_columns_input {
  one_row_id: Boolean!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input slashing_params_prepend_input {
  params: jsonb
}

"""
select columns of table "slashing_params"
"""
enum slashing_params_select_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""
input type for updating data in table "slashing_params"
"""
input slashing_params_set_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate stddev on columns"""
type slashing_params_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type slashing_params_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type slashing_params_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type slashing_params_sum_fields {
  height: bigint
}

"""
update columns of table "slashing_params"
"""
enum slashing_params_update_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""aggregate var_pop on columns"""
type slashing_params_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type slashing_params_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type slashing_params_variance_fields {
  height: Float
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
columns and relationships of "staking_params"
"""
type staking_params {
  height: bigint!
  one_row_id: Boolean!
  params(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "staking_params"
"""
type staking_params_aggregate {
  aggregate: staking_params_aggregate_fields
  nodes: [staking_params!]!
}

"""
aggregate fields of "staking_params"
"""
type staking_params_aggregate_fields {
  avg: staking_params_avg_fields
  count(columns: [staking_params_select_column!], distinct: Boolean): Int!
  max: staking_params_max_fields
  min: staking_params_min_fields
  stddev: staking_params_stddev_fields
  stddev_pop: staking_params_stddev_pop_fields
  stddev_samp: staking_params_stddev_samp_fields
  sum: staking_params_sum_fields
  var_pop: staking_params_var_pop_fields
  var_samp: staking_params_var_samp_fields
  variance: staking_params_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input staking_params_append_input {
  params: jsonb
}

"""aggregate avg on columns"""
type staking_params_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "staking_params". All fields are combined with a logical 'AND'.
"""
input staking_params_bool_exp {
  _and: [staking_params_bool_exp!]
  _not: staking_params_bool_exp
  _or: [staking_params_bool_exp!]
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
  params: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "staking_params"
"""
enum staking_params_constraint {
  """unique or primary key constraint"""
  staking_params_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input staking_params_delete_at_path_input {
  params: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input staking_params_delete_elem_input {
  params: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input staking_params_delete_key_input {
  params: String
}

"""
input type for incrementing numeric columns in table "staking_params"
"""
input staking_params_inc_input {
  height: bigint
}

"""
input type for inserting data into table "staking_params"
"""
input staking_params_insert_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate max on columns"""
type staking_params_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type staking_params_min_fields {
  height: bigint
}

"""
response of any mutation on the table "staking_params"
"""
type staking_params_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [staking_params!]!
}

"""
on conflict condition type for table "staking_params"
"""
input staking_params_on_conflict {
  constraint: staking_params_constraint!
  update_columns: [staking_params_update_column!]! = []
  where: staking_params_bool_exp
}

"""Ordering options when selecting data from "staking_params"."""
input staking_params_order_by {
  height: order_by
  one_row_id: order_by
  params: order_by
}

"""primary key columns input for table: staking_params"""
input staking_params_pk_columns_input {
  one_row_id: Boolean!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input staking_params_prepend_input {
  params: jsonb
}

"""
select columns of table "staking_params"
"""
enum staking_params_select_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""
input type for updating data in table "staking_params"
"""
input staking_params_set_input {
  height: bigint
  one_row_id: Boolean
  params: jsonb
}

"""aggregate stddev on columns"""
type staking_params_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type staking_params_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type staking_params_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type staking_params_sum_fields {
  height: bigint
}

"""
update columns of table "staking_params"
"""
enum staking_params_update_column {
  """column name"""
  height

  """column name"""
  one_row_id

  """column name"""
  params
}

"""aggregate var_pop on columns"""
type staking_params_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type staking_params_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type staking_params_variance_fields {
  height: Float
}

"""
columns and relationships of "staking_pool"
"""
type staking_pool {
  bonded_tokens: String!
  height: bigint!
  not_bonded_tokens: String!
  one_row_id: Boolean!
}

"""
aggregated selection of "staking_pool"
"""
type staking_pool_aggregate {
  aggregate: staking_pool_aggregate_fields
  nodes: [staking_pool!]!
}

"""
aggregate fields of "staking_pool"
"""
type staking_pool_aggregate_fields {
  avg: staking_pool_avg_fields
  count(columns: [staking_pool_select_column!], distinct: Boolean): Int!
  max: staking_pool_max_fields
  min: staking_pool_min_fields
  stddev: staking_pool_stddev_fields
  stddev_pop: staking_pool_stddev_pop_fields
  stddev_samp: staking_pool_stddev_samp_fields
  sum: staking_pool_sum_fields
  var_pop: staking_pool_var_pop_fields
  var_samp: staking_pool_var_samp_fields
  variance: staking_pool_variance_fields
}

"""aggregate avg on columns"""
type staking_pool_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "staking_pool". All fields are combined with a logical 'AND'.
"""
input staking_pool_bool_exp {
  _and: [staking_pool_bool_exp!]
  _not: staking_pool_bool_exp
  _or: [staking_pool_bool_exp!]
  bonded_tokens: String_comparison_exp
  height: bigint_comparison_exp
  not_bonded_tokens: String_comparison_exp
  one_row_id: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "staking_pool"
"""
enum staking_pool_constraint {
  """unique or primary key constraint"""
  staking_pool_pkey
}

"""
input type for incrementing numeric columns in table "staking_pool"
"""
input staking_pool_inc_input {
  height: bigint
}

"""
input type for inserting data into table "staking_pool"
"""
input staking_pool_insert_input {
  bonded_tokens: String
  height: bigint
  not_bonded_tokens: String
  one_row_id: Boolean
}

"""aggregate max on columns"""
type staking_pool_max_fields {
  bonded_tokens: String
  height: bigint
  not_bonded_tokens: String
}

"""aggregate min on columns"""
type staking_pool_min_fields {
  bonded_tokens: String
  height: bigint
  not_bonded_tokens: String
}

"""
response of any mutation on the table "staking_pool"
"""
type staking_pool_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [staking_pool!]!
}

"""
on conflict condition type for table "staking_pool"
"""
input staking_pool_on_conflict {
  constraint: staking_pool_constraint!
  update_columns: [staking_pool_update_column!]! = []
  where: staking_pool_bool_exp
}

"""Ordering options when selecting data from "staking_pool"."""
input staking_pool_order_by {
  bonded_tokens: order_by
  height: order_by
  not_bonded_tokens: order_by
  one_row_id: order_by
}

"""primary key columns input for table: staking_pool"""
input staking_pool_pk_columns_input {
  one_row_id: Boolean!
}

"""
select columns of table "staking_pool"
"""
enum staking_pool_select_column {
  """column name"""
  bonded_tokens

  """column name"""
  height

  """column name"""
  not_bonded_tokens

  """column name"""
  one_row_id
}

"""
input type for updating data in table "staking_pool"
"""
input staking_pool_set_input {
  bonded_tokens: String
  height: bigint
  not_bonded_tokens: String
  one_row_id: Boolean
}

"""aggregate stddev on columns"""
type staking_pool_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type staking_pool_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type staking_pool_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type staking_pool_sum_fields {
  height: bigint
}

"""
update columns of table "staking_pool"
"""
enum staking_pool_update_column {
  """column name"""
  bonded_tokens

  """column name"""
  height

  """column name"""
  not_bonded_tokens

  """column name"""
  one_row_id
}

"""aggregate var_pop on columns"""
type staking_pool_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type staking_pool_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type staking_pool_variance_fields {
  height: Float
}

type subscription_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(address: String!): account

  """
  fetch data from the table: "assetft_params"
  """
  assetft_params(
    """distinct select on columns"""
    distinct_on: [assetft_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [assetft_params_order_by!]

    """filter the rows returned"""
    where: assetft_params_bool_exp
  ): [assetft_params!]!

  """
  fetch aggregated fields from the table: "assetft_params"
  """
  assetft_params_aggregate(
    """distinct select on columns"""
    distinct_on: [assetft_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [assetft_params_order_by!]

    """filter the rows returned"""
    where: assetft_params_bool_exp
  ): assetft_params_aggregate!

  """fetch data from the table: "assetft_params" using primary key columns"""
  assetft_params_by_pk(one_row_id: Boolean!): assetft_params

  """
  fetch data from the table: "assetnft_params"
  """
  assetnft_params(
    """distinct select on columns"""
    distinct_on: [assetnft_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [assetnft_params_order_by!]

    """filter the rows returned"""
    where: assetnft_params_bool_exp
  ): [assetnft_params!]!

  """
  fetch aggregated fields from the table: "assetnft_params"
  """
  assetnft_params_aggregate(
    """distinct select on columns"""
    distinct_on: [assetnft_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [assetnft_params_order_by!]

    """filter the rows returned"""
    where: assetnft_params_bool_exp
  ): assetnft_params_aggregate!

  """fetch data from the table: "assetnft_params" using primary key columns"""
  assetnft_params_by_pk(one_row_id: Boolean!): assetnft_params

  """
  fetch data from the table: "average_block_time_from_genesis"
  """
  average_block_time_from_genesis(
    """distinct select on columns"""
    distinct_on: [average_block_time_from_genesis_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_from_genesis_order_by!]

    """filter the rows returned"""
    where: average_block_time_from_genesis_bool_exp
  ): [average_block_time_from_genesis!]!

  """
  fetch aggregated fields from the table: "average_block_time_from_genesis"
  """
  average_block_time_from_genesis_aggregate(
    """distinct select on columns"""
    distinct_on: [average_block_time_from_genesis_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_from_genesis_order_by!]

    """filter the rows returned"""
    where: average_block_time_from_genesis_bool_exp
  ): average_block_time_from_genesis_aggregate!

  """
  fetch data from the table: "average_block_time_from_genesis" using primary key columns
  """
  average_block_time_from_genesis_by_pk(one_row_id: Boolean!): average_block_time_from_genesis

  """
  fetch data from the table: "average_block_time_per_day"
  """
  average_block_time_per_day(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_day_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_day_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_day_bool_exp
  ): [average_block_time_per_day!]!

  """
  fetch aggregated fields from the table: "average_block_time_per_day"
  """
  average_block_time_per_day_aggregate(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_day_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_day_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_day_bool_exp
  ): average_block_time_per_day_aggregate!

  """
  fetch data from the table: "average_block_time_per_day" using primary key columns
  """
  average_block_time_per_day_by_pk(one_row_id: Boolean!): average_block_time_per_day

  """
  fetch data from the table: "average_block_time_per_hour"
  """
  average_block_time_per_hour(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_hour_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_hour_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_hour_bool_exp
  ): [average_block_time_per_hour!]!

  """
  fetch aggregated fields from the table: "average_block_time_per_hour"
  """
  average_block_time_per_hour_aggregate(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_hour_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_hour_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_hour_bool_exp
  ): average_block_time_per_hour_aggregate!

  """
  fetch data from the table: "average_block_time_per_hour" using primary key columns
  """
  average_block_time_per_hour_by_pk(one_row_id: Boolean!): average_block_time_per_hour

  """
  fetch data from the table: "average_block_time_per_minute"
  """
  average_block_time_per_minute(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_minute_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_minute_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_minute_bool_exp
  ): [average_block_time_per_minute!]!

  """
  fetch aggregated fields from the table: "average_block_time_per_minute"
  """
  average_block_time_per_minute_aggregate(
    """distinct select on columns"""
    distinct_on: [average_block_time_per_minute_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [average_block_time_per_minute_order_by!]

    """filter the rows returned"""
    where: average_block_time_per_minute_bool_exp
  ): average_block_time_per_minute_aggregate!

  """
  fetch data from the table: "average_block_time_per_minute" using primary key columns
  """
  average_block_time_per_minute_by_pk(one_row_id: Boolean!): average_block_time_per_minute

  """
  fetch data from the table: "block"
  """
  block(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): [block!]!

  """
  fetch aggregated fields from the table: "block"
  """
  block_aggregate(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): block_aggregate!

  """fetch data from the table: "block" using primary key columns"""
  block_by_pk(height: bigint!): block

  """
  fetch data from the table: "community_pool"
  """
  community_pool(
    """distinct select on columns"""
    distinct_on: [community_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [community_pool_order_by!]

    """filter the rows returned"""
    where: community_pool_bool_exp
  ): [community_pool!]!

  """
  fetch aggregated fields from the table: "community_pool"
  """
  community_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [community_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [community_pool_order_by!]

    """filter the rows returned"""
    where: community_pool_bool_exp
  ): community_pool_aggregate!

  """fetch data from the table: "community_pool" using primary key columns"""
  community_pool_by_pk(one_row_id: Boolean!): community_pool

  """
  fetch data from the table: "customparams_params"
  """
  customparams_params(
    """distinct select on columns"""
    distinct_on: [customparams_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customparams_params_order_by!]

    """filter the rows returned"""
    where: customparams_params_bool_exp
  ): [customparams_params!]!

  """
  fetch aggregated fields from the table: "customparams_params"
  """
  customparams_params_aggregate(
    """distinct select on columns"""
    distinct_on: [customparams_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customparams_params_order_by!]

    """filter the rows returned"""
    where: customparams_params_bool_exp
  ): customparams_params_aggregate!

  """
  fetch data from the table: "customparams_params" using primary key columns
  """
  customparams_params_by_pk(one_row_id: Boolean!): customparams_params

  """
  fetch data from the table: "distribution_params"
  """
  distribution_params(
    """distinct select on columns"""
    distinct_on: [distribution_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [distribution_params_order_by!]

    """filter the rows returned"""
    where: distribution_params_bool_exp
  ): [distribution_params!]!

  """
  fetch aggregated fields from the table: "distribution_params"
  """
  distribution_params_aggregate(
    """distinct select on columns"""
    distinct_on: [distribution_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [distribution_params_order_by!]

    """filter the rows returned"""
    where: distribution_params_bool_exp
  ): distribution_params_aggregate!

  """
  fetch data from the table: "distribution_params" using primary key columns
  """
  distribution_params_by_pk(one_row_id: Boolean!): distribution_params

  """
  fetch data from the table: "double_sign_evidence"
  """
  double_sign_evidence(
    """distinct select on columns"""
    distinct_on: [double_sign_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_evidence_order_by!]

    """filter the rows returned"""
    where: double_sign_evidence_bool_exp
  ): [double_sign_evidence!]!

  """
  fetch aggregated fields from the table: "double_sign_evidence"
  """
  double_sign_evidence_aggregate(
    """distinct select on columns"""
    distinct_on: [double_sign_evidence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_evidence_order_by!]

    """filter the rows returned"""
    where: double_sign_evidence_bool_exp
  ): double_sign_evidence_aggregate!

  """
  fetch data from the table: "double_sign_vote"
  """
  double_sign_vote(
    """distinct select on columns"""
    distinct_on: [double_sign_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_vote_order_by!]

    """filter the rows returned"""
    where: double_sign_vote_bool_exp
  ): [double_sign_vote!]!

  """
  fetch aggregated fields from the table: "double_sign_vote"
  """
  double_sign_vote_aggregate(
    """distinct select on columns"""
    distinct_on: [double_sign_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_vote_order_by!]

    """filter the rows returned"""
    where: double_sign_vote_bool_exp
  ): double_sign_vote_aggregate!

  """
  fetch data from the table: "double_sign_vote" using primary key columns
  """
  double_sign_vote_by_pk(id: Int!): double_sign_vote

  """
  fetch data from the table: "fee_grant_allowance"
  """
  fee_grant_allowance(
    """distinct select on columns"""
    distinct_on: [fee_grant_allowance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fee_grant_allowance_order_by!]

    """filter the rows returned"""
    where: fee_grant_allowance_bool_exp
  ): [fee_grant_allowance!]!

  """
  fetch aggregated fields from the table: "fee_grant_allowance"
  """
  fee_grant_allowance_aggregate(
    """distinct select on columns"""
    distinct_on: [fee_grant_allowance_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fee_grant_allowance_order_by!]

    """filter the rows returned"""
    where: fee_grant_allowance_bool_exp
  ): fee_grant_allowance_aggregate!

  """
  fetch data from the table: "fee_grant_allowance" using primary key columns
  """
  fee_grant_allowance_by_pk(id: Int!): fee_grant_allowance

  """
  fetch data from the table: "feemodel_params"
  """
  feemodel_params(
    """distinct select on columns"""
    distinct_on: [feemodel_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feemodel_params_order_by!]

    """filter the rows returned"""
    where: feemodel_params_bool_exp
  ): [feemodel_params!]!

  """
  fetch aggregated fields from the table: "feemodel_params"
  """
  feemodel_params_aggregate(
    """distinct select on columns"""
    distinct_on: [feemodel_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feemodel_params_order_by!]

    """filter the rows returned"""
    where: feemodel_params_bool_exp
  ): feemodel_params_aggregate!

  """fetch data from the table: "feemodel_params" using primary key columns"""
  feemodel_params_by_pk(one_row_id: Boolean!): feemodel_params

  """
  fetch data from the table: "genesis"
  """
  genesis(
    """distinct select on columns"""
    distinct_on: [genesis_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [genesis_order_by!]

    """filter the rows returned"""
    where: genesis_bool_exp
  ): [genesis!]!

  """
  fetch aggregated fields from the table: "genesis"
  """
  genesis_aggregate(
    """distinct select on columns"""
    distinct_on: [genesis_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [genesis_order_by!]

    """filter the rows returned"""
    where: genesis_bool_exp
  ): genesis_aggregate!

  """fetch data from the table: "genesis" using primary key columns"""
  genesis_by_pk(one_row_id: Boolean!): genesis

  """
  fetch data from the table: "gov_params"
  """
  gov_params(
    """distinct select on columns"""
    distinct_on: [gov_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gov_params_order_by!]

    """filter the rows returned"""
    where: gov_params_bool_exp
  ): [gov_params!]!

  """
  fetch aggregated fields from the table: "gov_params"
  """
  gov_params_aggregate(
    """distinct select on columns"""
    distinct_on: [gov_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gov_params_order_by!]

    """filter the rows returned"""
    where: gov_params_bool_exp
  ): gov_params_aggregate!

  """fetch data from the table: "gov_params" using primary key columns"""
  gov_params_by_pk(one_row_id: Boolean!): gov_params

  """
  fetch data from the table: "inflation"
  """
  inflation(
    """distinct select on columns"""
    distinct_on: [inflation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inflation_order_by!]

    """filter the rows returned"""
    where: inflation_bool_exp
  ): [inflation!]!

  """
  fetch aggregated fields from the table: "inflation"
  """
  inflation_aggregate(
    """distinct select on columns"""
    distinct_on: [inflation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inflation_order_by!]

    """filter the rows returned"""
    where: inflation_bool_exp
  ): inflation_aggregate!

  """fetch data from the table: "inflation" using primary key columns"""
  inflation_by_pk(one_row_id: Boolean!): inflation

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """
  execute function "messages_by_address" which returns "message"
  """
  messages_by_address(
    """
    input parameters for function "messages_by_address"
    """
    args: messages_by_address_args!

    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  execute function "messages_by_address" and query aggregates on result of table type "message"
  """
  messages_by_address_aggregate(
    """
    input parameters for function "messages_by_address_aggregate"
    """
    args: messages_by_address_args!

    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """
  fetch data from the table: "mint_params"
  """
  mint_params(
    """distinct select on columns"""
    distinct_on: [mint_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_params_order_by!]

    """filter the rows returned"""
    where: mint_params_bool_exp
  ): [mint_params!]!

  """
  fetch aggregated fields from the table: "mint_params"
  """
  mint_params_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_params_order_by!]

    """filter the rows returned"""
    where: mint_params_bool_exp
  ): mint_params_aggregate!

  """fetch data from the table: "mint_params" using primary key columns"""
  mint_params_by_pk(one_row_id: Boolean!): mint_params

  """
  fetch data from the table: "modules"
  """
  modules(
    """distinct select on columns"""
    distinct_on: [modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [modules_order_by!]

    """filter the rows returned"""
    where: modules_bool_exp
  ): [modules!]!

  """
  fetch aggregated fields from the table: "modules"
  """
  modules_aggregate(
    """distinct select on columns"""
    distinct_on: [modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [modules_order_by!]

    """filter the rows returned"""
    where: modules_bool_exp
  ): modules_aggregate!

  """fetch data from the table: "modules" using primary key columns"""
  modules_by_pk(module_name: String!): modules

  """
  fetch data from the table: "pre_commit"
  """
  pre_commit(
    """distinct select on columns"""
    distinct_on: [pre_commit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pre_commit_order_by!]

    """filter the rows returned"""
    where: pre_commit_bool_exp
  ): [pre_commit!]!

  """
  fetch aggregated fields from the table: "pre_commit"
  """
  pre_commit_aggregate(
    """distinct select on columns"""
    distinct_on: [pre_commit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pre_commit_order_by!]

    """filter the rows returned"""
    where: pre_commit_bool_exp
  ): pre_commit_aggregate!

  """
  fetch data from the table: "proposal"
  """
  proposal(
    """distinct select on columns"""
    distinct_on: [proposal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_order_by!]

    """filter the rows returned"""
    where: proposal_bool_exp
  ): [proposal!]!

  """
  fetch aggregated fields from the table: "proposal"
  """
  proposal_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_order_by!]

    """filter the rows returned"""
    where: proposal_bool_exp
  ): proposal_aggregate!

  """fetch data from the table: "proposal" using primary key columns"""
  proposal_by_pk(id: Int!): proposal

  """
  fetch data from the table: "proposal_deposit"
  """
  proposal_deposit(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): [proposal_deposit!]!

  """
  fetch aggregated fields from the table: "proposal_deposit"
  """
  proposal_deposit_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_deposit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_deposit_order_by!]

    """filter the rows returned"""
    where: proposal_deposit_bool_exp
  ): proposal_deposit_aggregate!

  """
  fetch data from the table: "proposal_staking_pool_snapshot"
  """
  proposal_staking_pool_snapshot(
    """distinct select on columns"""
    distinct_on: [proposal_staking_pool_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_staking_pool_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_staking_pool_snapshot_bool_exp
  ): [proposal_staking_pool_snapshot!]!

  """
  fetch aggregated fields from the table: "proposal_staking_pool_snapshot"
  """
  proposal_staking_pool_snapshot_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_staking_pool_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_staking_pool_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_staking_pool_snapshot_bool_exp
  ): proposal_staking_pool_snapshot_aggregate!

  """
  fetch data from the table: "proposal_staking_pool_snapshot" using primary key columns
  """
  proposal_staking_pool_snapshot_by_pk(proposal_id: Int!): proposal_staking_pool_snapshot

  """
  fetch data from the table: "proposal_tally_result"
  """
  proposal_tally_result(
    """distinct select on columns"""
    distinct_on: [proposal_tally_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_tally_result_order_by!]

    """filter the rows returned"""
    where: proposal_tally_result_bool_exp
  ): [proposal_tally_result!]!

  """
  fetch aggregated fields from the table: "proposal_tally_result"
  """
  proposal_tally_result_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_tally_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_tally_result_order_by!]

    """filter the rows returned"""
    where: proposal_tally_result_bool_exp
  ): proposal_tally_result_aggregate!

  """
  fetch data from the table: "proposal_tally_result" using primary key columns
  """
  proposal_tally_result_by_pk(proposal_id: Int!): proposal_tally_result

  """
  fetch data from the table: "proposal_validator_status_snapshot"
  """
  proposal_validator_status_snapshot(
    """distinct select on columns"""
    distinct_on: [proposal_validator_status_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_validator_status_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_validator_status_snapshot_bool_exp
  ): [proposal_validator_status_snapshot!]!

  """
  fetch aggregated fields from the table: "proposal_validator_status_snapshot"
  """
  proposal_validator_status_snapshot_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_validator_status_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_validator_status_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_validator_status_snapshot_bool_exp
  ): proposal_validator_status_snapshot_aggregate!

  """
  fetch data from the table: "proposal_validator_status_snapshot" using primary key columns
  """
  proposal_validator_status_snapshot_by_pk(id: Int!): proposal_validator_status_snapshot

  """
  fetch data from the table: "proposal_vote"
  """
  proposal_vote(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): [proposal_vote!]!

  """
  fetch aggregated fields from the table: "proposal_vote"
  """
  proposal_vote_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_vote_order_by!]

    """filter the rows returned"""
    where: proposal_vote_bool_exp
  ): proposal_vote_aggregate!

  """
  fetch data from the table: "slashing_params"
  """
  slashing_params(
    """distinct select on columns"""
    distinct_on: [slashing_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [slashing_params_order_by!]

    """filter the rows returned"""
    where: slashing_params_bool_exp
  ): [slashing_params!]!

  """
  fetch aggregated fields from the table: "slashing_params"
  """
  slashing_params_aggregate(
    """distinct select on columns"""
    distinct_on: [slashing_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [slashing_params_order_by!]

    """filter the rows returned"""
    where: slashing_params_bool_exp
  ): slashing_params_aggregate!

  """fetch data from the table: "slashing_params" using primary key columns"""
  slashing_params_by_pk(one_row_id: Boolean!): slashing_params

  """
  fetch data from the table: "staking_params"
  """
  staking_params(
    """distinct select on columns"""
    distinct_on: [staking_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staking_params_order_by!]

    """filter the rows returned"""
    where: staking_params_bool_exp
  ): [staking_params!]!

  """
  fetch aggregated fields from the table: "staking_params"
  """
  staking_params_aggregate(
    """distinct select on columns"""
    distinct_on: [staking_params_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staking_params_order_by!]

    """filter the rows returned"""
    where: staking_params_bool_exp
  ): staking_params_aggregate!

  """fetch data from the table: "staking_params" using primary key columns"""
  staking_params_by_pk(one_row_id: Boolean!): staking_params

  """
  fetch data from the table: "staking_pool"
  """
  staking_pool(
    """distinct select on columns"""
    distinct_on: [staking_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staking_pool_order_by!]

    """filter the rows returned"""
    where: staking_pool_bool_exp
  ): [staking_pool!]!

  """
  fetch aggregated fields from the table: "staking_pool"
  """
  staking_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [staking_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [staking_pool_order_by!]

    """filter the rows returned"""
    where: staking_pool_bool_exp
  ): staking_pool_aggregate!

  """fetch data from the table: "staking_pool" using primary key columns"""
  staking_pool_by_pk(one_row_id: Boolean!): staking_pool

  """
  fetch data from the table: "supply"
  """
  supply(
    """distinct select on columns"""
    distinct_on: [supply_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supply_order_by!]

    """filter the rows returned"""
    where: supply_bool_exp
  ): [supply!]!

  """
  fetch aggregated fields from the table: "supply"
  """
  supply_aggregate(
    """distinct select on columns"""
    distinct_on: [supply_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [supply_order_by!]

    """filter the rows returned"""
    where: supply_bool_exp
  ): supply_aggregate!

  """fetch data from the table: "supply" using primary key columns"""
  supply_by_pk(one_row_id: Boolean!): supply

  """
  fetch data from the table: "token"
  """
  token(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): [token!]!

  """
  fetch aggregated fields from the table: "token"
  """
  token_aggregate(
    """distinct select on columns"""
    distinct_on: [token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_order_by!]

    """filter the rows returned"""
    where: token_bool_exp
  ): token_aggregate!

  """
  fetch data from the table: "token_price"
  """
  token_price(
    """distinct select on columns"""
    distinct_on: [token_price_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_order_by!]

    """filter the rows returned"""
    where: token_price_bool_exp
  ): [token_price!]!

  """
  fetch aggregated fields from the table: "token_price"
  """
  token_price_aggregate(
    """distinct select on columns"""
    distinct_on: [token_price_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_order_by!]

    """filter the rows returned"""
    where: token_price_bool_exp
  ): token_price_aggregate!

  """fetch data from the table: "token_price" using primary key columns"""
  token_price_by_pk(id: Int!): token_price

  """
  fetch data from the table: "token_price_history"
  """
  token_price_history(
    """distinct select on columns"""
    distinct_on: [token_price_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_history_order_by!]

    """filter the rows returned"""
    where: token_price_history_bool_exp
  ): [token_price_history!]!

  """
  fetch aggregated fields from the table: "token_price_history"
  """
  token_price_history_aggregate(
    """distinct select on columns"""
    distinct_on: [token_price_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_history_order_by!]

    """filter the rows returned"""
    where: token_price_history_bool_exp
  ): token_price_history_aggregate!

  """
  fetch data from the table: "token_price_history" using primary key columns
  """
  token_price_history_by_pk(id: Int!): token_price_history

  """
  fetch data from the table: "token_unit"
  """
  token_unit(
    """distinct select on columns"""
    distinct_on: [token_unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_unit_order_by!]

    """filter the rows returned"""
    where: token_unit_bool_exp
  ): [token_unit!]!

  """
  fetch aggregated fields from the table: "token_unit"
  """
  token_unit_aggregate(
    """distinct select on columns"""
    distinct_on: [token_unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_unit_order_by!]

    """filter the rows returned"""
    where: token_unit_bool_exp
  ): token_unit_aggregate!

  """
  fetch data from the table: "transaction"
  """
  transaction(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch aggregated fields from the table: "transaction"
  """
  transaction_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """
  fetch data from the table: "validator"
  """
  validator(
    """distinct select on columns"""
    distinct_on: [validator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_order_by!]

    """filter the rows returned"""
    where: validator_bool_exp
  ): [validator!]!

  """
  fetch aggregated fields from the table: "validator"
  """
  validator_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_order_by!]

    """filter the rows returned"""
    where: validator_bool_exp
  ): validator_aggregate!

  """fetch data from the table: "validator" using primary key columns"""
  validator_by_pk(consensus_address: String!): validator

  """
  fetch data from the table: "validator_commission"
  """
  validator_commission(
    """distinct select on columns"""
    distinct_on: [validator_commission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_commission_order_by!]

    """filter the rows returned"""
    where: validator_commission_bool_exp
  ): [validator_commission!]!

  """
  fetch aggregated fields from the table: "validator_commission"
  """
  validator_commission_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_commission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_commission_order_by!]

    """filter the rows returned"""
    where: validator_commission_bool_exp
  ): validator_commission_aggregate!

  """
  fetch data from the table: "validator_commission" using primary key columns
  """
  validator_commission_by_pk(validator_address: String!): validator_commission

  """
  fetch data from the table: "validator_description"
  """
  validator_description(
    """distinct select on columns"""
    distinct_on: [validator_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_description_order_by!]

    """filter the rows returned"""
    where: validator_description_bool_exp
  ): [validator_description!]!

  """
  fetch aggregated fields from the table: "validator_description"
  """
  validator_description_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_description_order_by!]

    """filter the rows returned"""
    where: validator_description_bool_exp
  ): validator_description_aggregate!

  """
  fetch data from the table: "validator_description" using primary key columns
  """
  validator_description_by_pk(validator_address: String!): validator_description

  """
  fetch data from the table: "validator_info"
  """
  validator_info(
    """distinct select on columns"""
    distinct_on: [validator_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_info_order_by!]

    """filter the rows returned"""
    where: validator_info_bool_exp
  ): [validator_info!]!

  """
  fetch aggregated fields from the table: "validator_info"
  """
  validator_info_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_info_order_by!]

    """filter the rows returned"""
    where: validator_info_bool_exp
  ): validator_info_aggregate!

  """fetch data from the table: "validator_info" using primary key columns"""
  validator_info_by_pk(consensus_address: String!): validator_info

  """
  fetch data from the table: "validator_signing_info"
  """
  validator_signing_info(
    """distinct select on columns"""
    distinct_on: [validator_signing_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_signing_info_order_by!]

    """filter the rows returned"""
    where: validator_signing_info_bool_exp
  ): [validator_signing_info!]!

  """
  fetch aggregated fields from the table: "validator_signing_info"
  """
  validator_signing_info_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_signing_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_signing_info_order_by!]

    """filter the rows returned"""
    where: validator_signing_info_bool_exp
  ): validator_signing_info_aggregate!

  """
  fetch data from the table: "validator_signing_info" using primary key columns
  """
  validator_signing_info_by_pk(validator_address: String!): validator_signing_info

  """
  fetch data from the table: "validator_status"
  """
  validator_status(
    """distinct select on columns"""
    distinct_on: [validator_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_status_order_by!]

    """filter the rows returned"""
    where: validator_status_bool_exp
  ): [validator_status!]!

  """
  fetch aggregated fields from the table: "validator_status"
  """
  validator_status_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_status_order_by!]

    """filter the rows returned"""
    where: validator_status_bool_exp
  ): validator_status_aggregate!

  """
  fetch data from the table: "validator_status" using primary key columns
  """
  validator_status_by_pk(validator_address: String!): validator_status

  """
  fetch data from the table: "validator_voting_power"
  """
  validator_voting_power(
    """distinct select on columns"""
    distinct_on: [validator_voting_power_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_voting_power_order_by!]

    """filter the rows returned"""
    where: validator_voting_power_bool_exp
  ): [validator_voting_power!]!

  """
  fetch aggregated fields from the table: "validator_voting_power"
  """
  validator_voting_power_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_voting_power_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_voting_power_order_by!]

    """filter the rows returned"""
    where: validator_voting_power_bool_exp
  ): validator_voting_power_aggregate!

  """
  fetch data from the table: "validator_voting_power" using primary key columns
  """
  validator_voting_power_by_pk(validator_address: String!): validator_voting_power

  """
  fetch data from the table: "vesting_account"
  """
  vesting_account(
    """distinct select on columns"""
    distinct_on: [vesting_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_account_order_by!]

    """filter the rows returned"""
    where: vesting_account_bool_exp
  ): [vesting_account!]!

  """
  fetch aggregated fields from the table: "vesting_account"
  """
  vesting_account_aggregate(
    """distinct select on columns"""
    distinct_on: [vesting_account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_account_order_by!]

    """filter the rows returned"""
    where: vesting_account_bool_exp
  ): vesting_account_aggregate!

  """fetch data from the table: "vesting_account" using primary key columns"""
  vesting_account_by_pk(id: Int!): vesting_account

  """
  fetch data from the table: "vesting_period"
  """
  vesting_period(
    """distinct select on columns"""
    distinct_on: [vesting_period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_period_order_by!]

    """filter the rows returned"""
    where: vesting_period_bool_exp
  ): [vesting_period!]!

  """
  fetch aggregated fields from the table: "vesting_period"
  """
  vesting_period_aggregate(
    """distinct select on columns"""
    distinct_on: [vesting_period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_period_order_by!]

    """filter the rows returned"""
    where: vesting_period_bool_exp
  ): vesting_period_aggregate!
}

"""
columns and relationships of "supply"
"""
type supply {
  coins: _coin!
  height: bigint!
  one_row_id: Boolean!
}

"""
aggregated selection of "supply"
"""
type supply_aggregate {
  aggregate: supply_aggregate_fields
  nodes: [supply!]!
}

"""
aggregate fields of "supply"
"""
type supply_aggregate_fields {
  avg: supply_avg_fields
  count(columns: [supply_select_column!], distinct: Boolean): Int!
  max: supply_max_fields
  min: supply_min_fields
  stddev: supply_stddev_fields
  stddev_pop: supply_stddev_pop_fields
  stddev_samp: supply_stddev_samp_fields
  sum: supply_sum_fields
  var_pop: supply_var_pop_fields
  var_samp: supply_var_samp_fields
  variance: supply_variance_fields
}

"""aggregate avg on columns"""
type supply_avg_fields {
  height: Float
}

"""
Boolean expression to filter rows from the table "supply". All fields are combined with a logical 'AND'.
"""
input supply_bool_exp {
  _and: [supply_bool_exp!]
  _not: supply_bool_exp
  _or: [supply_bool_exp!]
  coins: _coin_comparison_exp
  height: bigint_comparison_exp
  one_row_id: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "supply"
"""
enum supply_constraint {
  """unique or primary key constraint"""
  supply_pkey
}

"""
input type for incrementing numeric columns in table "supply"
"""
input supply_inc_input {
  height: bigint
}

"""
input type for inserting data into table "supply"
"""
input supply_insert_input {
  coins: _coin
  height: bigint
  one_row_id: Boolean
}

"""aggregate max on columns"""
type supply_max_fields {
  height: bigint
}

"""aggregate min on columns"""
type supply_min_fields {
  height: bigint
}

"""
response of any mutation on the table "supply"
"""
type supply_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [supply!]!
}

"""
on conflict condition type for table "supply"
"""
input supply_on_conflict {
  constraint: supply_constraint!
  update_columns: [supply_update_column!]! = []
  where: supply_bool_exp
}

"""Ordering options when selecting data from "supply"."""
input supply_order_by {
  coins: order_by
  height: order_by
  one_row_id: order_by
}

"""primary key columns input for table: supply"""
input supply_pk_columns_input {
  one_row_id: Boolean!
}

"""
select columns of table "supply"
"""
enum supply_select_column {
  """column name"""
  coins

  """column name"""
  height

  """column name"""
  one_row_id
}

"""
input type for updating data in table "supply"
"""
input supply_set_input {
  coins: _coin
  height: bigint
  one_row_id: Boolean
}

"""aggregate stddev on columns"""
type supply_stddev_fields {
  height: Float
}

"""aggregate stddev_pop on columns"""
type supply_stddev_pop_fields {
  height: Float
}

"""aggregate stddev_samp on columns"""
type supply_stddev_samp_fields {
  height: Float
}

"""aggregate sum on columns"""
type supply_sum_fields {
  height: bigint
}

"""
update columns of table "supply"
"""
enum supply_update_column {
  """column name"""
  coins

  """column name"""
  height

  """column name"""
  one_row_id
}

"""aggregate var_pop on columns"""
type supply_var_pop_fields {
  height: Float
}

"""aggregate var_samp on columns"""
type supply_var_samp_fields {
  height: Float
}

"""aggregate variance on columns"""
type supply_variance_fields {
  height: Float
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
columns and relationships of "token"
"""
type token {
  name: String!

  """An array relationship"""
  token_units(
    """distinct select on columns"""
    distinct_on: [token_unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_unit_order_by!]

    """filter the rows returned"""
    where: token_unit_bool_exp
  ): [token_unit!]!

  """An aggregate relationship"""
  token_units_aggregate(
    """distinct select on columns"""
    distinct_on: [token_unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_unit_order_by!]

    """filter the rows returned"""
    where: token_unit_bool_exp
  ): token_unit_aggregate!
}

"""
aggregated selection of "token"
"""
type token_aggregate {
  aggregate: token_aggregate_fields
  nodes: [token!]!
}

"""
aggregate fields of "token"
"""
type token_aggregate_fields {
  count(columns: [token_select_column!], distinct: Boolean): Int!
  max: token_max_fields
  min: token_min_fields
}

"""
Boolean expression to filter rows from the table "token". All fields are combined with a logical 'AND'.
"""
input token_bool_exp {
  _and: [token_bool_exp!]
  _not: token_bool_exp
  _or: [token_bool_exp!]
  name: String_comparison_exp
  token_units: token_unit_bool_exp
}

"""
unique or primary key constraints on table "token"
"""
enum token_constraint {
  """unique or primary key constraint"""
  token_name_key
}

"""
input type for inserting data into table "token"
"""
input token_insert_input {
  name: String
  token_units: token_unit_arr_rel_insert_input
}

"""aggregate max on columns"""
type token_max_fields {
  name: String
}

"""aggregate min on columns"""
type token_min_fields {
  name: String
}

"""
response of any mutation on the table "token"
"""
type token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [token!]!
}

"""
input type for inserting object relation for remote table "token"
"""
input token_obj_rel_insert_input {
  data: token_insert_input!

  """on conflict condition"""
  on_conflict: token_on_conflict
}

"""
on conflict condition type for table "token"
"""
input token_on_conflict {
  constraint: token_constraint!
  update_columns: [token_update_column!]! = []
  where: token_bool_exp
}

"""Ordering options when selecting data from "token"."""
input token_order_by {
  name: order_by
  token_units_aggregate: token_unit_aggregate_order_by
}

"""
columns and relationships of "token_price"
"""
type token_price {
  id: Int!
  market_cap: bigint!
  price: numeric!
  timestamp: timestamp!

  """An object relationship"""
  token_unit: token_unit!
  unit_name: String!
}

"""
aggregated selection of "token_price"
"""
type token_price_aggregate {
  aggregate: token_price_aggregate_fields
  nodes: [token_price!]!
}

"""
aggregate fields of "token_price"
"""
type token_price_aggregate_fields {
  avg: token_price_avg_fields
  count(columns: [token_price_select_column!], distinct: Boolean): Int!
  max: token_price_max_fields
  min: token_price_min_fields
  stddev: token_price_stddev_fields
  stddev_pop: token_price_stddev_pop_fields
  stddev_samp: token_price_stddev_samp_fields
  sum: token_price_sum_fields
  var_pop: token_price_var_pop_fields
  var_samp: token_price_var_samp_fields
  variance: token_price_variance_fields
}

"""
order by aggregate values of table "token_price"
"""
input token_price_aggregate_order_by {
  avg: token_price_avg_order_by
  count: order_by
  max: token_price_max_order_by
  min: token_price_min_order_by
  stddev: token_price_stddev_order_by
  stddev_pop: token_price_stddev_pop_order_by
  stddev_samp: token_price_stddev_samp_order_by
  sum: token_price_sum_order_by
  var_pop: token_price_var_pop_order_by
  var_samp: token_price_var_samp_order_by
  variance: token_price_variance_order_by
}

"""
input type for inserting array relation for remote table "token_price"
"""
input token_price_arr_rel_insert_input {
  data: [token_price_insert_input!]!

  """on conflict condition"""
  on_conflict: token_price_on_conflict
}

"""aggregate avg on columns"""
type token_price_avg_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by avg() on columns of table "token_price"
"""
input token_price_avg_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""
Boolean expression to filter rows from the table "token_price". All fields are combined with a logical 'AND'.
"""
input token_price_bool_exp {
  _and: [token_price_bool_exp!]
  _not: token_price_bool_exp
  _or: [token_price_bool_exp!]
  id: Int_comparison_exp
  market_cap: bigint_comparison_exp
  price: numeric_comparison_exp
  timestamp: timestamp_comparison_exp
  token_unit: token_unit_bool_exp
  unit_name: String_comparison_exp
}

"""
unique or primary key constraints on table "token_price"
"""
enum token_price_constraint {
  """unique or primary key constraint"""
  token_price_pkey

  """unique or primary key constraint"""
  token_price_unit_name_key
}

"""
columns and relationships of "token_price_history"
"""
type token_price_history {
  id: Int!
  market_cap: bigint!
  price: numeric!
  timestamp: timestamp!

  """An object relationship"""
  token_unit: token_unit!
  unit_name: String!
}

"""
aggregated selection of "token_price_history"
"""
type token_price_history_aggregate {
  aggregate: token_price_history_aggregate_fields
  nodes: [token_price_history!]!
}

"""
aggregate fields of "token_price_history"
"""
type token_price_history_aggregate_fields {
  avg: token_price_history_avg_fields
  count(columns: [token_price_history_select_column!], distinct: Boolean): Int!
  max: token_price_history_max_fields
  min: token_price_history_min_fields
  stddev: token_price_history_stddev_fields
  stddev_pop: token_price_history_stddev_pop_fields
  stddev_samp: token_price_history_stddev_samp_fields
  sum: token_price_history_sum_fields
  var_pop: token_price_history_var_pop_fields
  var_samp: token_price_history_var_samp_fields
  variance: token_price_history_variance_fields
}

"""
order by aggregate values of table "token_price_history"
"""
input token_price_history_aggregate_order_by {
  avg: token_price_history_avg_order_by
  count: order_by
  max: token_price_history_max_order_by
  min: token_price_history_min_order_by
  stddev: token_price_history_stddev_order_by
  stddev_pop: token_price_history_stddev_pop_order_by
  stddev_samp: token_price_history_stddev_samp_order_by
  sum: token_price_history_sum_order_by
  var_pop: token_price_history_var_pop_order_by
  var_samp: token_price_history_var_samp_order_by
  variance: token_price_history_variance_order_by
}

"""
input type for inserting array relation for remote table "token_price_history"
"""
input token_price_history_arr_rel_insert_input {
  data: [token_price_history_insert_input!]!

  """on conflict condition"""
  on_conflict: token_price_history_on_conflict
}

"""aggregate avg on columns"""
type token_price_history_avg_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by avg() on columns of table "token_price_history"
"""
input token_price_history_avg_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""
Boolean expression to filter rows from the table "token_price_history". All fields are combined with a logical 'AND'.
"""
input token_price_history_bool_exp {
  _and: [token_price_history_bool_exp!]
  _not: token_price_history_bool_exp
  _or: [token_price_history_bool_exp!]
  id: Int_comparison_exp
  market_cap: bigint_comparison_exp
  price: numeric_comparison_exp
  timestamp: timestamp_comparison_exp
  token_unit: token_unit_bool_exp
  unit_name: String_comparison_exp
}

"""
unique or primary key constraints on table "token_price_history"
"""
enum token_price_history_constraint {
  """unique or primary key constraint"""
  token_price_history_pkey

  """unique or primary key constraint"""
  unique_price_for_timestamp
}

"""
input type for incrementing numeric columns in table "token_price_history"
"""
input token_price_history_inc_input {
  id: Int
  market_cap: bigint
  price: numeric
}

"""
input type for inserting data into table "token_price_history"
"""
input token_price_history_insert_input {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  token_unit: token_unit_obj_rel_insert_input
  unit_name: String
}

"""aggregate max on columns"""
type token_price_history_max_fields {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"""
order by max() on columns of table "token_price_history"
"""
input token_price_history_max_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
  timestamp: order_by
  unit_name: order_by
}

"""aggregate min on columns"""
type token_price_history_min_fields {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"""
order by min() on columns of table "token_price_history"
"""
input token_price_history_min_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
  timestamp: order_by
  unit_name: order_by
}

"""
response of any mutation on the table "token_price_history"
"""
type token_price_history_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [token_price_history!]!
}

"""
on conflict condition type for table "token_price_history"
"""
input token_price_history_on_conflict {
  constraint: token_price_history_constraint!
  update_columns: [token_price_history_update_column!]! = []
  where: token_price_history_bool_exp
}

"""Ordering options when selecting data from "token_price_history"."""
input token_price_history_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
  timestamp: order_by
  token_unit: token_unit_order_by
  unit_name: order_by
}

"""primary key columns input for table: token_price_history"""
input token_price_history_pk_columns_input {
  id: Int!
}

"""
select columns of table "token_price_history"
"""
enum token_price_history_select_column {
  """column name"""
  id

  """column name"""
  market_cap

  """column name"""
  price

  """column name"""
  timestamp

  """column name"""
  unit_name
}

"""
input type for updating data in table "token_price_history"
"""
input token_price_history_set_input {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"""aggregate stddev on columns"""
type token_price_history_stddev_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by stddev() on columns of table "token_price_history"
"""
input token_price_history_stddev_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate stddev_pop on columns"""
type token_price_history_stddev_pop_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by stddev_pop() on columns of table "token_price_history"
"""
input token_price_history_stddev_pop_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate stddev_samp on columns"""
type token_price_history_stddev_samp_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by stddev_samp() on columns of table "token_price_history"
"""
input token_price_history_stddev_samp_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate sum on columns"""
type token_price_history_sum_fields {
  id: Int
  market_cap: bigint
  price: numeric
}

"""
order by sum() on columns of table "token_price_history"
"""
input token_price_history_sum_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""
update columns of table "token_price_history"
"""
enum token_price_history_update_column {
  """column name"""
  id

  """column name"""
  market_cap

  """column name"""
  price

  """column name"""
  timestamp

  """column name"""
  unit_name
}

"""aggregate var_pop on columns"""
type token_price_history_var_pop_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by var_pop() on columns of table "token_price_history"
"""
input token_price_history_var_pop_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate var_samp on columns"""
type token_price_history_var_samp_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by var_samp() on columns of table "token_price_history"
"""
input token_price_history_var_samp_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate variance on columns"""
type token_price_history_variance_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by variance() on columns of table "token_price_history"
"""
input token_price_history_variance_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""
input type for incrementing numeric columns in table "token_price"
"""
input token_price_inc_input {
  id: Int
  market_cap: bigint
  price: numeric
}

"""
input type for inserting data into table "token_price"
"""
input token_price_insert_input {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  token_unit: token_unit_obj_rel_insert_input
  unit_name: String
}

"""aggregate max on columns"""
type token_price_max_fields {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"""
order by max() on columns of table "token_price"
"""
input token_price_max_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
  timestamp: order_by
  unit_name: order_by
}

"""aggregate min on columns"""
type token_price_min_fields {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"""
order by min() on columns of table "token_price"
"""
input token_price_min_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
  timestamp: order_by
  unit_name: order_by
}

"""
response of any mutation on the table "token_price"
"""
type token_price_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [token_price!]!
}

"""
input type for inserting object relation for remote table "token_price"
"""
input token_price_obj_rel_insert_input {
  data: token_price_insert_input!

  """on conflict condition"""
  on_conflict: token_price_on_conflict
}

"""
on conflict condition type for table "token_price"
"""
input token_price_on_conflict {
  constraint: token_price_constraint!
  update_columns: [token_price_update_column!]! = []
  where: token_price_bool_exp
}

"""Ordering options when selecting data from "token_price"."""
input token_price_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
  timestamp: order_by
  token_unit: token_unit_order_by
  unit_name: order_by
}

"""primary key columns input for table: token_price"""
input token_price_pk_columns_input {
  id: Int!
}

"""
select columns of table "token_price"
"""
enum token_price_select_column {
  """column name"""
  id

  """column name"""
  market_cap

  """column name"""
  price

  """column name"""
  timestamp

  """column name"""
  unit_name
}

"""
input type for updating data in table "token_price"
"""
input token_price_set_input {
  id: Int
  market_cap: bigint
  price: numeric
  timestamp: timestamp
  unit_name: String
}

"""aggregate stddev on columns"""
type token_price_stddev_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by stddev() on columns of table "token_price"
"""
input token_price_stddev_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate stddev_pop on columns"""
type token_price_stddev_pop_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by stddev_pop() on columns of table "token_price"
"""
input token_price_stddev_pop_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate stddev_samp on columns"""
type token_price_stddev_samp_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by stddev_samp() on columns of table "token_price"
"""
input token_price_stddev_samp_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate sum on columns"""
type token_price_sum_fields {
  id: Int
  market_cap: bigint
  price: numeric
}

"""
order by sum() on columns of table "token_price"
"""
input token_price_sum_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""
update columns of table "token_price"
"""
enum token_price_update_column {
  """column name"""
  id

  """column name"""
  market_cap

  """column name"""
  price

  """column name"""
  timestamp

  """column name"""
  unit_name
}

"""aggregate var_pop on columns"""
type token_price_var_pop_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by var_pop() on columns of table "token_price"
"""
input token_price_var_pop_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate var_samp on columns"""
type token_price_var_samp_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by var_samp() on columns of table "token_price"
"""
input token_price_var_samp_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""aggregate variance on columns"""
type token_price_variance_fields {
  id: Float
  market_cap: Float
  price: Float
}

"""
order by variance() on columns of table "token_price"
"""
input token_price_variance_order_by {
  id: order_by
  market_cap: order_by
  price: order_by
}

"""
select columns of table "token"
"""
enum token_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "token"
"""
input token_set_input {
  name: String
}

"""
columns and relationships of "token_unit"
"""
type token_unit {
  aliases: _text
  denom: String!
  exponent: Int!
  price_id: String

  """An object relationship"""
  token: token!
  token_name: String!

  """An object relationship"""
  token_price: token_price

  """An array relationship"""
  token_price_histories(
    """distinct select on columns"""
    distinct_on: [token_price_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_history_order_by!]

    """filter the rows returned"""
    where: token_price_history_bool_exp
  ): [token_price_history!]!

  """An aggregate relationship"""
  token_price_histories_aggregate(
    """distinct select on columns"""
    distinct_on: [token_price_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_history_order_by!]

    """filter the rows returned"""
    where: token_price_history_bool_exp
  ): token_price_history_aggregate!

  """An array relationship"""
  token_prices(
    """distinct select on columns"""
    distinct_on: [token_price_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_order_by!]

    """filter the rows returned"""
    where: token_price_bool_exp
  ): [token_price!]!

  """An aggregate relationship"""
  token_prices_aggregate(
    """distinct select on columns"""
    distinct_on: [token_price_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_price_order_by!]

    """filter the rows returned"""
    where: token_price_bool_exp
  ): token_price_aggregate!
}

"""
aggregated selection of "token_unit"
"""
type token_unit_aggregate {
  aggregate: token_unit_aggregate_fields
  nodes: [token_unit!]!
}

"""
aggregate fields of "token_unit"
"""
type token_unit_aggregate_fields {
  avg: token_unit_avg_fields
  count(columns: [token_unit_select_column!], distinct: Boolean): Int!
  max: token_unit_max_fields
  min: token_unit_min_fields
  stddev: token_unit_stddev_fields
  stddev_pop: token_unit_stddev_pop_fields
  stddev_samp: token_unit_stddev_samp_fields
  sum: token_unit_sum_fields
  var_pop: token_unit_var_pop_fields
  var_samp: token_unit_var_samp_fields
  variance: token_unit_variance_fields
}

"""
order by aggregate values of table "token_unit"
"""
input token_unit_aggregate_order_by {
  avg: token_unit_avg_order_by
  count: order_by
  max: token_unit_max_order_by
  min: token_unit_min_order_by
  stddev: token_unit_stddev_order_by
  stddev_pop: token_unit_stddev_pop_order_by
  stddev_samp: token_unit_stddev_samp_order_by
  sum: token_unit_sum_order_by
  var_pop: token_unit_var_pop_order_by
  var_samp: token_unit_var_samp_order_by
  variance: token_unit_variance_order_by
}

"""
input type for inserting array relation for remote table "token_unit"
"""
input token_unit_arr_rel_insert_input {
  data: [token_unit_insert_input!]!

  """on conflict condition"""
  on_conflict: token_unit_on_conflict
}

"""aggregate avg on columns"""
type token_unit_avg_fields {
  exponent: Float
}

"""
order by avg() on columns of table "token_unit"
"""
input token_unit_avg_order_by {
  exponent: order_by
}

"""
Boolean expression to filter rows from the table "token_unit". All fields are combined with a logical 'AND'.
"""
input token_unit_bool_exp {
  _and: [token_unit_bool_exp!]
  _not: token_unit_bool_exp
  _or: [token_unit_bool_exp!]
  aliases: _text_comparison_exp
  denom: String_comparison_exp
  exponent: Int_comparison_exp
  price_id: String_comparison_exp
  token: token_bool_exp
  token_name: String_comparison_exp
  token_price: token_price_bool_exp
  token_price_histories: token_price_history_bool_exp
  token_prices: token_price_bool_exp
}

"""
unique or primary key constraints on table "token_unit"
"""
enum token_unit_constraint {
  """unique or primary key constraint"""
  token_unit_denom_key
}

"""
input type for incrementing numeric columns in table "token_unit"
"""
input token_unit_inc_input {
  exponent: Int
}

"""
input type for inserting data into table "token_unit"
"""
input token_unit_insert_input {
  aliases: _text
  denom: String
  exponent: Int
  price_id: String
  token: token_obj_rel_insert_input
  token_name: String
  token_price: token_price_obj_rel_insert_input
  token_price_histories: token_price_history_arr_rel_insert_input
  token_prices: token_price_arr_rel_insert_input
}

"""aggregate max on columns"""
type token_unit_max_fields {
  denom: String
  exponent: Int
  price_id: String
  token_name: String
}

"""
order by max() on columns of table "token_unit"
"""
input token_unit_max_order_by {
  denom: order_by
  exponent: order_by
  price_id: order_by
  token_name: order_by
}

"""aggregate min on columns"""
type token_unit_min_fields {
  denom: String
  exponent: Int
  price_id: String
  token_name: String
}

"""
order by min() on columns of table "token_unit"
"""
input token_unit_min_order_by {
  denom: order_by
  exponent: order_by
  price_id: order_by
  token_name: order_by
}

"""
response of any mutation on the table "token_unit"
"""
type token_unit_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [token_unit!]!
}

"""
input type for inserting object relation for remote table "token_unit"
"""
input token_unit_obj_rel_insert_input {
  data: token_unit_insert_input!

  """on conflict condition"""
  on_conflict: token_unit_on_conflict
}

"""
on conflict condition type for table "token_unit"
"""
input token_unit_on_conflict {
  constraint: token_unit_constraint!
  update_columns: [token_unit_update_column!]! = []
  where: token_unit_bool_exp
}

"""Ordering options when selecting data from "token_unit"."""
input token_unit_order_by {
  aliases: order_by
  denom: order_by
  exponent: order_by
  price_id: order_by
  token: token_order_by
  token_name: order_by
  token_price: token_price_order_by
  token_price_histories_aggregate: token_price_history_aggregate_order_by
  token_prices_aggregate: token_price_aggregate_order_by
}

"""
select columns of table "token_unit"
"""
enum token_unit_select_column {
  """column name"""
  aliases

  """column name"""
  denom

  """column name"""
  exponent

  """column name"""
  price_id

  """column name"""
  token_name
}

"""
input type for updating data in table "token_unit"
"""
input token_unit_set_input {
  aliases: _text
  denom: String
  exponent: Int
  price_id: String
  token_name: String
}

"""aggregate stddev on columns"""
type token_unit_stddev_fields {
  exponent: Float
}

"""
order by stddev() on columns of table "token_unit"
"""
input token_unit_stddev_order_by {
  exponent: order_by
}

"""aggregate stddev_pop on columns"""
type token_unit_stddev_pop_fields {
  exponent: Float
}

"""
order by stddev_pop() on columns of table "token_unit"
"""
input token_unit_stddev_pop_order_by {
  exponent: order_by
}

"""aggregate stddev_samp on columns"""
type token_unit_stddev_samp_fields {
  exponent: Float
}

"""
order by stddev_samp() on columns of table "token_unit"
"""
input token_unit_stddev_samp_order_by {
  exponent: order_by
}

"""aggregate sum on columns"""
type token_unit_sum_fields {
  exponent: Int
}

"""
order by sum() on columns of table "token_unit"
"""
input token_unit_sum_order_by {
  exponent: order_by
}

"""
update columns of table "token_unit"
"""
enum token_unit_update_column {
  """column name"""
  aliases

  """column name"""
  denom

  """column name"""
  exponent

  """column name"""
  price_id

  """column name"""
  token_name
}

"""aggregate var_pop on columns"""
type token_unit_var_pop_fields {
  exponent: Float
}

"""
order by var_pop() on columns of table "token_unit"
"""
input token_unit_var_pop_order_by {
  exponent: order_by
}

"""aggregate var_samp on columns"""
type token_unit_var_samp_fields {
  exponent: Float
}

"""
order by var_samp() on columns of table "token_unit"
"""
input token_unit_var_samp_order_by {
  exponent: order_by
}

"""aggregate variance on columns"""
type token_unit_variance_fields {
  exponent: Float
}

"""
order by variance() on columns of table "token_unit"
"""
input token_unit_variance_order_by {
  exponent: order_by
}

"""
update columns of table "token"
"""
enum token_update_column {
  """column name"""
  name
}

"""
columns and relationships of "transaction"
"""
type transaction {
  """An object relationship"""
  block: block!
  fee(
    """JSON select path"""
    path: String
  ): jsonb!
  gas_used: bigint
  gas_wanted: bigint
  hash: String!
  height: bigint!
  logs(
    """JSON select path"""
    path: String
  ): jsonb
  memo: String
  messages(
    """JSON select path"""
    path: String
  ): jsonb!
  partition_id: bigint!
  raw_log: String
  signatures: _text!
  signer_infos(
    """JSON select path"""
    path: String
  ): jsonb!
  success: Boolean!
}

"""
aggregated selection of "transaction"
"""
type transaction_aggregate {
  aggregate: transaction_aggregate_fields
  nodes: [transaction!]!
}

"""
aggregate fields of "transaction"
"""
type transaction_aggregate_fields {
  avg: transaction_avg_fields
  count(columns: [transaction_select_column!], distinct: Boolean): Int!
  max: transaction_max_fields
  min: transaction_min_fields
  stddev: transaction_stddev_fields
  stddev_pop: transaction_stddev_pop_fields
  stddev_samp: transaction_stddev_samp_fields
  sum: transaction_sum_fields
  var_pop: transaction_var_pop_fields
  var_samp: transaction_var_samp_fields
  variance: transaction_variance_fields
}

"""
order by aggregate values of table "transaction"
"""
input transaction_aggregate_order_by {
  avg: transaction_avg_order_by
  count: order_by
  max: transaction_max_order_by
  min: transaction_min_order_by
  stddev: transaction_stddev_order_by
  stddev_pop: transaction_stddev_pop_order_by
  stddev_samp: transaction_stddev_samp_order_by
  sum: transaction_sum_order_by
  var_pop: transaction_var_pop_order_by
  var_samp: transaction_var_samp_order_by
  variance: transaction_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input transaction_append_input {
  fee: jsonb
  logs: jsonb
  messages: jsonb
  signer_infos: jsonb
}

"""
input type for inserting array relation for remote table "transaction"
"""
input transaction_arr_rel_insert_input {
  data: [transaction_insert_input!]!

  """on conflict condition"""
  on_conflict: transaction_on_conflict
}

"""aggregate avg on columns"""
type transaction_avg_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
  partition_id: Float
}

"""
order by avg() on columns of table "transaction"
"""
input transaction_avg_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
  partition_id: order_by
}

"""
Boolean expression to filter rows from the table "transaction". All fields are combined with a logical 'AND'.
"""
input transaction_bool_exp {
  _and: [transaction_bool_exp!]
  _not: transaction_bool_exp
  _or: [transaction_bool_exp!]
  block: block_bool_exp
  fee: jsonb_comparison_exp
  gas_used: bigint_comparison_exp
  gas_wanted: bigint_comparison_exp
  hash: String_comparison_exp
  height: bigint_comparison_exp
  logs: jsonb_comparison_exp
  memo: String_comparison_exp
  messages: jsonb_comparison_exp
  partition_id: bigint_comparison_exp
  raw_log: String_comparison_exp
  signatures: _text_comparison_exp
  signer_infos: jsonb_comparison_exp
  success: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "transaction"
"""
enum transaction_constraint {
  """unique or primary key constraint"""
  unique_tx
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input transaction_delete_at_path_input {
  fee: [String!]
  logs: [String!]
  messages: [String!]
  signer_infos: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input transaction_delete_elem_input {
  fee: Int
  logs: Int
  messages: Int
  signer_infos: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input transaction_delete_key_input {
  fee: String
  logs: String
  messages: String
  signer_infos: String
}

"""
input type for incrementing numeric columns in table "transaction"
"""
input transaction_inc_input {
  gas_used: bigint
  gas_wanted: bigint
  height: bigint
  partition_id: bigint
}

"""
input type for inserting data into table "transaction"
"""
input transaction_insert_input {
  block: block_obj_rel_insert_input
  fee: jsonb
  gas_used: bigint
  gas_wanted: bigint
  hash: String
  height: bigint
  logs: jsonb
  memo: String
  messages: jsonb
  partition_id: bigint
  raw_log: String
  signatures: _text
  signer_infos: jsonb
  success: Boolean
}

"""aggregate max on columns"""
type transaction_max_fields {
  gas_used: bigint
  gas_wanted: bigint
  hash: String
  height: bigint
  memo: String
  partition_id: bigint
  raw_log: String
}

"""
order by max() on columns of table "transaction"
"""
input transaction_max_order_by {
  gas_used: order_by
  gas_wanted: order_by
  hash: order_by
  height: order_by
  memo: order_by
  partition_id: order_by
  raw_log: order_by
}

"""aggregate min on columns"""
type transaction_min_fields {
  gas_used: bigint
  gas_wanted: bigint
  hash: String
  height: bigint
  memo: String
  partition_id: bigint
  raw_log: String
}

"""
order by min() on columns of table "transaction"
"""
input transaction_min_order_by {
  gas_used: order_by
  gas_wanted: order_by
  hash: order_by
  height: order_by
  memo: order_by
  partition_id: order_by
  raw_log: order_by
}

"""
response of any mutation on the table "transaction"
"""
type transaction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [transaction!]!
}

"""
input type for inserting object relation for remote table "transaction"
"""
input transaction_obj_rel_insert_input {
  data: transaction_insert_input!

  """on conflict condition"""
  on_conflict: transaction_on_conflict
}

"""
on conflict condition type for table "transaction"
"""
input transaction_on_conflict {
  constraint: transaction_constraint!
  update_columns: [transaction_update_column!]! = []
  where: transaction_bool_exp
}

"""Ordering options when selecting data from "transaction"."""
input transaction_order_by {
  block: block_order_by
  fee: order_by
  gas_used: order_by
  gas_wanted: order_by
  hash: order_by
  height: order_by
  logs: order_by
  memo: order_by
  messages: order_by
  partition_id: order_by
  raw_log: order_by
  signatures: order_by
  signer_infos: order_by
  success: order_by
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input transaction_prepend_input {
  fee: jsonb
  logs: jsonb
  messages: jsonb
  signer_infos: jsonb
}

"""
select columns of table "transaction"
"""
enum transaction_select_column {
  """column name"""
  fee

  """column name"""
  gas_used

  """column name"""
  gas_wanted

  """column name"""
  hash

  """column name"""
  height

  """column name"""
  logs

  """column name"""
  memo

  """column name"""
  messages

  """column name"""
  partition_id

  """column name"""
  raw_log

  """column name"""
  signatures

  """column name"""
  signer_infos

  """column name"""
  success
}

"""
input type for updating data in table "transaction"
"""
input transaction_set_input {
  fee: jsonb
  gas_used: bigint
  gas_wanted: bigint
  hash: String
  height: bigint
  logs: jsonb
  memo: String
  messages: jsonb
  partition_id: bigint
  raw_log: String
  signatures: _text
  signer_infos: jsonb
  success: Boolean
}

"""aggregate stddev on columns"""
type transaction_stddev_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
  partition_id: Float
}

"""
order by stddev() on columns of table "transaction"
"""
input transaction_stddev_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
  partition_id: order_by
}

"""aggregate stddev_pop on columns"""
type transaction_stddev_pop_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
  partition_id: Float
}

"""
order by stddev_pop() on columns of table "transaction"
"""
input transaction_stddev_pop_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
  partition_id: order_by
}

"""aggregate stddev_samp on columns"""
type transaction_stddev_samp_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
  partition_id: Float
}

"""
order by stddev_samp() on columns of table "transaction"
"""
input transaction_stddev_samp_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
  partition_id: order_by
}

"""aggregate sum on columns"""
type transaction_sum_fields {
  gas_used: bigint
  gas_wanted: bigint
  height: bigint
  partition_id: bigint
}

"""
order by sum() on columns of table "transaction"
"""
input transaction_sum_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
  partition_id: order_by
}

"""
update columns of table "transaction"
"""
enum transaction_update_column {
  """column name"""
  fee

  """column name"""
  gas_used

  """column name"""
  gas_wanted

  """column name"""
  hash

  """column name"""
  height

  """column name"""
  logs

  """column name"""
  memo

  """column name"""
  messages

  """column name"""
  partition_id

  """column name"""
  raw_log

  """column name"""
  signatures

  """column name"""
  signer_infos

  """column name"""
  success
}

"""aggregate var_pop on columns"""
type transaction_var_pop_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
  partition_id: Float
}

"""
order by var_pop() on columns of table "transaction"
"""
input transaction_var_pop_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
  partition_id: order_by
}

"""aggregate var_samp on columns"""
type transaction_var_samp_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
  partition_id: Float
}

"""
order by var_samp() on columns of table "transaction"
"""
input transaction_var_samp_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
  partition_id: order_by
}

"""aggregate variance on columns"""
type transaction_variance_fields {
  gas_used: Float
  gas_wanted: Float
  height: Float
  partition_id: Float
}

"""
order by variance() on columns of table "transaction"
"""
input transaction_variance_order_by {
  gas_used: order_by
  gas_wanted: order_by
  height: order_by
  partition_id: order_by
}

"""
columns and relationships of "validator"
"""
type validator {
  """An array relationship"""
  blocks(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): [block!]!

  """An aggregate relationship"""
  blocks_aggregate(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): block_aggregate!
  consensus_address: String!
  consensus_pubkey: String!

  """An array relationship"""
  double_sign_votes(
    """distinct select on columns"""
    distinct_on: [double_sign_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_vote_order_by!]

    """filter the rows returned"""
    where: double_sign_vote_bool_exp
  ): [double_sign_vote!]!

  """An aggregate relationship"""
  double_sign_votes_aggregate(
    """distinct select on columns"""
    distinct_on: [double_sign_vote_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [double_sign_vote_order_by!]

    """filter the rows returned"""
    where: double_sign_vote_bool_exp
  ): double_sign_vote_aggregate!

  """An array relationship"""
  pre_commits(
    """distinct select on columns"""
    distinct_on: [pre_commit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pre_commit_order_by!]

    """filter the rows returned"""
    where: pre_commit_bool_exp
  ): [pre_commit!]!

  """An aggregate relationship"""
  pre_commits_aggregate(
    """distinct select on columns"""
    distinct_on: [pre_commit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pre_commit_order_by!]

    """filter the rows returned"""
    where: pre_commit_bool_exp
  ): pre_commit_aggregate!

  """An object relationship"""
  proposal_validator_status_snapshot: proposal_validator_status_snapshot

  """An array relationship"""
  proposal_validator_status_snapshots(
    """distinct select on columns"""
    distinct_on: [proposal_validator_status_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_validator_status_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_validator_status_snapshot_bool_exp
  ): [proposal_validator_status_snapshot!]!

  """An aggregate relationship"""
  proposal_validator_status_snapshots_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_validator_status_snapshot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_validator_status_snapshot_order_by!]

    """filter the rows returned"""
    where: proposal_validator_status_snapshot_bool_exp
  ): proposal_validator_status_snapshot_aggregate!

  """An array relationship"""
  validator_commissions(
    """distinct select on columns"""
    distinct_on: [validator_commission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_commission_order_by!]

    """filter the rows returned"""
    where: validator_commission_bool_exp
  ): [validator_commission!]!

  """An aggregate relationship"""
  validator_commissions_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_commission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_commission_order_by!]

    """filter the rows returned"""
    where: validator_commission_bool_exp
  ): validator_commission_aggregate!

  """An array relationship"""
  validator_descriptions(
    """distinct select on columns"""
    distinct_on: [validator_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_description_order_by!]

    """filter the rows returned"""
    where: validator_description_bool_exp
  ): [validator_description!]!

  """An aggregate relationship"""
  validator_descriptions_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_description_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_description_order_by!]

    """filter the rows returned"""
    where: validator_description_bool_exp
  ): validator_description_aggregate!

  """An object relationship"""
  validator_info: validator_info

  """An array relationship"""
  validator_infos(
    """distinct select on columns"""
    distinct_on: [validator_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_info_order_by!]

    """filter the rows returned"""
    where: validator_info_bool_exp
  ): [validator_info!]!

  """An aggregate relationship"""
  validator_infos_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_info_order_by!]

    """filter the rows returned"""
    where: validator_info_bool_exp
  ): validator_info_aggregate!

  """An array relationship"""
  validator_signing_infos(
    """distinct select on columns"""
    distinct_on: [validator_signing_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_signing_info_order_by!]

    """filter the rows returned"""
    where: validator_signing_info_bool_exp
  ): [validator_signing_info!]!

  """An aggregate relationship"""
  validator_signing_infos_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_signing_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_signing_info_order_by!]

    """filter the rows returned"""
    where: validator_signing_info_bool_exp
  ): validator_signing_info_aggregate!

  """An array relationship"""
  validator_statuses(
    """distinct select on columns"""
    distinct_on: [validator_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_status_order_by!]

    """filter the rows returned"""
    where: validator_status_bool_exp
  ): [validator_status!]!

  """An aggregate relationship"""
  validator_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_status_order_by!]

    """filter the rows returned"""
    where: validator_status_bool_exp
  ): validator_status_aggregate!

  """An array relationship"""
  validator_voting_powers(
    """distinct select on columns"""
    distinct_on: [validator_voting_power_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_voting_power_order_by!]

    """filter the rows returned"""
    where: validator_voting_power_bool_exp
  ): [validator_voting_power!]!

  """An aggregate relationship"""
  validator_voting_powers_aggregate(
    """distinct select on columns"""
    distinct_on: [validator_voting_power_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [validator_voting_power_order_by!]

    """filter the rows returned"""
    where: validator_voting_power_bool_exp
  ): validator_voting_power_aggregate!
}

"""
aggregated selection of "validator"
"""
type validator_aggregate {
  aggregate: validator_aggregate_fields
  nodes: [validator!]!
}

"""
aggregate fields of "validator"
"""
type validator_aggregate_fields {
  count(columns: [validator_select_column!], distinct: Boolean): Int!
  max: validator_max_fields
  min: validator_min_fields
}

"""
Boolean expression to filter rows from the table "validator". All fields are combined with a logical 'AND'.
"""
input validator_bool_exp {
  _and: [validator_bool_exp!]
  _not: validator_bool_exp
  _or: [validator_bool_exp!]
  blocks: block_bool_exp
  consensus_address: String_comparison_exp
  consensus_pubkey: String_comparison_exp
  double_sign_votes: double_sign_vote_bool_exp
  pre_commits: pre_commit_bool_exp
  proposal_validator_status_snapshot: proposal_validator_status_snapshot_bool_exp
  proposal_validator_status_snapshots: proposal_validator_status_snapshot_bool_exp
  validator_commissions: validator_commission_bool_exp
  validator_descriptions: validator_description_bool_exp
  validator_info: validator_info_bool_exp
  validator_infos: validator_info_bool_exp
  validator_signing_infos: validator_signing_info_bool_exp
  validator_statuses: validator_status_bool_exp
  validator_voting_powers: validator_voting_power_bool_exp
}

"""
columns and relationships of "validator_commission"
"""
type validator_commission {
  commission: numeric!
  height: bigint!
  min_self_delegation: bigint!

  """An object relationship"""
  validator: validator!
  validator_address: String!
}

"""
aggregated selection of "validator_commission"
"""
type validator_commission_aggregate {
  aggregate: validator_commission_aggregate_fields
  nodes: [validator_commission!]!
}

"""
aggregate fields of "validator_commission"
"""
type validator_commission_aggregate_fields {
  avg: validator_commission_avg_fields
  count(columns: [validator_commission_select_column!], distinct: Boolean): Int!
  max: validator_commission_max_fields
  min: validator_commission_min_fields
  stddev: validator_commission_stddev_fields
  stddev_pop: validator_commission_stddev_pop_fields
  stddev_samp: validator_commission_stddev_samp_fields
  sum: validator_commission_sum_fields
  var_pop: validator_commission_var_pop_fields
  var_samp: validator_commission_var_samp_fields
  variance: validator_commission_variance_fields
}

"""
order by aggregate values of table "validator_commission"
"""
input validator_commission_aggregate_order_by {
  avg: validator_commission_avg_order_by
  count: order_by
  max: validator_commission_max_order_by
  min: validator_commission_min_order_by
  stddev: validator_commission_stddev_order_by
  stddev_pop: validator_commission_stddev_pop_order_by
  stddev_samp: validator_commission_stddev_samp_order_by
  sum: validator_commission_sum_order_by
  var_pop: validator_commission_var_pop_order_by
  var_samp: validator_commission_var_samp_order_by
  variance: validator_commission_variance_order_by
}

"""
input type for inserting array relation for remote table "validator_commission"
"""
input validator_commission_arr_rel_insert_input {
  data: [validator_commission_insert_input!]!

  """on conflict condition"""
  on_conflict: validator_commission_on_conflict
}

"""aggregate avg on columns"""
type validator_commission_avg_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"""
order by avg() on columns of table "validator_commission"
"""
input validator_commission_avg_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"""
Boolean expression to filter rows from the table "validator_commission". All fields are combined with a logical 'AND'.
"""
input validator_commission_bool_exp {
  _and: [validator_commission_bool_exp!]
  _not: validator_commission_bool_exp
  _or: [validator_commission_bool_exp!]
  commission: numeric_comparison_exp
  height: bigint_comparison_exp
  min_self_delegation: bigint_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
}

"""
unique or primary key constraints on table "validator_commission"
"""
enum validator_commission_constraint {
  """unique or primary key constraint"""
  validator_commission_pkey
}

"""
input type for incrementing numeric columns in table "validator_commission"
"""
input validator_commission_inc_input {
  commission: numeric
  height: bigint
  min_self_delegation: bigint
}

"""
input type for inserting data into table "validator_commission"
"""
input validator_commission_insert_input {
  commission: numeric
  height: bigint
  min_self_delegation: bigint
  validator: validator_obj_rel_insert_input
  validator_address: String
}

"""aggregate max on columns"""
type validator_commission_max_fields {
  commission: numeric
  height: bigint
  min_self_delegation: bigint
  validator_address: String
}

"""
order by max() on columns of table "validator_commission"
"""
input validator_commission_max_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
  validator_address: order_by
}

"""aggregate min on columns"""
type validator_commission_min_fields {
  commission: numeric
  height: bigint
  min_self_delegation: bigint
  validator_address: String
}

"""
order by min() on columns of table "validator_commission"
"""
input validator_commission_min_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
  validator_address: order_by
}

"""
response of any mutation on the table "validator_commission"
"""
type validator_commission_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [validator_commission!]!
}

"""
on conflict condition type for table "validator_commission"
"""
input validator_commission_on_conflict {
  constraint: validator_commission_constraint!
  update_columns: [validator_commission_update_column!]! = []
  where: validator_commission_bool_exp
}

"""Ordering options when selecting data from "validator_commission"."""
input validator_commission_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
  validator: validator_order_by
  validator_address: order_by
}

"""primary key columns input for table: validator_commission"""
input validator_commission_pk_columns_input {
  validator_address: String!
}

"""
select columns of table "validator_commission"
"""
enum validator_commission_select_column {
  """column name"""
  commission

  """column name"""
  height

  """column name"""
  min_self_delegation

  """column name"""
  validator_address
}

"""
input type for updating data in table "validator_commission"
"""
input validator_commission_set_input {
  commission: numeric
  height: bigint
  min_self_delegation: bigint
  validator_address: String
}

"""aggregate stddev on columns"""
type validator_commission_stddev_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"""
order by stddev() on columns of table "validator_commission"
"""
input validator_commission_stddev_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"""aggregate stddev_pop on columns"""
type validator_commission_stddev_pop_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"""
order by stddev_pop() on columns of table "validator_commission"
"""
input validator_commission_stddev_pop_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"""aggregate stddev_samp on columns"""
type validator_commission_stddev_samp_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"""
order by stddev_samp() on columns of table "validator_commission"
"""
input validator_commission_stddev_samp_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"""aggregate sum on columns"""
type validator_commission_sum_fields {
  commission: numeric
  height: bigint
  min_self_delegation: bigint
}

"""
order by sum() on columns of table "validator_commission"
"""
input validator_commission_sum_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"""
update columns of table "validator_commission"
"""
enum validator_commission_update_column {
  """column name"""
  commission

  """column name"""
  height

  """column name"""
  min_self_delegation

  """column name"""
  validator_address
}

"""aggregate var_pop on columns"""
type validator_commission_var_pop_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"""
order by var_pop() on columns of table "validator_commission"
"""
input validator_commission_var_pop_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"""aggregate var_samp on columns"""
type validator_commission_var_samp_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"""
order by var_samp() on columns of table "validator_commission"
"""
input validator_commission_var_samp_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"""aggregate variance on columns"""
type validator_commission_variance_fields {
  commission: Float
  height: Float
  min_self_delegation: Float
}

"""
order by variance() on columns of table "validator_commission"
"""
input validator_commission_variance_order_by {
  commission: order_by
  height: order_by
  min_self_delegation: order_by
}

"""
unique or primary key constraints on table "validator"
"""
enum validator_constraint {
  """unique or primary key constraint"""
  validator_consensus_pubkey_key

  """unique or primary key constraint"""
  validator_pkey
}

"""
columns and relationships of "validator_description"
"""
type validator_description {
  avatar_url: String
  details: String
  height: bigint!
  identity: String
  moniker: String
  security_contact: String

  """An object relationship"""
  validator: validator!
  validator_address: String!
  website: String
}

"""
aggregated selection of "validator_description"
"""
type validator_description_aggregate {
  aggregate: validator_description_aggregate_fields
  nodes: [validator_description!]!
}

"""
aggregate fields of "validator_description"
"""
type validator_description_aggregate_fields {
  avg: validator_description_avg_fields
  count(columns: [validator_description_select_column!], distinct: Boolean): Int!
  max: validator_description_max_fields
  min: validator_description_min_fields
  stddev: validator_description_stddev_fields
  stddev_pop: validator_description_stddev_pop_fields
  stddev_samp: validator_description_stddev_samp_fields
  sum: validator_description_sum_fields
  var_pop: validator_description_var_pop_fields
  var_samp: validator_description_var_samp_fields
  variance: validator_description_variance_fields
}

"""
order by aggregate values of table "validator_description"
"""
input validator_description_aggregate_order_by {
  avg: validator_description_avg_order_by
  count: order_by
  max: validator_description_max_order_by
  min: validator_description_min_order_by
  stddev: validator_description_stddev_order_by
  stddev_pop: validator_description_stddev_pop_order_by
  stddev_samp: validator_description_stddev_samp_order_by
  sum: validator_description_sum_order_by
  var_pop: validator_description_var_pop_order_by
  var_samp: validator_description_var_samp_order_by
  variance: validator_description_variance_order_by
}

"""
input type for inserting array relation for remote table "validator_description"
"""
input validator_description_arr_rel_insert_input {
  data: [validator_description_insert_input!]!

  """on conflict condition"""
  on_conflict: validator_description_on_conflict
}

"""aggregate avg on columns"""
type validator_description_avg_fields {
  height: Float
}

"""
order by avg() on columns of table "validator_description"
"""
input validator_description_avg_order_by {
  height: order_by
}

"""
Boolean expression to filter rows from the table "validator_description". All fields are combined with a logical 'AND'.
"""
input validator_description_bool_exp {
  _and: [validator_description_bool_exp!]
  _not: validator_description_bool_exp
  _or: [validator_description_bool_exp!]
  avatar_url: String_comparison_exp
  details: String_comparison_exp
  height: bigint_comparison_exp
  identity: String_comparison_exp
  moniker: String_comparison_exp
  security_contact: String_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "validator_description"
"""
enum validator_description_constraint {
  """unique or primary key constraint"""
  validator_description_pkey
}

"""
input type for incrementing numeric columns in table "validator_description"
"""
input validator_description_inc_input {
  height: bigint
}

"""
input type for inserting data into table "validator_description"
"""
input validator_description_insert_input {
  avatar_url: String
  details: String
  height: bigint
  identity: String
  moniker: String
  security_contact: String
  validator: validator_obj_rel_insert_input
  validator_address: String
  website: String
}

"""aggregate max on columns"""
type validator_description_max_fields {
  avatar_url: String
  details: String
  height: bigint
  identity: String
  moniker: String
  security_contact: String
  validator_address: String
  website: String
}

"""
order by max() on columns of table "validator_description"
"""
input validator_description_max_order_by {
  avatar_url: order_by
  details: order_by
  height: order_by
  identity: order_by
  moniker: order_by
  security_contact: order_by
  validator_address: order_by
  website: order_by
}

"""aggregate min on columns"""
type validator_description_min_fields {
  avatar_url: String
  details: String
  height: bigint
  identity: String
  moniker: String
  security_contact: String
  validator_address: String
  website: String
}

"""
order by min() on columns of table "validator_description"
"""
input validator_description_min_order_by {
  avatar_url: order_by
  details: order_by
  height: order_by
  identity: order_by
  moniker: order_by
  security_contact: order_by
  validator_address: order_by
  website: order_by
}

"""
response of any mutation on the table "validator_description"
"""
type validator_description_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [validator_description!]!
}

"""
on conflict condition type for table "validator_description"
"""
input validator_description_on_conflict {
  constraint: validator_description_constraint!
  update_columns: [validator_description_update_column!]! = []
  where: validator_description_bool_exp
}

"""Ordering options when selecting data from "validator_description"."""
input validator_description_order_by {
  avatar_url: order_by
  details: order_by
  height: order_by
  identity: order_by
  moniker: order_by
  security_contact: order_by
  validator: validator_order_by
  validator_address: order_by
  website: order_by
}

"""primary key columns input for table: validator_description"""
input validator_description_pk_columns_input {
  validator_address: String!
}

"""
select columns of table "validator_description"
"""
enum validator_description_select_column {
  """column name"""
  avatar_url

  """column name"""
  details

  """column name"""
  height

  """column name"""
  identity

  """column name"""
  moniker

  """column name"""
  security_contact

  """column name"""
  validator_address

  """column name"""
  website
}

"""
input type for updating data in table "validator_description"
"""
input validator_description_set_input {
  avatar_url: String
  details: String
  height: bigint
  identity: String
  moniker: String
  security_contact: String
  validator_address: String
  website: String
}

"""aggregate stddev on columns"""
type validator_description_stddev_fields {
  height: Float
}

"""
order by stddev() on columns of table "validator_description"
"""
input validator_description_stddev_order_by {
  height: order_by
}

"""aggregate stddev_pop on columns"""
type validator_description_stddev_pop_fields {
  height: Float
}

"""
order by stddev_pop() on columns of table "validator_description"
"""
input validator_description_stddev_pop_order_by {
  height: order_by
}

"""aggregate stddev_samp on columns"""
type validator_description_stddev_samp_fields {
  height: Float
}

"""
order by stddev_samp() on columns of table "validator_description"
"""
input validator_description_stddev_samp_order_by {
  height: order_by
}

"""aggregate sum on columns"""
type validator_description_sum_fields {
  height: bigint
}

"""
order by sum() on columns of table "validator_description"
"""
input validator_description_sum_order_by {
  height: order_by
}

"""
update columns of table "validator_description"
"""
enum validator_description_update_column {
  """column name"""
  avatar_url

  """column name"""
  details

  """column name"""
  height

  """column name"""
  identity

  """column name"""
  moniker

  """column name"""
  security_contact

  """column name"""
  validator_address

  """column name"""
  website
}

"""aggregate var_pop on columns"""
type validator_description_var_pop_fields {
  height: Float
}

"""
order by var_pop() on columns of table "validator_description"
"""
input validator_description_var_pop_order_by {
  height: order_by
}

"""aggregate var_samp on columns"""
type validator_description_var_samp_fields {
  height: Float
}

"""
order by var_samp() on columns of table "validator_description"
"""
input validator_description_var_samp_order_by {
  height: order_by
}

"""aggregate variance on columns"""
type validator_description_variance_fields {
  height: Float
}

"""
order by variance() on columns of table "validator_description"
"""
input validator_description_variance_order_by {
  height: order_by
}

"""
columns and relationships of "validator_info"
"""
type validator_info {
  """An object relationship"""
  account: account
  consensus_address: String!
  height: bigint!
  max_change_rate: String!
  max_rate: String!
  operator_address: String!
  self_delegate_address: String

  """An object relationship"""
  validator: validator!
}

"""
aggregated selection of "validator_info"
"""
type validator_info_aggregate {
  aggregate: validator_info_aggregate_fields
  nodes: [validator_info!]!
}

"""
aggregate fields of "validator_info"
"""
type validator_info_aggregate_fields {
  avg: validator_info_avg_fields
  count(columns: [validator_info_select_column!], distinct: Boolean): Int!
  max: validator_info_max_fields
  min: validator_info_min_fields
  stddev: validator_info_stddev_fields
  stddev_pop: validator_info_stddev_pop_fields
  stddev_samp: validator_info_stddev_samp_fields
  sum: validator_info_sum_fields
  var_pop: validator_info_var_pop_fields
  var_samp: validator_info_var_samp_fields
  variance: validator_info_variance_fields
}

"""
order by aggregate values of table "validator_info"
"""
input validator_info_aggregate_order_by {
  avg: validator_info_avg_order_by
  count: order_by
  max: validator_info_max_order_by
  min: validator_info_min_order_by
  stddev: validator_info_stddev_order_by
  stddev_pop: validator_info_stddev_pop_order_by
  stddev_samp: validator_info_stddev_samp_order_by
  sum: validator_info_sum_order_by
  var_pop: validator_info_var_pop_order_by
  var_samp: validator_info_var_samp_order_by
  variance: validator_info_variance_order_by
}

"""
input type for inserting array relation for remote table "validator_info"
"""
input validator_info_arr_rel_insert_input {
  data: [validator_info_insert_input!]!

  """on conflict condition"""
  on_conflict: validator_info_on_conflict
}

"""aggregate avg on columns"""
type validator_info_avg_fields {
  height: Float
}

"""
order by avg() on columns of table "validator_info"
"""
input validator_info_avg_order_by {
  height: order_by
}

"""
Boolean expression to filter rows from the table "validator_info". All fields are combined with a logical 'AND'.
"""
input validator_info_bool_exp {
  _and: [validator_info_bool_exp!]
  _not: validator_info_bool_exp
  _or: [validator_info_bool_exp!]
  account: account_bool_exp
  consensus_address: String_comparison_exp
  height: bigint_comparison_exp
  max_change_rate: String_comparison_exp
  max_rate: String_comparison_exp
  operator_address: String_comparison_exp
  self_delegate_address: String_comparison_exp
  validator: validator_bool_exp
}

"""
unique or primary key constraints on table "validator_info"
"""
enum validator_info_constraint {
  """unique or primary key constraint"""
  validator_info_operator_address_key

  """unique or primary key constraint"""
  validator_info_pkey
}

"""
input type for incrementing numeric columns in table "validator_info"
"""
input validator_info_inc_input {
  height: bigint
}

"""
input type for inserting data into table "validator_info"
"""
input validator_info_insert_input {
  account: account_obj_rel_insert_input
  consensus_address: String
  height: bigint
  max_change_rate: String
  max_rate: String
  operator_address: String
  self_delegate_address: String
  validator: validator_obj_rel_insert_input
}

"""aggregate max on columns"""
type validator_info_max_fields {
  consensus_address: String
  height: bigint
  max_change_rate: String
  max_rate: String
  operator_address: String
  self_delegate_address: String
}

"""
order by max() on columns of table "validator_info"
"""
input validator_info_max_order_by {
  consensus_address: order_by
  height: order_by
  max_change_rate: order_by
  max_rate: order_by
  operator_address: order_by
  self_delegate_address: order_by
}

"""aggregate min on columns"""
type validator_info_min_fields {
  consensus_address: String
  height: bigint
  max_change_rate: String
  max_rate: String
  operator_address: String
  self_delegate_address: String
}

"""
order by min() on columns of table "validator_info"
"""
input validator_info_min_order_by {
  consensus_address: order_by
  height: order_by
  max_change_rate: order_by
  max_rate: order_by
  operator_address: order_by
  self_delegate_address: order_by
}

"""
response of any mutation on the table "validator_info"
"""
type validator_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [validator_info!]!
}

"""
input type for inserting object relation for remote table "validator_info"
"""
input validator_info_obj_rel_insert_input {
  data: validator_info_insert_input!

  """on conflict condition"""
  on_conflict: validator_info_on_conflict
}

"""
on conflict condition type for table "validator_info"
"""
input validator_info_on_conflict {
  constraint: validator_info_constraint!
  update_columns: [validator_info_update_column!]! = []
  where: validator_info_bool_exp
}

"""Ordering options when selecting data from "validator_info"."""
input validator_info_order_by {
  account: account_order_by
  consensus_address: order_by
  height: order_by
  max_change_rate: order_by
  max_rate: order_by
  operator_address: order_by
  self_delegate_address: order_by
  validator: validator_order_by
}

"""primary key columns input for table: validator_info"""
input validator_info_pk_columns_input {
  consensus_address: String!
}

"""
select columns of table "validator_info"
"""
enum validator_info_select_column {
  """column name"""
  consensus_address

  """column name"""
  height

  """column name"""
  max_change_rate

  """column name"""
  max_rate

  """column name"""
  operator_address

  """column name"""
  self_delegate_address
}

"""
input type for updating data in table "validator_info"
"""
input validator_info_set_input {
  consensus_address: String
  height: bigint
  max_change_rate: String
  max_rate: String
  operator_address: String
  self_delegate_address: String
}

"""aggregate stddev on columns"""
type validator_info_stddev_fields {
  height: Float
}

"""
order by stddev() on columns of table "validator_info"
"""
input validator_info_stddev_order_by {
  height: order_by
}

"""aggregate stddev_pop on columns"""
type validator_info_stddev_pop_fields {
  height: Float
}

"""
order by stddev_pop() on columns of table "validator_info"
"""
input validator_info_stddev_pop_order_by {
  height: order_by
}

"""aggregate stddev_samp on columns"""
type validator_info_stddev_samp_fields {
  height: Float
}

"""
order by stddev_samp() on columns of table "validator_info"
"""
input validator_info_stddev_samp_order_by {
  height: order_by
}

"""aggregate sum on columns"""
type validator_info_sum_fields {
  height: bigint
}

"""
order by sum() on columns of table "validator_info"
"""
input validator_info_sum_order_by {
  height: order_by
}

"""
update columns of table "validator_info"
"""
enum validator_info_update_column {
  """column name"""
  consensus_address

  """column name"""
  height

  """column name"""
  max_change_rate

  """column name"""
  max_rate

  """column name"""
  operator_address

  """column name"""
  self_delegate_address
}

"""aggregate var_pop on columns"""
type validator_info_var_pop_fields {
  height: Float
}

"""
order by var_pop() on columns of table "validator_info"
"""
input validator_info_var_pop_order_by {
  height: order_by
}

"""aggregate var_samp on columns"""
type validator_info_var_samp_fields {
  height: Float
}

"""
order by var_samp() on columns of table "validator_info"
"""
input validator_info_var_samp_order_by {
  height: order_by
}

"""aggregate variance on columns"""
type validator_info_variance_fields {
  height: Float
}

"""
order by variance() on columns of table "validator_info"
"""
input validator_info_variance_order_by {
  height: order_by
}

"""
input type for inserting data into table "validator"
"""
input validator_insert_input {
  blocks: block_arr_rel_insert_input
  consensus_address: String
  consensus_pubkey: String
  double_sign_votes: double_sign_vote_arr_rel_insert_input
  pre_commits: pre_commit_arr_rel_insert_input
  proposal_validator_status_snapshot: proposal_validator_status_snapshot_obj_rel_insert_input
  proposal_validator_status_snapshots: proposal_validator_status_snapshot_arr_rel_insert_input
  validator_commissions: validator_commission_arr_rel_insert_input
  validator_descriptions: validator_description_arr_rel_insert_input
  validator_info: validator_info_obj_rel_insert_input
  validator_infos: validator_info_arr_rel_insert_input
  validator_signing_infos: validator_signing_info_arr_rel_insert_input
  validator_statuses: validator_status_arr_rel_insert_input
  validator_voting_powers: validator_voting_power_arr_rel_insert_input
}

"""aggregate max on columns"""
type validator_max_fields {
  consensus_address: String
  consensus_pubkey: String
}

"""aggregate min on columns"""
type validator_min_fields {
  consensus_address: String
  consensus_pubkey: String
}

"""
response of any mutation on the table "validator"
"""
type validator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [validator!]!
}

"""
input type for inserting object relation for remote table "validator"
"""
input validator_obj_rel_insert_input {
  data: validator_insert_input!

  """on conflict condition"""
  on_conflict: validator_on_conflict
}

"""
on conflict condition type for table "validator"
"""
input validator_on_conflict {
  constraint: validator_constraint!
  update_columns: [validator_update_column!]! = []
  where: validator_bool_exp
}

"""Ordering options when selecting data from "validator"."""
input validator_order_by {
  blocks_aggregate: block_aggregate_order_by
  consensus_address: order_by
  consensus_pubkey: order_by
  double_sign_votes_aggregate: double_sign_vote_aggregate_order_by
  pre_commits_aggregate: pre_commit_aggregate_order_by
  proposal_validator_status_snapshot: proposal_validator_status_snapshot_order_by
  proposal_validator_status_snapshots_aggregate: proposal_validator_status_snapshot_aggregate_order_by
  validator_commissions_aggregate: validator_commission_aggregate_order_by
  validator_descriptions_aggregate: validator_description_aggregate_order_by
  validator_info: validator_info_order_by
  validator_infos_aggregate: validator_info_aggregate_order_by
  validator_signing_infos_aggregate: validator_signing_info_aggregate_order_by
  validator_statuses_aggregate: validator_status_aggregate_order_by
  validator_voting_powers_aggregate: validator_voting_power_aggregate_order_by
}

"""primary key columns input for table: validator"""
input validator_pk_columns_input {
  consensus_address: String!
}

"""
select columns of table "validator"
"""
enum validator_select_column {
  """column name"""
  consensus_address

  """column name"""
  consensus_pubkey
}

"""
input type for updating data in table "validator"
"""
input validator_set_input {
  consensus_address: String
  consensus_pubkey: String
}

"""
columns and relationships of "validator_signing_info"
"""
type validator_signing_info {
  height: bigint!
  index_offset: bigint!
  jailed_until: timestamp!
  missed_blocks_counter: bigint!
  start_height: bigint!
  tombstoned: Boolean!
  validator_address: String!
}

"""
aggregated selection of "validator_signing_info"
"""
type validator_signing_info_aggregate {
  aggregate: validator_signing_info_aggregate_fields
  nodes: [validator_signing_info!]!
}

"""
aggregate fields of "validator_signing_info"
"""
type validator_signing_info_aggregate_fields {
  avg: validator_signing_info_avg_fields
  count(columns: [validator_signing_info_select_column!], distinct: Boolean): Int!
  max: validator_signing_info_max_fields
  min: validator_signing_info_min_fields
  stddev: validator_signing_info_stddev_fields
  stddev_pop: validator_signing_info_stddev_pop_fields
  stddev_samp: validator_signing_info_stddev_samp_fields
  sum: validator_signing_info_sum_fields
  var_pop: validator_signing_info_var_pop_fields
  var_samp: validator_signing_info_var_samp_fields
  variance: validator_signing_info_variance_fields
}

"""
order by aggregate values of table "validator_signing_info"
"""
input validator_signing_info_aggregate_order_by {
  avg: validator_signing_info_avg_order_by
  count: order_by
  max: validator_signing_info_max_order_by
  min: validator_signing_info_min_order_by
  stddev: validator_signing_info_stddev_order_by
  stddev_pop: validator_signing_info_stddev_pop_order_by
  stddev_samp: validator_signing_info_stddev_samp_order_by
  sum: validator_signing_info_sum_order_by
  var_pop: validator_signing_info_var_pop_order_by
  var_samp: validator_signing_info_var_samp_order_by
  variance: validator_signing_info_variance_order_by
}

"""
input type for inserting array relation for remote table "validator_signing_info"
"""
input validator_signing_info_arr_rel_insert_input {
  data: [validator_signing_info_insert_input!]!

  """on conflict condition"""
  on_conflict: validator_signing_info_on_conflict
}

"""aggregate avg on columns"""
type validator_signing_info_avg_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"""
order by avg() on columns of table "validator_signing_info"
"""
input validator_signing_info_avg_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"""
Boolean expression to filter rows from the table "validator_signing_info". All fields are combined with a logical 'AND'.
"""
input validator_signing_info_bool_exp {
  _and: [validator_signing_info_bool_exp!]
  _not: validator_signing_info_bool_exp
  _or: [validator_signing_info_bool_exp!]
  height: bigint_comparison_exp
  index_offset: bigint_comparison_exp
  jailed_until: timestamp_comparison_exp
  missed_blocks_counter: bigint_comparison_exp
  start_height: bigint_comparison_exp
  tombstoned: Boolean_comparison_exp
  validator_address: String_comparison_exp
}

"""
unique or primary key constraints on table "validator_signing_info"
"""
enum validator_signing_info_constraint {
  """unique or primary key constraint"""
  validator_signing_info_pkey
}

"""
input type for incrementing numeric columns in table "validator_signing_info"
"""
input validator_signing_info_inc_input {
  height: bigint
  index_offset: bigint
  missed_blocks_counter: bigint
  start_height: bigint
}

"""
input type for inserting data into table "validator_signing_info"
"""
input validator_signing_info_insert_input {
  height: bigint
  index_offset: bigint
  jailed_until: timestamp
  missed_blocks_counter: bigint
  start_height: bigint
  tombstoned: Boolean
  validator_address: String
}

"""aggregate max on columns"""
type validator_signing_info_max_fields {
  height: bigint
  index_offset: bigint
  jailed_until: timestamp
  missed_blocks_counter: bigint
  start_height: bigint
  validator_address: String
}

"""
order by max() on columns of table "validator_signing_info"
"""
input validator_signing_info_max_order_by {
  height: order_by
  index_offset: order_by
  jailed_until: order_by
  missed_blocks_counter: order_by
  start_height: order_by
  validator_address: order_by
}

"""aggregate min on columns"""
type validator_signing_info_min_fields {
  height: bigint
  index_offset: bigint
  jailed_until: timestamp
  missed_blocks_counter: bigint
  start_height: bigint
  validator_address: String
}

"""
order by min() on columns of table "validator_signing_info"
"""
input validator_signing_info_min_order_by {
  height: order_by
  index_offset: order_by
  jailed_until: order_by
  missed_blocks_counter: order_by
  start_height: order_by
  validator_address: order_by
}

"""
response of any mutation on the table "validator_signing_info"
"""
type validator_signing_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [validator_signing_info!]!
}

"""
on conflict condition type for table "validator_signing_info"
"""
input validator_signing_info_on_conflict {
  constraint: validator_signing_info_constraint!
  update_columns: [validator_signing_info_update_column!]! = []
  where: validator_signing_info_bool_exp
}

"""Ordering options when selecting data from "validator_signing_info"."""
input validator_signing_info_order_by {
  height: order_by
  index_offset: order_by
  jailed_until: order_by
  missed_blocks_counter: order_by
  start_height: order_by
  tombstoned: order_by
  validator_address: order_by
}

"""primary key columns input for table: validator_signing_info"""
input validator_signing_info_pk_columns_input {
  validator_address: String!
}

"""
select columns of table "validator_signing_info"
"""
enum validator_signing_info_select_column {
  """column name"""
  height

  """column name"""
  index_offset

  """column name"""
  jailed_until

  """column name"""
  missed_blocks_counter

  """column name"""
  start_height

  """column name"""
  tombstoned

  """column name"""
  validator_address
}

"""
input type for updating data in table "validator_signing_info"
"""
input validator_signing_info_set_input {
  height: bigint
  index_offset: bigint
  jailed_until: timestamp
  missed_blocks_counter: bigint
  start_height: bigint
  tombstoned: Boolean
  validator_address: String
}

"""aggregate stddev on columns"""
type validator_signing_info_stddev_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"""
order by stddev() on columns of table "validator_signing_info"
"""
input validator_signing_info_stddev_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"""aggregate stddev_pop on columns"""
type validator_signing_info_stddev_pop_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"""
order by stddev_pop() on columns of table "validator_signing_info"
"""
input validator_signing_info_stddev_pop_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"""aggregate stddev_samp on columns"""
type validator_signing_info_stddev_samp_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"""
order by stddev_samp() on columns of table "validator_signing_info"
"""
input validator_signing_info_stddev_samp_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"""aggregate sum on columns"""
type validator_signing_info_sum_fields {
  height: bigint
  index_offset: bigint
  missed_blocks_counter: bigint
  start_height: bigint
}

"""
order by sum() on columns of table "validator_signing_info"
"""
input validator_signing_info_sum_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"""
update columns of table "validator_signing_info"
"""
enum validator_signing_info_update_column {
  """column name"""
  height

  """column name"""
  index_offset

  """column name"""
  jailed_until

  """column name"""
  missed_blocks_counter

  """column name"""
  start_height

  """column name"""
  tombstoned

  """column name"""
  validator_address
}

"""aggregate var_pop on columns"""
type validator_signing_info_var_pop_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"""
order by var_pop() on columns of table "validator_signing_info"
"""
input validator_signing_info_var_pop_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"""aggregate var_samp on columns"""
type validator_signing_info_var_samp_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"""
order by var_samp() on columns of table "validator_signing_info"
"""
input validator_signing_info_var_samp_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"""aggregate variance on columns"""
type validator_signing_info_variance_fields {
  height: Float
  index_offset: Float
  missed_blocks_counter: Float
  start_height: Float
}

"""
order by variance() on columns of table "validator_signing_info"
"""
input validator_signing_info_variance_order_by {
  height: order_by
  index_offset: order_by
  missed_blocks_counter: order_by
  start_height: order_by
}

"""
columns and relationships of "validator_status"
"""
type validator_status {
  height: bigint!
  jailed: Boolean!
  status: Int!
  tombstoned: Boolean!

  """An object relationship"""
  validator: validator!
  validator_address: String!
}

"""
aggregated selection of "validator_status"
"""
type validator_status_aggregate {
  aggregate: validator_status_aggregate_fields
  nodes: [validator_status!]!
}

"""
aggregate fields of "validator_status"
"""
type validator_status_aggregate_fields {
  avg: validator_status_avg_fields
  count(columns: [validator_status_select_column!], distinct: Boolean): Int!
  max: validator_status_max_fields
  min: validator_status_min_fields
  stddev: validator_status_stddev_fields
  stddev_pop: validator_status_stddev_pop_fields
  stddev_samp: validator_status_stddev_samp_fields
  sum: validator_status_sum_fields
  var_pop: validator_status_var_pop_fields
  var_samp: validator_status_var_samp_fields
  variance: validator_status_variance_fields
}

"""
order by aggregate values of table "validator_status"
"""
input validator_status_aggregate_order_by {
  avg: validator_status_avg_order_by
  count: order_by
  max: validator_status_max_order_by
  min: validator_status_min_order_by
  stddev: validator_status_stddev_order_by
  stddev_pop: validator_status_stddev_pop_order_by
  stddev_samp: validator_status_stddev_samp_order_by
  sum: validator_status_sum_order_by
  var_pop: validator_status_var_pop_order_by
  var_samp: validator_status_var_samp_order_by
  variance: validator_status_variance_order_by
}

"""
input type for inserting array relation for remote table "validator_status"
"""
input validator_status_arr_rel_insert_input {
  data: [validator_status_insert_input!]!

  """on conflict condition"""
  on_conflict: validator_status_on_conflict
}

"""aggregate avg on columns"""
type validator_status_avg_fields {
  height: Float
  status: Float
}

"""
order by avg() on columns of table "validator_status"
"""
input validator_status_avg_order_by {
  height: order_by
  status: order_by
}

"""
Boolean expression to filter rows from the table "validator_status". All fields are combined with a logical 'AND'.
"""
input validator_status_bool_exp {
  _and: [validator_status_bool_exp!]
  _not: validator_status_bool_exp
  _or: [validator_status_bool_exp!]
  height: bigint_comparison_exp
  jailed: Boolean_comparison_exp
  status: Int_comparison_exp
  tombstoned: Boolean_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
}

"""
unique or primary key constraints on table "validator_status"
"""
enum validator_status_constraint {
  """unique or primary key constraint"""
  validator_status_pkey
}

"""
input type for incrementing numeric columns in table "validator_status"
"""
input validator_status_inc_input {
  height: bigint
  status: Int
}

"""
input type for inserting data into table "validator_status"
"""
input validator_status_insert_input {
  height: bigint
  jailed: Boolean
  status: Int
  tombstoned: Boolean
  validator: validator_obj_rel_insert_input
  validator_address: String
}

"""aggregate max on columns"""
type validator_status_max_fields {
  height: bigint
  status: Int
  validator_address: String
}

"""
order by max() on columns of table "validator_status"
"""
input validator_status_max_order_by {
  height: order_by
  status: order_by
  validator_address: order_by
}

"""aggregate min on columns"""
type validator_status_min_fields {
  height: bigint
  status: Int
  validator_address: String
}

"""
order by min() on columns of table "validator_status"
"""
input validator_status_min_order_by {
  height: order_by
  status: order_by
  validator_address: order_by
}

"""
response of any mutation on the table "validator_status"
"""
type validator_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [validator_status!]!
}

"""
on conflict condition type for table "validator_status"
"""
input validator_status_on_conflict {
  constraint: validator_status_constraint!
  update_columns: [validator_status_update_column!]! = []
  where: validator_status_bool_exp
}

"""Ordering options when selecting data from "validator_status"."""
input validator_status_order_by {
  height: order_by
  jailed: order_by
  status: order_by
  tombstoned: order_by
  validator: validator_order_by
  validator_address: order_by
}

"""primary key columns input for table: validator_status"""
input validator_status_pk_columns_input {
  validator_address: String!
}

"""
select columns of table "validator_status"
"""
enum validator_status_select_column {
  """column name"""
  height

  """column name"""
  jailed

  """column name"""
  status

  """column name"""
  tombstoned

  """column name"""
  validator_address
}

"""
input type for updating data in table "validator_status"
"""
input validator_status_set_input {
  height: bigint
  jailed: Boolean
  status: Int
  tombstoned: Boolean
  validator_address: String
}

"""aggregate stddev on columns"""
type validator_status_stddev_fields {
  height: Float
  status: Float
}

"""
order by stddev() on columns of table "validator_status"
"""
input validator_status_stddev_order_by {
  height: order_by
  status: order_by
}

"""aggregate stddev_pop on columns"""
type validator_status_stddev_pop_fields {
  height: Float
  status: Float
}

"""
order by stddev_pop() on columns of table "validator_status"
"""
input validator_status_stddev_pop_order_by {
  height: order_by
  status: order_by
}

"""aggregate stddev_samp on columns"""
type validator_status_stddev_samp_fields {
  height: Float
  status: Float
}

"""
order by stddev_samp() on columns of table "validator_status"
"""
input validator_status_stddev_samp_order_by {
  height: order_by
  status: order_by
}

"""aggregate sum on columns"""
type validator_status_sum_fields {
  height: bigint
  status: Int
}

"""
order by sum() on columns of table "validator_status"
"""
input validator_status_sum_order_by {
  height: order_by
  status: order_by
}

"""
update columns of table "validator_status"
"""
enum validator_status_update_column {
  """column name"""
  height

  """column name"""
  jailed

  """column name"""
  status

  """column name"""
  tombstoned

  """column name"""
  validator_address
}

"""aggregate var_pop on columns"""
type validator_status_var_pop_fields {
  height: Float
  status: Float
}

"""
order by var_pop() on columns of table "validator_status"
"""
input validator_status_var_pop_order_by {
  height: order_by
  status: order_by
}

"""aggregate var_samp on columns"""
type validator_status_var_samp_fields {
  height: Float
  status: Float
}

"""
order by var_samp() on columns of table "validator_status"
"""
input validator_status_var_samp_order_by {
  height: order_by
  status: order_by
}

"""aggregate variance on columns"""
type validator_status_variance_fields {
  height: Float
  status: Float
}

"""
order by variance() on columns of table "validator_status"
"""
input validator_status_variance_order_by {
  height: order_by
  status: order_by
}

"""
update columns of table "validator"
"""
enum validator_update_column {
  """column name"""
  consensus_address

  """column name"""
  consensus_pubkey
}

"""
columns and relationships of "validator_voting_power"
"""
type validator_voting_power {
  """An object relationship"""
  block: block!
  height: bigint!

  """An object relationship"""
  validator: validator!
  validator_address: String!
  voting_power: bigint!
}

"""
aggregated selection of "validator_voting_power"
"""
type validator_voting_power_aggregate {
  aggregate: validator_voting_power_aggregate_fields
  nodes: [validator_voting_power!]!
}

"""
aggregate fields of "validator_voting_power"
"""
type validator_voting_power_aggregate_fields {
  avg: validator_voting_power_avg_fields
  count(columns: [validator_voting_power_select_column!], distinct: Boolean): Int!
  max: validator_voting_power_max_fields
  min: validator_voting_power_min_fields
  stddev: validator_voting_power_stddev_fields
  stddev_pop: validator_voting_power_stddev_pop_fields
  stddev_samp: validator_voting_power_stddev_samp_fields
  sum: validator_voting_power_sum_fields
  var_pop: validator_voting_power_var_pop_fields
  var_samp: validator_voting_power_var_samp_fields
  variance: validator_voting_power_variance_fields
}

"""
order by aggregate values of table "validator_voting_power"
"""
input validator_voting_power_aggregate_order_by {
  avg: validator_voting_power_avg_order_by
  count: order_by
  max: validator_voting_power_max_order_by
  min: validator_voting_power_min_order_by
  stddev: validator_voting_power_stddev_order_by
  stddev_pop: validator_voting_power_stddev_pop_order_by
  stddev_samp: validator_voting_power_stddev_samp_order_by
  sum: validator_voting_power_sum_order_by
  var_pop: validator_voting_power_var_pop_order_by
  var_samp: validator_voting_power_var_samp_order_by
  variance: validator_voting_power_variance_order_by
}

"""
input type for inserting array relation for remote table "validator_voting_power"
"""
input validator_voting_power_arr_rel_insert_input {
  data: [validator_voting_power_insert_input!]!

  """on conflict condition"""
  on_conflict: validator_voting_power_on_conflict
}

"""aggregate avg on columns"""
type validator_voting_power_avg_fields {
  height: Float
  voting_power: Float
}

"""
order by avg() on columns of table "validator_voting_power"
"""
input validator_voting_power_avg_order_by {
  height: order_by
  voting_power: order_by
}

"""
Boolean expression to filter rows from the table "validator_voting_power". All fields are combined with a logical 'AND'.
"""
input validator_voting_power_bool_exp {
  _and: [validator_voting_power_bool_exp!]
  _not: validator_voting_power_bool_exp
  _or: [validator_voting_power_bool_exp!]
  block: block_bool_exp
  height: bigint_comparison_exp
  validator: validator_bool_exp
  validator_address: String_comparison_exp
  voting_power: bigint_comparison_exp
}

"""
unique or primary key constraints on table "validator_voting_power"
"""
enum validator_voting_power_constraint {
  """unique or primary key constraint"""
  validator_voting_power_pkey
}

"""
input type for incrementing numeric columns in table "validator_voting_power"
"""
input validator_voting_power_inc_input {
  height: bigint
  voting_power: bigint
}

"""
input type for inserting data into table "validator_voting_power"
"""
input validator_voting_power_insert_input {
  block: block_obj_rel_insert_input
  height: bigint
  validator: validator_obj_rel_insert_input
  validator_address: String
  voting_power: bigint
}

"""aggregate max on columns"""
type validator_voting_power_max_fields {
  height: bigint
  validator_address: String
  voting_power: bigint
}

"""
order by max() on columns of table "validator_voting_power"
"""
input validator_voting_power_max_order_by {
  height: order_by
  validator_address: order_by
  voting_power: order_by
}

"""aggregate min on columns"""
type validator_voting_power_min_fields {
  height: bigint
  validator_address: String
  voting_power: bigint
}

"""
order by min() on columns of table "validator_voting_power"
"""
input validator_voting_power_min_order_by {
  height: order_by
  validator_address: order_by
  voting_power: order_by
}

"""
response of any mutation on the table "validator_voting_power"
"""
type validator_voting_power_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [validator_voting_power!]!
}

"""
on conflict condition type for table "validator_voting_power"
"""
input validator_voting_power_on_conflict {
  constraint: validator_voting_power_constraint!
  update_columns: [validator_voting_power_update_column!]! = []
  where: validator_voting_power_bool_exp
}

"""Ordering options when selecting data from "validator_voting_power"."""
input validator_voting_power_order_by {
  block: block_order_by
  height: order_by
  validator: validator_order_by
  validator_address: order_by
  voting_power: order_by
}

"""primary key columns input for table: validator_voting_power"""
input validator_voting_power_pk_columns_input {
  validator_address: String!
}

"""
select columns of table "validator_voting_power"
"""
enum validator_voting_power_select_column {
  """column name"""
  height

  """column name"""
  validator_address

  """column name"""
  voting_power
}

"""
input type for updating data in table "validator_voting_power"
"""
input validator_voting_power_set_input {
  height: bigint
  validator_address: String
  voting_power: bigint
}

"""aggregate stddev on columns"""
type validator_voting_power_stddev_fields {
  height: Float
  voting_power: Float
}

"""
order by stddev() on columns of table "validator_voting_power"
"""
input validator_voting_power_stddev_order_by {
  height: order_by
  voting_power: order_by
}

"""aggregate stddev_pop on columns"""
type validator_voting_power_stddev_pop_fields {
  height: Float
  voting_power: Float
}

"""
order by stddev_pop() on columns of table "validator_voting_power"
"""
input validator_voting_power_stddev_pop_order_by {
  height: order_by
  voting_power: order_by
}

"""aggregate stddev_samp on columns"""
type validator_voting_power_stddev_samp_fields {
  height: Float
  voting_power: Float
}

"""
order by stddev_samp() on columns of table "validator_voting_power"
"""
input validator_voting_power_stddev_samp_order_by {
  height: order_by
  voting_power: order_by
}

"""aggregate sum on columns"""
type validator_voting_power_sum_fields {
  height: bigint
  voting_power: bigint
}

"""
order by sum() on columns of table "validator_voting_power"
"""
input validator_voting_power_sum_order_by {
  height: order_by
  voting_power: order_by
}

"""
update columns of table "validator_voting_power"
"""
enum validator_voting_power_update_column {
  """column name"""
  height

  """column name"""
  validator_address

  """column name"""
  voting_power
}

"""aggregate var_pop on columns"""
type validator_voting_power_var_pop_fields {
  height: Float
  voting_power: Float
}

"""
order by var_pop() on columns of table "validator_voting_power"
"""
input validator_voting_power_var_pop_order_by {
  height: order_by
  voting_power: order_by
}

"""aggregate var_samp on columns"""
type validator_voting_power_var_samp_fields {
  height: Float
  voting_power: Float
}

"""
order by var_samp() on columns of table "validator_voting_power"
"""
input validator_voting_power_var_samp_order_by {
  height: order_by
  voting_power: order_by
}

"""aggregate variance on columns"""
type validator_voting_power_variance_fields {
  height: Float
  voting_power: Float
}

"""
order by variance() on columns of table "validator_voting_power"
"""
input validator_voting_power_variance_order_by {
  height: order_by
  voting_power: order_by
}

"""
columns and relationships of "vesting_account"
"""
type vesting_account {
  """An object relationship"""
  account: account!
  address: String!
  end_time: timestamp!
  id: Int!
  original_vesting: _coin!
  start_time: timestamp
  type: String!

  """An array relationship"""
  vesting_periods(
    """distinct select on columns"""
    distinct_on: [vesting_period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_period_order_by!]

    """filter the rows returned"""
    where: vesting_period_bool_exp
  ): [vesting_period!]!

  """An aggregate relationship"""
  vesting_periods_aggregate(
    """distinct select on columns"""
    distinct_on: [vesting_period_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vesting_period_order_by!]

    """filter the rows returned"""
    where: vesting_period_bool_exp
  ): vesting_period_aggregate!
}

"""
aggregated selection of "vesting_account"
"""
type vesting_account_aggregate {
  aggregate: vesting_account_aggregate_fields
  nodes: [vesting_account!]!
}

"""
aggregate fields of "vesting_account"
"""
type vesting_account_aggregate_fields {
  avg: vesting_account_avg_fields
  count(columns: [vesting_account_select_column!], distinct: Boolean): Int!
  max: vesting_account_max_fields
  min: vesting_account_min_fields
  stddev: vesting_account_stddev_fields
  stddev_pop: vesting_account_stddev_pop_fields
  stddev_samp: vesting_account_stddev_samp_fields
  sum: vesting_account_sum_fields
  var_pop: vesting_account_var_pop_fields
  var_samp: vesting_account_var_samp_fields
  variance: vesting_account_variance_fields
}

"""
order by aggregate values of table "vesting_account"
"""
input vesting_account_aggregate_order_by {
  avg: vesting_account_avg_order_by
  count: order_by
  max: vesting_account_max_order_by
  min: vesting_account_min_order_by
  stddev: vesting_account_stddev_order_by
  stddev_pop: vesting_account_stddev_pop_order_by
  stddev_samp: vesting_account_stddev_samp_order_by
  sum: vesting_account_sum_order_by
  var_pop: vesting_account_var_pop_order_by
  var_samp: vesting_account_var_samp_order_by
  variance: vesting_account_variance_order_by
}

"""
input type for inserting array relation for remote table "vesting_account"
"""
input vesting_account_arr_rel_insert_input {
  data: [vesting_account_insert_input!]!

  """on conflict condition"""
  on_conflict: vesting_account_on_conflict
}

"""aggregate avg on columns"""
type vesting_account_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "vesting_account"
"""
input vesting_account_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "vesting_account". All fields are combined with a logical 'AND'.
"""
input vesting_account_bool_exp {
  _and: [vesting_account_bool_exp!]
  _not: vesting_account_bool_exp
  _or: [vesting_account_bool_exp!]
  account: account_bool_exp
  address: String_comparison_exp
  end_time: timestamp_comparison_exp
  id: Int_comparison_exp
  original_vesting: _coin_comparison_exp
  start_time: timestamp_comparison_exp
  type: String_comparison_exp
  vesting_periods: vesting_period_bool_exp
}

"""
unique or primary key constraints on table "vesting_account"
"""
enum vesting_account_constraint {
  """unique or primary key constraint"""
  vesting_account_address_idx

  """unique or primary key constraint"""
  vesting_account_pkey
}

"""
input type for incrementing numeric columns in table "vesting_account"
"""
input vesting_account_inc_input {
  id: Int
}

"""
input type for inserting data into table "vesting_account"
"""
input vesting_account_insert_input {
  account: account_obj_rel_insert_input
  address: String
  end_time: timestamp
  id: Int
  original_vesting: _coin
  start_time: timestamp
  type: String
  vesting_periods: vesting_period_arr_rel_insert_input
}

"""aggregate max on columns"""
type vesting_account_max_fields {
  address: String
  end_time: timestamp
  id: Int
  start_time: timestamp
  type: String
}

"""
order by max() on columns of table "vesting_account"
"""
input vesting_account_max_order_by {
  address: order_by
  end_time: order_by
  id: order_by
  start_time: order_by
  type: order_by
}

"""aggregate min on columns"""
type vesting_account_min_fields {
  address: String
  end_time: timestamp
  id: Int
  start_time: timestamp
  type: String
}

"""
order by min() on columns of table "vesting_account"
"""
input vesting_account_min_order_by {
  address: order_by
  end_time: order_by
  id: order_by
  start_time: order_by
  type: order_by
}

"""
response of any mutation on the table "vesting_account"
"""
type vesting_account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [vesting_account!]!
}

"""
input type for inserting object relation for remote table "vesting_account"
"""
input vesting_account_obj_rel_insert_input {
  data: vesting_account_insert_input!

  """on conflict condition"""
  on_conflict: vesting_account_on_conflict
}

"""
on conflict condition type for table "vesting_account"
"""
input vesting_account_on_conflict {
  constraint: vesting_account_constraint!
  update_columns: [vesting_account_update_column!]! = []
  where: vesting_account_bool_exp
}

"""Ordering options when selecting data from "vesting_account"."""
input vesting_account_order_by {
  account: account_order_by
  address: order_by
  end_time: order_by
  id: order_by
  original_vesting: order_by
  start_time: order_by
  type: order_by
  vesting_periods_aggregate: vesting_period_aggregate_order_by
}

"""primary key columns input for table: vesting_account"""
input vesting_account_pk_columns_input {
  id: Int!
}

"""
select columns of table "vesting_account"
"""
enum vesting_account_select_column {
  """column name"""
  address

  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  original_vesting

  """column name"""
  start_time

  """column name"""
  type
}

"""
input type for updating data in table "vesting_account"
"""
input vesting_account_set_input {
  address: String
  end_time: timestamp
  id: Int
  original_vesting: _coin
  start_time: timestamp
  type: String
}

"""aggregate stddev on columns"""
type vesting_account_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "vesting_account"
"""
input vesting_account_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type vesting_account_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "vesting_account"
"""
input vesting_account_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type vesting_account_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "vesting_account"
"""
input vesting_account_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type vesting_account_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "vesting_account"
"""
input vesting_account_sum_order_by {
  id: order_by
}

"""
update columns of table "vesting_account"
"""
enum vesting_account_update_column {
  """column name"""
  address

  """column name"""
  end_time

  """column name"""
  id

  """column name"""
  original_vesting

  """column name"""
  start_time

  """column name"""
  type
}

"""aggregate var_pop on columns"""
type vesting_account_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "vesting_account"
"""
input vesting_account_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type vesting_account_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "vesting_account"
"""
input vesting_account_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type vesting_account_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "vesting_account"
"""
input vesting_account_variance_order_by {
  id: order_by
}

"""
columns and relationships of "vesting_period"
"""
type vesting_period {
  amount: _coin!
  length: bigint!
  period_order: bigint!

  """An object relationship"""
  vesting_account: vesting_account!
  vesting_account_id: bigint!
}

"""
aggregated selection of "vesting_period"
"""
type vesting_period_aggregate {
  aggregate: vesting_period_aggregate_fields
  nodes: [vesting_period!]!
}

"""
aggregate fields of "vesting_period"
"""
type vesting_period_aggregate_fields {
  avg: vesting_period_avg_fields
  count(columns: [vesting_period_select_column!], distinct: Boolean): Int!
  max: vesting_period_max_fields
  min: vesting_period_min_fields
  stddev: vesting_period_stddev_fields
  stddev_pop: vesting_period_stddev_pop_fields
  stddev_samp: vesting_period_stddev_samp_fields
  sum: vesting_period_sum_fields
  var_pop: vesting_period_var_pop_fields
  var_samp: vesting_period_var_samp_fields
  variance: vesting_period_variance_fields
}

"""
order by aggregate values of table "vesting_period"
"""
input vesting_period_aggregate_order_by {
  avg: vesting_period_avg_order_by
  count: order_by
  max: vesting_period_max_order_by
  min: vesting_period_min_order_by
  stddev: vesting_period_stddev_order_by
  stddev_pop: vesting_period_stddev_pop_order_by
  stddev_samp: vesting_period_stddev_samp_order_by
  sum: vesting_period_sum_order_by
  var_pop: vesting_period_var_pop_order_by
  var_samp: vesting_period_var_samp_order_by
  variance: vesting_period_variance_order_by
}

"""
input type for inserting array relation for remote table "vesting_period"
"""
input vesting_period_arr_rel_insert_input {
  data: [vesting_period_insert_input!]!
}

"""aggregate avg on columns"""
type vesting_period_avg_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"""
order by avg() on columns of table "vesting_period"
"""
input vesting_period_avg_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"""
Boolean expression to filter rows from the table "vesting_period". All fields are combined with a logical 'AND'.
"""
input vesting_period_bool_exp {
  _and: [vesting_period_bool_exp!]
  _not: vesting_period_bool_exp
  _or: [vesting_period_bool_exp!]
  amount: _coin_comparison_exp
  length: bigint_comparison_exp
  period_order: bigint_comparison_exp
  vesting_account: vesting_account_bool_exp
  vesting_account_id: bigint_comparison_exp
}

"""
input type for incrementing numeric columns in table "vesting_period"
"""
input vesting_period_inc_input {
  length: bigint
  period_order: bigint
  vesting_account_id: bigint
}

"""
input type for inserting data into table "vesting_period"
"""
input vesting_period_insert_input {
  amount: _coin
  length: bigint
  period_order: bigint
  vesting_account: vesting_account_obj_rel_insert_input
  vesting_account_id: bigint
}

"""aggregate max on columns"""
type vesting_period_max_fields {
  length: bigint
  period_order: bigint
  vesting_account_id: bigint
}

"""
order by max() on columns of table "vesting_period"
"""
input vesting_period_max_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"""aggregate min on columns"""
type vesting_period_min_fields {
  length: bigint
  period_order: bigint
  vesting_account_id: bigint
}

"""
order by min() on columns of table "vesting_period"
"""
input vesting_period_min_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"""
response of any mutation on the table "vesting_period"
"""
type vesting_period_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [vesting_period!]!
}

"""Ordering options when selecting data from "vesting_period"."""
input vesting_period_order_by {
  amount: order_by
  length: order_by
  period_order: order_by
  vesting_account: vesting_account_order_by
  vesting_account_id: order_by
}

"""
select columns of table "vesting_period"
"""
enum vesting_period_select_column {
  """column name"""
  amount

  """column name"""
  length

  """column name"""
  period_order

  """column name"""
  vesting_account_id
}

"""
input type for updating data in table "vesting_period"
"""
input vesting_period_set_input {
  amount: _coin
  length: bigint
  period_order: bigint
  vesting_account_id: bigint
}

"""aggregate stddev on columns"""
type vesting_period_stddev_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"""
order by stddev() on columns of table "vesting_period"
"""
input vesting_period_stddev_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"""aggregate stddev_pop on columns"""
type vesting_period_stddev_pop_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"""
order by stddev_pop() on columns of table "vesting_period"
"""
input vesting_period_stddev_pop_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"""aggregate stddev_samp on columns"""
type vesting_period_stddev_samp_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"""
order by stddev_samp() on columns of table "vesting_period"
"""
input vesting_period_stddev_samp_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"""aggregate sum on columns"""
type vesting_period_sum_fields {
  length: bigint
  period_order: bigint
  vesting_account_id: bigint
}

"""
order by sum() on columns of table "vesting_period"
"""
input vesting_period_sum_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"""aggregate var_pop on columns"""
type vesting_period_var_pop_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"""
order by var_pop() on columns of table "vesting_period"
"""
input vesting_period_var_pop_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"""aggregate var_samp on columns"""
type vesting_period_var_samp_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"""
order by var_samp() on columns of table "vesting_period"
"""
input vesting_period_var_samp_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

"""aggregate variance on columns"""
type vesting_period_variance_fields {
  length: Float
  period_order: Float
  vesting_account_id: Float
}

"""
order by variance() on columns of table "vesting_period"
"""
input vesting_period_variance_order_by {
  length: order_by
  period_order: order_by
  vesting_account_id: order_by
}

